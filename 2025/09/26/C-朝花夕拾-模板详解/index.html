<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="https://lyroom.github.io">
  <title>C++朝花夕拾-模板详解 | Henry&#39;Blog</title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="description" content="模板详解模板基础C++ 模板（Templates）是现代 C++ 中强大而灵活的特性，支持泛型编程，使得代码更具复用性和类型安全性。模板不仅包括基本的函数模板和类模板，还涵盖了模板特化（全特化与偏特化）、模板参数种类、变参模板（Variadic Templates）、模板元编程（Template Metaprogramming）、SFINAE（Substitution Failure Is Not">
<meta property="og:type" content="article">
<meta property="og:title" content="C++朝花夕拾-模板详解">
<meta property="og:url" content="https://lyroom.github.io/2025/09/26/C-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%E6%A8%A1%E6%9D%BF%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Henry&#39;Blog">
<meta property="og:description" content="模板详解模板基础C++ 模板（Templates）是现代 C++ 中强大而灵活的特性，支持泛型编程，使得代码更具复用性和类型安全性。模板不仅包括基本的函数模板和类模板，还涵盖了模板特化（全特化与偏特化）、模板参数种类、变参模板（Variadic Templates）、模板元编程（Template Metaprogramming）、SFINAE（Substitution Failure Is Not">
<meta property="og:locale">
<meta property="article:published_time" content="2025-09-26T08:19:24.000Z">
<meta property="article:modified_time" content="2025-09-26T08:19:24.000Z">
<meta property="article:author" content="迪丽惹Bug">
<meta property="article:tag" content="Henry,博客">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Henry&#39;Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
    <link rel="apple-touch-icon" href="/apple-touch-icon-180x180.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.a5fda8.css">
  <style type="text/css">
    
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

  
  


  

</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      


<div class="overlay" style="background: #4d4d4d;background: url('/img/%E8%83%8C%E6%99%AF.jpg') no-repeat ;"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/img/%E5%A4%B4%E5%83%8F.jpg" class="js-avatar">
		</a>
		<hgroup>
			<h1 class="header-author"><a href="/">迪丽惹Bug</a></h1>
		</hgroup>
		
		<p class="header-subtitle">宇宙很大，生活更大</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/" target="_blank">主页</a></li>
			
				<li><a href="/tags/%E6%B5%AE%E7%94%9F%E5%85%AD%E8%AE%B0/" target="_blank">浮生六记</a></li>
			
				<li><a href="/archives" target="_blank">归档</a></li>
			
			</ul>
		</nav>
		<nav class="header-smart-menu">
			
				
					<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
				
			
				
			
				
					<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
				
			
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					
						<a class="github" href="https://github.com/HenryMorgan911" 
												title="GitHub" target="_blank"><i class="icon-github"></i></a>
					
				
					
						<a class="gitee" href="https://gitee.com/HenryMorgan911" 
												title="码云" target="_blank"><i class="icon-gitee"></i></a>
					
				
					
						<a class="bilibili" href="https://space.bilibili.com/277372350" 
												title="哔哩哔哩" target="_blank"><i class="icon-bilibili"></i></a>
					
				
			</div>
		
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<a href="/">
					<img src="/img/%E5%A4%B4%E5%83%8F.jpg" class="js-avatar">
				</a>
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">迪丽惹Bug</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>宇宙很大，生活更大<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						
						<a class="github" target="_blank" 
							href="https://github.com/HenryMorgan911" title="GitHub"><i class="icon-github"></i></a>
						
					
						
						<a class="gitee" target="_blank" 
							href="https://gitee.com/HenryMorgan911" title="码云"><i class="icon-gitee"></i></a>
						
					
						
						<a class="bilibili" target="_blank" 
							href="https://space.bilibili.com/277372350" title="哔哩哔哩"><i class="icon-bilibili"></i></a>
						
					
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 33.333333333333336%"><a href="/">主页</a></li>
		        
					<li style="width: 33.333333333333336%"><a href="/tags/%E6%B5%AE%E7%94%9F%E5%85%AD%E8%AE%B0/">浮生六记</a></li>
		        
					<li style="width: 33.333333333333336%"><a href="/archives">归档</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1"
              class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            <article id="post-C-朝花夕拾-模板详解" class="article article-type-post " itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
  
  
    <h1 class="article-title" itemprop="name">
      C++朝花夕拾-模板详解
    </h1>
  


  
  
        
        <span id="busuanzi_container_page_pv" style='display:none' class="archive-article-date">
              <i class="icon-smile icon"></i> 阅读数：<span id="busuanzi_value_page_pv"></span>次
        </span>

<a href="/2025/09/26/C-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%E6%A8%A1%E6%9D%BF%E8%AF%A6%E8%A7%A3/" class="archive-article-date">
        <time datetime="2025-09-26T08:19:24.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2025-09-26</time>
</a>

  
  
    
<div style="margin-top:10px;">
  <span class="post-time">
    <span class="post-meta-item-icon">
      <!-- fonts.scss -->
      <!-- 百度字体平台:http://fontstore.baidu.com/static/editor/index.html -->
      <i class="icon-statistics"></i>
      <span class="post-meta-item-text"> 字数统计:</span>
      <span class="post-count">15.4k字</span>
    </span>
  </span>

  <span class="post-time">
    &nbsp; | &nbsp;
    <span class="post-meta-item-icon">
      <i class="icon-book icon"></i>
      <span class="post-meta-item-text"> 阅读时长≈</span>
      <span class="post-count">66分</span>
    </span>
  </span>
</div>


  
  </header>
  
  <div class="article-entry" itemprop="articleBody">
    
    <h1 id="模板详解"><a href="#模板详解" class="headerlink" title="模板详解"></a>模板详解</h1><h2 id="模板基础"><a href="#模板基础" class="headerlink" title="模板基础"></a>模板基础</h2><p>C++ 模板（Templates）是现代 C++ 中强大而灵活的特性，支持泛型编程，使得代码更具复用性和类型安全性。模板不仅包括基本的函数模板和类模板，还涵盖了模板特化（全特化与偏特化）、模板参数种类、变参模板（Variadic Templates）、模板元编程（Template Metaprogramming）、SFINAE（Substitution Failure Is Not An Error）等高级内容。</p>
<span id="more"></span>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>函数模板允许编写通用的函数，通过类型参数化，使其能够处理不同的数据类型。它通过模板参数定义与类型无关的函数。</p>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">functionName</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例：最大值函数"><a href="#示例：最大值函数" class="headerlink" title="示例：最大值函数"></a>示例：最大值函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">maxValue</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">maxValue</span>(<span class="number">3</span>, <span class="number">7</span>) &lt;&lt; std::endl;         <span class="comment">// int 类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">maxValue</span>(<span class="number">3.14</span>, <span class="number">2.72</span>) &lt;&lt; std::endl;  <span class="comment">// double 类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">maxValue</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;z&#x27;</span>) &lt;&lt; std::endl;    <span class="comment">// char 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">3.14</span><br><span class="line">z</span><br></pre></td></tr></table></figure>

<h4 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h4><ul>
<li>模板参数列表以 <code>template &lt;typename T&gt;</code> 或 <code>template &lt;class T&gt;</code> 开头，两者等价。</li>
<li>类型推导：编译器根据函数参数自动推导模板参数类型。</li>
</ul>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板允许定义通用的类，通过类型参数化，实现不同类型的对象。</p>
<h4 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T memberVariable;</span><br><span class="line">    <span class="comment">// 构造函数、成员函数等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="示例：简单的-Pair-类"><a href="#示例：简单的-Pair-类" class="headerlink" title="示例：简单的 Pair 类"></a>示例：简单的 Pair 类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T first;</span><br><span class="line">    U second;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Pair</span>(T a, U b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pair: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">print</span>(); <span class="comment">// 输出：Pair: 1, 2.5</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Pair&lt;std::string, std::string&gt; <span class="title">p2</span><span class="params">(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">    p2.<span class="built_in">print</span>(); <span class="comment">// 输出：Pair: Hello, World</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Pair&lt;std::string, <span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="string">&quot;Age&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    p3.<span class="built_in">print</span>(); <span class="comment">// 输出：Pair: Age, 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a><strong>输出：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair: 1, 2.5</span><br><span class="line">Pair: Hello, World</span><br><span class="line">Pair: Age, 30</span><br></pre></td></tr></table></figure>

<h4 id="要点：-1"><a href="#要点：-1" class="headerlink" title="要点："></a>要点：</h4><ul>
<li>类模板可以有多个类型参数。</li>
<li>模板参数可以被用于成员变量和成员函数中。</li>
<li>类模板实例化时指定具体类型，如 <code>Pair&lt;int, double&gt;</code>。</li>
</ul>
<h2 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h2><p>模板参数决定了模板的泛用性与灵活性。C++ 模板参数种类主要包括类型参数、非类型参数和模板模板参数。</p>
<h3 id="类型参数（Type-Parameters）"><a href="#类型参数（Type-Parameters）" class="headerlink" title="类型参数（Type Parameters）"></a>类型参数（Type Parameters）</h3><p>类型参数用于表示任意类型，在模板实例化时被具体的类型替代。</p>
<h3 id="非类型参数（Non-Type-Parameters）"><a href="#非类型参数（Non-Type-Parameters）" class="headerlink" title="非类型参数（Non-Type Parameters）"></a>非类型参数（Non-Type Parameters）</h3><p>非类型参数允许模板接受非类型的值，如整数、指针或引用。C++17 支持更多非类型参数类型，如 auto。</p>
<h4 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> Size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="示例：固定大小的数组类"><a href="#示例：固定大小的数组类" class="headerlink" title="示例：固定大小的数组类"></a>示例：固定大小的数组类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) &#123; <span class="keyword">return</span> data[index]; &#125;</span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span> &#123; <span class="keyword">return</span> data[index]; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            data[i] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Array&lt;<span class="type">int</span>, <span class="number">5</span>&gt; arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 10 20 30 40 </span><br></pre></td></tr></table></figure>

<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul>
<li>非类型参数必须是编译期常量。</li>
<li>允许的类型包括整型、枚举、指针、引用等，但不包括浮点数和类类型。</li>
</ul>
<h3 id="模板模板参数（Template-Template-Parameters）"><a href="#模板模板参数（Template-Template-Parameters）" class="headerlink" title="模板模板参数（Template Template Parameters）"></a>模板模板参数（Template Template Parameters）</h3><p>模板模板参数允许模板接受另一个模板作为参数。这对于抽象容器和策略模式等场景非常有用。</p>
<h4 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="示例：容器适配器"><a href="#示例：容器适配器" class="headerlink" title="示例：容器适配器"></a>示例：容器适配器</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;<span class="type">int</span>&gt; elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; elements.<span class="built_in">push_back</span>(value); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; elements.<span class="built_in">pop_back</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> elements.<span class="built_in">back</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack&lt;std::vector&gt; stack1;</span><br><span class="line">    Stack&lt;std::deque&gt; stack2;</span><br><span class="line">    </span><br><span class="line">    stack1.<span class="built_in">push</span>(<span class="number">1</span>); stack1.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    stack2.<span class="built_in">push</span>(<span class="number">3</span>); stack2.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; stack1.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; stack2.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 4</span><br></pre></td></tr></table></figure>

<h4 id="要点：-2"><a href="#要点：-2" class="headerlink" title="要点："></a>要点：</h4><ul>
<li>模板模板参数需要完全匹配被接受模板的参数列表。</li>
<li>可通过默认模板参数增强灵活性。</li>
</ul>
<h2 id="模板特化（Template-Specialization）"><a href="#模板特化（Template-Specialization）" class="headerlink" title="模板特化（Template Specialization）"></a>模板特化（Template Specialization）</h2><p>模板特化允许开发者为特定类型或类型组合提供专门的实现。当通用模板无法满足特定需求时，特化模板可以调整行为以处理特定的情况。C++ 支持全特化（Full Specialization）<em>和</em>偏特化（Partial Specialization），但需要注意的是，函数模板不支持偏特化，只能进行全特化。</p>
<h3 id="全特化（Full-Specialization）"><a href="#全特化（Full-Specialization）" class="headerlink" title="全特化（Full Specialization）"></a>全特化（Full Specialization）</h3><p>全特化是针对模板参数的完全特定类型组合。它提供了模板的一个特定版本，当模板参数完全匹配特化类型时，编译器将优先使用该特化版本。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&lt;SpecificType&gt; &#123;</span><br><span class="line">    <span class="comment">// 特化实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="示例：类模板全特化"><a href="#示例：类模板全特化" class="headerlink" title="示例：类模板全特化"></a>示例：类模板全特化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;General Printer: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>&lt;std::string&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String Printer: \&quot;&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Printer&lt;<span class="type">int</span>&gt; intPrinter;</span><br><span class="line">    Printer&lt;std::string&gt; stringPrinter;</span><br><span class="line">    </span><br><span class="line">    intPrinter.<span class="built_in">print</span>(<span class="number">42</span>);</span><br><span class="line">    stringPrinter.<span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">General Printer: 42</span><br><span class="line">String Printer: &quot;Hello World&quot;</span><br></pre></td></tr></table></figure>

<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ul>
<li>通用模板适用于所有类型，在print函数中以通用方式输出值。</li>
<li>全特化模板针对std::string类型进行了专门化，实现了不同的print函数。</li>
<li>当实例化<code>Printer&lt;std::string&gt;</code>时，编译器选择全特化版本而非通用模板。</li>
</ul>
<h3 id="偏特化（Partial-Specialization）"><a href="#偏特化（Partial-Specialization）" class="headerlink" title="偏特化（Partial Specialization）"></a>偏特化（Partial Specialization）</h3><p>偏特化允许模板对部分参数进行特定类型的处理，同时保持其他参数的通用性。对于类模板而言，可以针对模板参数的某些特性进行偏特化；对于函数模板，则仅支持全特化，不支持偏特化。</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&lt;T, U*&gt; &#123;  <span class="comment">// 偏特化：当U是指针类型时</span></span><br><span class="line">    <span class="comment">// 特化实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="示例：类模板偏特化"><a href="#示例：类模板偏特化" class="headerlink" title="示例：类模板偏特化"></a>示例：类模板偏特化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T first;</span><br><span class="line">    U second;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;General Pair: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化版本：当第二个类型是指针时</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T, U*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T first;</span><br><span class="line">    U* second;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pointer Pair: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (second) &#123;</span><br><span class="line">            std::cout &lt;&lt; *second;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;nullptr&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line">    <span class="function">Pair&lt;<span class="type">int</span>, <span class="type">int</span>*&gt; <span class="title">p2</span><span class="params">(<span class="number">20</span>, &amp;value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    p1.<span class="built_in">print</span>();</span><br><span class="line">    p2.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">General Pair: 10, 3.14</span><br><span class="line">Pointer Pair: 20, 100</span><br></pre></td></tr></table></figure>

<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><ul>
<li>通用模板处理非指针类型对。</li>
<li>偏特化模板处理第二个类型为指针的情况，打印指针指向的值。</li>
<li>使用偏特化提升了模板的灵活性，使其能够根据部分参数类型进行不同处理。</li>
</ul>
<h3 id="函数模板的特化"><a href="#函数模板的特化" class="headerlink" title="函数模板的特化"></a>函数模板的特化</h3><p>与类模板不同，函数模板不支持偏特化，只能进行全特化。当对函数模板进行全特化时，需要显式指定类型。</p>
<h4 id="示例：函数模板全特化"><a href="#示例：函数模板全特化" class="headerlink" title="示例：函数模板全特化"></a>示例：函数模板全特化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;General value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">printValue</span>&lt;std::string&gt;(<span class="type">const</span> std::string&amp; value) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;String value: \&quot;&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">printValue</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">General value: 42</span><br><span class="line">General value: 3.14</span><br><span class="line">String value: &quot;Hello&quot;</span><br></pre></td></tr></table></figure>

<h4 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h4><ul>
<li>通用函数模板适用于所有类型，提供通用的printValue实现。</li>
<li>全特化函数模板专门处理std::string类型，提供不同的输出格式。</li>
<li>调用printValue时，编译器根据实参类型选择适当的模板版本。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>优先级</strong>：全特化版本的优先级高于通用模板，因此当特化条件满足时，总是选择特化版本。</li>
<li><strong>显式指定类型</strong>：函数模板特化需要在调用时显式指定类型，或者确保类型推导可以正确匹配特化版本。</li>
<li><strong>不支持偏特化</strong>：无法通过偏特化对函数模板进行部分特化，需要通过其他方法（如重载）实现类似功能。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>全特化适用于为具体类型或类型组合提供专门实现，适用于类模板和函数模板。</li>
<li>偏特化仅适用于类模板，允许针对部分参数进行特定处理，同时保持其他参数的通用性。</li>
<li>函数模板仅支持全特化，不支持偏特化；类模板支持全特化和偏特化。</li>
<li>特化模板提升了模板的灵活性和适应性，使其能够根据不同类型需求调整行为。</li>
</ul>
<h2 id="变参模板（Variadic-Templates）"><a href="#变参模板（Variadic-Templates）" class="headerlink" title="变参模板（Variadic Templates）"></a>变参模板（Variadic Templates）</h2><p>变参模板允许模板接受可变数量的参数，提供极高的灵活性，是实现诸如 std::tuple、std::variant 等模板库组件的基础。</p>
<h3 id="定义与语法"><a href="#定义与语法" class="headerlink" title="定义与语法"></a>定义与语法</h3><p>变参模板使用 参数包（Parameter Pack），通过 <code>...</code> 语法来表示。</p>
<h4 id="语法：-4"><a href="#语法：-4" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionName</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归与展开（Recursion-and-Expansion）"><a href="#递归与展开（Recursion-and-Expansion）" class="headerlink" title="递归与展开（Recursion and Expansion）"></a>递归与展开（Recursion and Expansion）</h3><p>变参模板通常与递归相结合，通过递归地处理参数包，或者使用 折叠表达式（Fold Expressions） 来展开发参数包。</p>
<h4 id="递归示例：打印所有参数"><a href="#递归示例：打印所有参数" class="headerlink" title="递归示例：打印所有参数"></a>递归示例：打印所有参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T first, Args... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2.5 Hello A </span><br></pre></td></tr></table></figure>

<h4 id="折叠表达式版本"><a href="#折叠表达式版本" class="headerlink" title="折叠表达式版本"></a>折叠表达式版本</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;  <span class="comment">// C++17 折叠表达式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="折叠表达式示例：计算总和"><a href="#折叠表达式示例：计算总和" class="headerlink" title="折叠表达式示例：计算总和"></a>折叠表达式示例：计算总和</h3><p>C++17 引入了折叠表达式，简化了参数包的处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...);  <span class="comment">// 二元右折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>

<h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><h4 id="示例：日志记录器"><a href="#示例：日志记录器" class="headerlink" title="示例：日志记录器"></a>示例：日志记录器</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[LOG] &quot;</span>;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;User&quot;</span>, <span class="string">&quot; logged in at &quot;</span>, <span class="number">14</span>, <span class="string">&quot;:30&quot;</span>);</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;Error code: &quot;</span>, <span class="number">404</span>, <span class="string">&quot;, Message: &quot;</span>, <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[LOG] User logged in at 14:30</span><br><span class="line">[LOG] Error code: 404, Message: Not Found</span><br></pre></td></tr></table></figure>

<h3 id="要点：-3"><a href="#要点：-3" class="headerlink" title="要点："></a>要点：</h3><ul>
<li>变参模板极大地提升了模板的灵活性。</li>
<li>使用递归或折叠表达式处理参数包。</li>
<li>常用于实现通用函数、容器类和元编程工具。</li>
</ul>
<h2 id="模板折叠（Fold-Expressions）"><a href="#模板折叠（Fold-Expressions）" class="headerlink" title="模板折叠（Fold Expressions）"></a>模板折叠（Fold Expressions）</h2><h3 id="1-折叠表达式的概念与背景"><a href="#1-折叠表达式的概念与背景" class="headerlink" title="1. 折叠表达式的概念与背景"></a>1. 折叠表达式的概念与背景</h3><p>在C++中，可变参数模板允许函数或类模板接受任意数量的模板参数。这在编写灵活且通用的代码时非常有用。然而，处理参数包中的每个参数往往需要递归模板技巧，这样的代码通常复杂且难以维护。</p>
<p>折叠表达式的引入显著简化了这一过程。它们允许开发者直接对参数包应用操作符，而无需手动展开或递归处理参数。这不仅使代码更加简洁，还提高了可读性和可维护性。</p>
<p>折叠表达式可分为：</p>
<ul>
<li><strong>一元折叠表达式（Unary Fold）</strong>：对参数包中的每个参数应用一个一元操作符。</li>
<li><strong>二元折叠表达式（Binary Fold）</strong>：对参数包中的每个参数应用一个二元操作符。</li>
</ul>
<p>此外，二元折叠表达式可进一步细分为<strong>左折叠（Left Fold）</strong>和<strong>右折叠（Right Fold）</strong>，取决于操作符的结合方向。</p>
<h3 id="2-一元折叠表达式（Unary-Fold）"><a href="#2-一元折叠表达式（Unary-Fold）" class="headerlink" title="2. 一元折叠表达式（Unary Fold）"></a>2. 一元折叠表达式（Unary Fold）</h3><p>一元折叠表达式用于在参数包的每个参数前或后应用一元操作符。语法形式如下：</p>
<h4 id="前置一元折叠（Unary-Prefix-Fold）"><a href="#前置一元折叠（Unary-Prefix-Fold）" class="headerlink" title="前置一元折叠（Unary Prefix Fold）"></a>前置一元折叠（Unary Prefix Fold）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(op ... pack)</span><br></pre></td></tr></table></figure>

<h4 id="后置一元折叠（Unary-Postfix-Fold）"><a href="#后置一元折叠（Unary-Postfix-Fold）" class="headerlink" title="后置一元折叠（Unary Postfix Fold）"></a>后置一元折叠（Unary Postfix Fold）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pack ... op)</span><br></pre></td></tr></table></figure>

<p>其中，<code>op</code> 是一元操作符，如<code>!</code>（逻辑非）、<code>~</code>（按位取反）等。</p>
<h4 id="示例1：逻辑非操作"><a href="#示例1：逻辑非操作" class="headerlink" title="示例1：逻辑非操作"></a>示例1：逻辑非操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">allFalse</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (!args &amp;&amp; ...);  <span class="comment">// 一元左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">allFalse</span>(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>) &lt;&lt; std::endl;  <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">allFalse</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>) &lt;&lt; std::endl;   <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-二元折叠表达式（Binary-Fold）"><a href="#3-二元折叠表达式（Binary-Fold）" class="headerlink" title="3. 二元折叠表达式（Binary Fold）"></a>3. 二元折叠表达式（Binary Fold）</h3><p>二元折叠表达式用于在参数包的每个参数之间应用一个二元操作符。它们可以分为二元左折叠（Binary Left Fold）和二元右折叠（Binary Right Fold），取决于操作符的结合方向。</p>
<h4 id="二元折叠表达式语法"><a href="#二元折叠表达式语法" class="headerlink" title="二元折叠表达式语法"></a>二元折叠表达式语法</h4><p><strong>二元左折叠（Left Fold）</strong>：</p>
<ul>
<li><code>(init op ... op pack)</code></li>
<li>或者简化为：<code>(pack1 op ... op packN)</code></li>
</ul>
<p><strong>二元右折叠（Right Fold）</strong>：</p>
<ul>
<li><code>(pack1 op ... op init op ...)</code></li>
<li>或者简化为：<code>(pack1 op ... op packN)</code></li>
</ul>
<p>其中，<code>op</code> 是二元操作符，如<code>+</code>、<code>*</code>、<code>&amp;&amp;</code>、<code>||</code>、<code>&lt;&lt;</code> 等。</p>
<h4 id="左折叠与右折叠的区别"><a href="#左折叠与右折叠的区别" class="headerlink" title="左折叠与右折叠的区别"></a>左折叠与右折叠的区别</h4><ul>
<li><strong>二元左折叠（Binary Left Fold）</strong>：操作符从左至右结合，等价于 <code>(((a op b) op c) op d)</code>。</li>
<li><strong>二元右折叠（Binary Right Fold）</strong>：操作符从右至左结合，等价于 <code>(a op (b op (c op d)))</code>。</li>
</ul>
<h4 id="示例1：求和（Binary-Left-Fold）"><a href="#示例1：求和（Binary-Left-Fold）" class="headerlink" title="示例1：求和（Binary Left Fold）"></a>示例1：求和（Binary Left Fold）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...);  <span class="comment">// 二元左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;  <span class="comment">// 输出：10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>(args + ...)</code> 是一个二元左折叠表达式。</li>
<li>它将<code>+</code>操作符逐个应用于参数，按照左折叠顺序。</li>
<li>即，<code>((1 + 2) + 3) + 4 = 10</code>。</li>
</ul>
<h4 id="示例2：乘积（Binary-Right-Fold）"><a href="#示例2：乘积（Binary-Right-Fold）" class="headerlink" title="示例2：乘积（Binary Right Fold）"></a>示例2：乘积（Binary Right Fold）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">product</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (... * args);  <span class="comment">// 二元右折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">product</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;  <span class="comment">// 输出：24</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>(... * args)</code> 是一个二元右折叠表达式。</li>
<li>它将<code>*</code>操作符逐个应用于参数，按照右折叠顺序。</li>
<li>即，<code>2 * (3 * 4) = 2 * 12 = 24</code>。</li>
</ul>
<h4 id="示例3：逻辑与（Binary-Left-Fold）"><a href="#示例3：逻辑与（Binary-Left-Fold）" class="headerlink" title="示例3：逻辑与（Binary Left Fold）"></a>示例3：逻辑与（Binary Left Fold）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">allTrue</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args &amp;&amp; ...);  <span class="comment">// 二元左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">allTrue</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>) &lt;&lt; std::endl;   <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">allTrue</span>(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>) &lt;&lt; std::endl;  <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>(args &amp;&amp; ...)</code> 是一个二元左折叠表达式。</li>
<li>用于检查所有参数是否为true。</li>
<li>类似于链式的逻辑与运算。</li>
</ul>
<h3 id="4-左折叠与右折叠（Left-and-Right-Folds）"><a href="#4-左折叠与右折叠（Left-and-Right-Folds）" class="headerlink" title="4. 左折叠与右折叠（Left and Right Folds）"></a>4. 左折叠与右折叠（Left and Right Folds）</h3><p>了解左折叠和右折叠的区别，对于正确选择折叠表达式的形式至关重要。</p>
<h4 id="二元左折叠（Binary-Left-Fold）"><a href="#二元左折叠（Binary-Left-Fold）" class="headerlink" title="二元左折叠（Binary Left Fold）"></a>二元左折叠（Binary Left Fold）</h4><p><strong>语法：</strong></p>
<ul>
<li><code>(args op ...)</code></li>
</ul>
<p><strong>展开方式：</strong></p>
<ul>
<li><code>((arg1 op arg2) op arg3) op ... op argN</code></li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>当操作符是结合性的且从左侧开始累积操作时（如<code>+</code>、<code>*</code>）。</li>
<li>需要严格的顺序执行时，确保从左到右依次处理参数。</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>(args + ...)</code> &#x2F;&#x2F; 左折叠求和</li>
</ul>
<h4 id="二元右折叠（Binary-Right-Fold）"><a href="#二元右折叠（Binary-Right-Fold）" class="headerlink" title="二元右折叠（Binary Right Fold）"></a>二元右折叠（Binary Right Fold）</h4><p><strong>语法：</strong></p>
<ul>
<li><code>(... op args)</code></li>
</ul>
<p><strong>展开方式：</strong></p>
<ul>
<li><code>arg1 op (arg2 op (arg3 op ... op argN))</code></li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>当操作符是右结合的，或当需要从右侧开始累积操作时。</li>
<li>某些特定的逻辑和数据结构可能需要右侧先处理。</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>(... + args)</code> &#x2F;&#x2F; 右折叠求和</li>
</ul>
<h3 id="5-op-在折叠表达式中的作用"><a href="#5-op-在折叠表达式中的作用" class="headerlink" title="5. op 在折叠表达式中的作用"></a>5. op 在折叠表达式中的作用</h3><p>在折叠表达式中，<code>op</code> 代表二元操作符，用于定义如何将参数包中的各个参数相互结合。<code>op</code> 可以是任何合法的二元操作符，包括但不限于：</p>
<ul>
<li><strong>算术操作符</strong>：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code> 等。</li>
<li><strong>逻辑操作符</strong>：<code>&amp;&amp;</code>、<code>||</code> 等。</li>
<li><strong>按位操作符</strong>：<code>&amp;</code>、<code>|</code>、<code>^</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code> 等。</li>
<li><strong>比较操作符</strong>：<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code> 等。</li>
<li><strong>自定义操作符</strong>：如果定义了自定义类型并重载了特定的操作符，也可以使用这些操作符。</li>
</ul>
<p><code>op</code> 的选择直接影响折叠表达式的行为和结果。选择适当的操作符是实现特定功能的关键。</p>
<h4 id="示例1：使用加法操作符"><a href="#示例1：使用加法操作符" class="headerlink" title="示例1：使用加法操作符"></a>示例1：使用加法操作符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例2：使用逻辑与操作符"><a href="#示例2：使用逻辑与操作符" class="headerlink" title="示例2：使用逻辑与操作符"></a>示例2：使用逻辑与操作符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">all</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args &amp;&amp; ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例3：使用左移操作符（流插入）"><a href="#示例3：使用左移操作符（流插入）" class="headerlink" title="示例3：使用左移操作符（流插入）"></a>示例3：使用左移操作符（流插入）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>在上述示例中，<code>op</code> 分别为 <code>+</code>、<code>&amp;&amp;</code>、<code>&lt;&lt;</code>。</li>
<li>每个操作符定义了如何将参数包中的元素相互结合。</li>
</ul>
<h4 id="示例4：使用自定义操作符"><a href="#示例4：使用自定义操作符" class="headerlink" title="示例4：使用自定义操作符"></a>示例4：使用自定义操作符</h4><p>假设有一个自定义类型<code>Point</code>，并重载了<code>+</code>操作符以支持点的相加。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x + other.x, y + other.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Point&amp; p) &#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sumPoints</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">p2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span>, <span class="title">p3</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    Point result = <span class="built_in">sumPoints</span>(p1, p2, p3);</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;  <span class="comment">// 输出：(9, 12)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>通过重载<code>+</code>操作符，<code>sumPoints</code>函数能够将多个<code>Point</code>对象相加，得到累积的结果。</li>
</ul>
<h3 id="6-示例代码与应用"><a href="#6-示例代码与应用" class="headerlink" title="6. 示例代码与应用"></a>6. 示例代码与应用</h3><p>为了全面理解折叠表达式的应用，以下提供多个具体示例，涵盖不同类型的折叠表达式。</p>
<h4 id="示例1：字符串拼接"><a href="#示例1：字符串拼接" class="headerlink" title="示例1：字符串拼接"></a>示例1：字符串拼接</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">std::string <span class="title">concatenate</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (std::string&#123;&#125; + ... + args);  <span class="comment">// 二元左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string result = <span class="built_in">concatenate</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;  <span class="comment">// 输出：Hello World!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例2：计算逻辑与"><a href="#示例2：计算逻辑与" class="headerlink" title="示例2：计算逻辑与"></a>示例2：计算逻辑与</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">all</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args &amp;&amp; ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">all</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>) &lt;&lt; std::endl;    <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">all</span>(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>) &lt;&lt; std::endl;   <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例3：计算最大值"><a href="#示例3：计算最大值" class="headerlink" title="示例3：计算最大值"></a>示例3：计算最大值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T <span class="title">maxValue</span><span class="params">(T first, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(args) == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T restMax = <span class="built_in">maxValue</span>(args...);</span><br><span class="line">        <span class="keyword">return</span> (first &gt; restMax) ? first : restMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">maxValue</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>) &lt;&lt; std::endl;  <span class="comment">// 输出：9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 上述示例中的<code>(std::max)(first, ... , args)</code>是一个非标准用法，需要根据具体情况调整。通常，<code>std::max</code>不支持直接的折叠表达式，因此此例更适合作为概念性说明。在实际应用中，可以使用<code>std::initializer_list</code>或其他方法实现多参数的最大值计算。</p>
<h4 id="示例4：筛选逻辑"><a href="#示例4：筛选逻辑" class="headerlink" title="示例4：筛选逻辑"></a>示例4：筛选逻辑</h4><p>假设需要检查多个条件是否满足，且每个条件之间使用逻辑或操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Conditions&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">anyCondition</span><span class="params">(Conditions... conds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (conds || ...);  <span class="comment">// 二元左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> a = <span class="literal">false</span>, b = <span class="literal">true</span>, c = <span class="literal">false</span>;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">anyCondition</span>(a, b, c) &lt;&lt; std::endl;  <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-注意事项与最佳实践"><a href="#7-注意事项与最佳实践" class="headerlink" title="7. 注意事项与最佳实践"></a>7. 注意事项与最佳实践</h3><ol>
<li><p><strong>操作符的选择</strong><br>选择合适的操作符（<code>op</code>）对于实现正确的折叠行为至关重要。确保所选的操作符符合所需的逻辑和计算需求。</p>
</li>
<li><p><strong>操作符的结合性</strong><br>不同的操作符具有不同的结合性（左结合、右结合）。了解操作符的结合性有助于选择正确的折叠方向（左折叠或右折叠）。</p>
</li>
<li><p><strong>参数包的初始化</strong><br>在二元折叠表达式中，有时需要一个初始值（<code>init</code>）。这主要用于确保折叠的正确性，尤其在参数包可能为空的情况下。</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sumWithInit</span><span class="params">(<span class="type">int</span> init, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (init + ... + args);  <span class="comment">// 带初始值的左折叠</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>参数包为空的情况</strong><br>如果参数包为空，折叠表达式的结果取决于折叠的类型和初始值。合理设置初始值可以避免潜在的错误。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">safeSum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> + ... + args);  <span class="comment">// 空包时返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p><strong>与递归模板的比较</strong><br>折叠表达式在处理可变参数模板时，比传统的递归模板方法更简洁、易读且易于维护。然而，理解折叠表达式的基本原理和语法对于充分利用其优势至关重要。</p>
</li>
<li><p><strong>编译器支持</strong><br>确保所使用的编译器支持C++17或更高标准，因为折叠表达式是在C++17中引入的。常见的支持C++17的编译器包括：</p>
<ul>
<li><strong>GCC</strong>：从版本7开始支持C++17，其中完整支持在后续版本中得到增强。</li>
<li><strong>Clang</strong>：从版本5开始支持C++17。</li>
<li><strong>MSVC（Visual Studio）</strong>：从Visual Studio 2017版本15.7开始提供较全面的C++17支持。</li>
</ul>
</li>
<li><p><strong>性能考虑</strong><br>折叠表达式本身并不引入额外的性能开销。它们是在编译时展开的，生成的代码与手动展开参数包时的代码几乎相同。然而，编写高效的折叠表达式仍然需要理解所应用操作符的性能特性。</p>
</li>
</ol>
<h2 id="SFINAE（Substitution-Failure-Is-Not-An-Error）"><a href="#SFINAE（Substitution-Failure-Is-Not-An-Error）" class="headerlink" title="SFINAE（Substitution Failure Is Not An Error）"></a>SFINAE（Substitution Failure Is Not An Error）</h2><h3 id="一、什么是SFINAE？"><a href="#一、什么是SFINAE？" class="headerlink" title="一、什么是SFINAE？"></a>一、什么是SFINAE？</h3><p>SFINAE 是 “Substitution Failure Is Not An Error”（替换失败不是错误）的缩写，是C++模板编程中的一个重要概念。它允许编译器在模板实例化过程中，如果在替换模板参数时失败（即不满足某些条件），不会将其视为编译错误，而是继续寻找其他可能的模板或重载。这一机制为条件编译、类型特性检测、函数重载等提供了强大的支持。</p>
<h3 id="二、SFINAE的工作原理"><a href="#二、SFINAE的工作原理" class="headerlink" title="二、SFINAE的工作原理"></a>二、SFINAE的工作原理</h3><p>在模板实例化过程中，编译器会尝试将模板参数替换为具体类型。如果在替换过程中出现不合法的表达式或类型，编译器不会报错，而是将该模板视为不可行的，继续尝试其他模板或重载。这一特性允许开发者根据类型特性选择不同的模板实现。</p>
<h3 id="三、SFINAE的应用场景"><a href="#三、SFINAE的应用场景" class="headerlink" title="三、SFINAE的应用场景"></a>三、SFINAE的应用场景</h3><ol>
<li><strong>函数重载选择</strong>：根据参数类型的不同选择不同的函数实现。</li>
<li><strong>类型特性检测</strong>：检测类型是否具有某些成员或特性，从而决定是否启用某些功能。</li>
<li><strong>条件编译</strong>：根据模板参数的特性决定是否编译某些代码段。</li>
</ol>
<h3 id="四、SFINAE的基本用法"><a href="#四、SFINAE的基本用法" class="headerlink" title="四、SFINAE的基本用法"></a>四、SFINAE的基本用法</h3><p>SFINAE通常与<code>std::enable_if</code>、模板特化、以及类型萃取等技术结合使用。以下通过几个例子来说明SFINAE的应用。</p>
<h4 id="示例一：通过std-enable-if实现函数重载"><a href="#示例一：通过std-enable-if实现函数重载" class="headerlink" title="示例一：通过std::enable_if实现函数重载"></a>示例一：通过<code>std::enable_if</code>实现函数重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing integral: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, T&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing floating point: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(<span class="number">42</span>);      <span class="comment">// 调用整数版本</span></span><br><span class="line">    <span class="built_in">process</span>(<span class="number">3.14</span>);    <span class="comment">// 调用浮点数版本</span></span><br><span class="line">    <span class="comment">// process(&quot;hello&quot;); // 编译错误：没有匹配的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::enable_if</code> 根据条件 <code>std::is_integral&lt;T&gt;::value</code> 或 <code>std::is_floating_point&lt;T&gt;::value</code> 决定是否启用对应的函数模板。</li>
<li>当条件不满足时，该模板实例化失败，但由于SFINAE规则，编译器不会报错，而是忽略该模板，从而实现函数重载选择。</li>
</ul>
<h4 id="示例二：检测类型是否具有特定成员"><a href="#示例二：检测类型是否具有特定成员" class="headerlink" title="示例二：检测类型是否具有特定成员"></a>示例二：检测类型是否具有特定成员</h4><p>假设我们需要实现一个函数，仅当类型 T 具有成员函数 <code>foo</code> 时才启用该函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测类型T是否有foo成员函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">has_foo</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">test</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">decltype</span><span class="params">(std::declval&lt;U&gt;().foo(), std::true_type&#123;&#125;)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::false_type <span class="title">test</span><span class="params">(...)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="keyword">decltype</span>(<span class="built_in">test</span>&lt;T&gt;(<span class="number">0</span>))::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅当T有foo成员时才启用的函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;has_foo&lt;T&gt;::value&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">call_foo</span><span class="params">(T&amp; obj)</span> </span>&#123;</span><br><span class="line">    obj.<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithFoo</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;WithFoo::foo() called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithoutFoo</span> &#123;</span><br><span class="line">    <span class="comment">// 没有foo成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WithFoo wf;</span><br><span class="line">    WithoutFoo wof;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">call_foo</span>(wf);   <span class="comment">// 正常调用</span></span><br><span class="line">    <span class="comment">// call_foo(wof); // 编译错误：没有匹配的函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>has_foo</code> 是一个类型萃取类，用于检测类型 T 是否具有成员函数 <code>foo</code>。</li>
<li><code>call_foo</code> 函数模板仅在 T 具有 <code>foo</code> 成员时启用。</li>
<li>对于不具有 <code>foo</code> 成员的类型，编译器会忽略 <code>call_foo</code>，从而避免编译错误。</li>
</ul>
<h4 id="示例三：通过模板特化实现不同的行为"><a href="#示例三：通过模板特化实现不同的行为" class="headerlink" title="示例三：通过模板特化实现不同的行为"></a>示例三：通过模板特化实现不同的行为</h4><p>以下是完整的、正确实现 <code>TypePrinter</code> 的代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测类型T是否有非void的value_type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> has_non_void_value_type : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_non_void_value_type</span>&lt;T, </span><br><span class="line">    std::<span class="type">void_t</span>&lt;<span class="keyword">typename</span> T::value_type&gt;&gt; : </span><br><span class="line">    std::negation&lt;std::is_void&lt;<span class="keyword">typename</span> T::value_type&gt;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">bool</span> HasValueType = has_non_void_value_type&lt;T&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> TypePrinter &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="built_in">print</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Type without value_type or value_type is void&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化版本：当T有非void的value_type时</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypePrinter</span>&lt;T, <span class="literal">true</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Type with value_type: &quot;</span> </span><br><span class="line">                  &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">typename</span> T::value_type).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithValueType</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithoutValueType</span> &#123;</span><br><span class="line">    <span class="comment">// 没有value_type</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithVoidValueType</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="type">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TypePrinter&lt;WithValueType&gt;::<span class="built_in">print</span>();      <span class="comment">// 有value_type</span></span><br><span class="line">    TypePrinter&lt;WithoutValueType&gt;::<span class="built_in">print</span>();   <span class="comment">// 没有value_type</span></span><br><span class="line">    TypePrinter&lt;WithVoidValueType&gt;::<span class="built_in">print</span>();  <span class="comment">// value_type是void</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解释</strong></p>
<ol>
<li><p><strong>Trait <code>has_non_void_value_type</code></strong>:</p>
<ul>
<li>主模板：默认情况下，<code>has_non_void_value_type&lt;T&gt;</code> 继承自 <code>std::false_type</code>，表示 T 没有 <code>value_type</code> 或 <code>value_type</code> 是 <code>void</code>。</li>
<li>特化模板：仅当 T 有 <code>value_type</code> 且 <code>value_type</code> 不是 <code>void</code> 时，<code>has_non_void_value_type&lt;T&gt;</code> 继承自 <code>std::true_type</code>。</li>
</ul>
</li>
<li><p><strong><code>TypePrinter</code> 模板</strong>:</p>
<ul>
<li>主模板：接受一个类型 T 和一个布尔模板参数 <code>HasValueType</code>，默认为 <code>has_non_void_value_type&lt;T&gt;::value</code>。</li>
<li>特化版本 <code>TypePrinter&lt;T, true&gt;</code>：当 <code>HasValueType</code> 为 true 时，表示 T 有非 void 的 <code>value_type</code>，提供相应的 <code>print</code> 实现。</li>
<li>特化版本 <code>TypePrinter&lt;T, false&gt;</code>：当 <code>HasValueType</code> 为 false 时，表示 T 没有 <code>value_type</code> 或 <code>value_type</code> 是 <code>void</code>，提供默认的 <code>print</code> 实现。</li>
</ul>
</li>
<li><p><strong>测试结构体</strong>：</p>
<ul>
<li><code>WithValueType</code>：有一个非 void 的 <code>value_type</code>。</li>
<li><code>WithoutValueType</code>：没有 <code>value_type</code>。</li>
<li><code>WithVoidValueType</code>：有一个 <code>value_type</code>，但它是 <code>void</code>。</li>
</ul>
</li>
<li><p><strong>main 函数</strong>：</p>
<ul>
<li>分别测试了三种情况，验证 <code>TypePrinter</code> 的行为是否符合预期。</li>
</ul>
</li>
</ol>
<h3 id="五、SFINAE的优缺点"><a href="#五、SFINAE的优缺点" class="headerlink" title="五、SFINAE的优缺点"></a>五、SFINAE的优缺点</h3><p><strong>优点：</strong></p>
<ol>
<li><strong>灵活性高</strong>：能够根据类型特性选择不同的实现，提升代码的泛化能力。</li>
<li><strong>类型安全</strong>：通过编译期检测，避免了运行时错误。</li>
<li><strong>无需额外的运行时开销</strong>：所有的类型筛选都在编译期完成。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>复杂性高</strong>：SFINAE相关的代码往往较为复杂，阅读和维护难度较大。</li>
<li><strong>编译器错误信息难以理解</strong>：SFINAE失败时，编译器可能给出晦涩的错误信息，调试困难。</li>
<li><strong>模板实例化深度限制</strong>：过度使用SFINAE可能导致编译时间增加和模板实例化深度限制问题。</li>
</ol>
<h3 id="六、现代C-中的替代方案"><a href="#六、现代C-中的替代方案" class="headerlink" title="六、现代C++中的替代方案"></a>六、现代C++中的替代方案</h3><p>随着C++11及后续标准的发展，引入了诸如<code>decltype</code>、<code>constexpr</code>、<code>if constexpr</code>、概念（C++20）等新的特性，部分情况下可以替代传统的SFINAE，提高代码的可读性和可维护性。例如，C++20引入的概念（Concepts）提供了更为简洁和直观的方式来约束模板参数，减少了SFINAE的复杂性。</p>
<h4 id="示例：使用概念替代SFINAE"><a href="#示例：使用概念替代SFINAE" class="headerlink" title="示例：使用概念替代SFINAE"></a>示例：使用概念替代SFINAE</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Integral = std::is_integral_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;Integral T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing integral: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> std::floating_point&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing floating point: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(<span class="number">42</span>);      <span class="comment">// 调用整数版本</span></span><br><span class="line">    <span class="built_in">process</span>(<span class="number">3.14</span>);    <span class="comment">// 调用浮点数版本</span></span><br><span class="line">    <span class="comment">// process(&quot;hello&quot;); // 编译错误：没有匹配的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>使用概念<code>Integral</code>代替<code>std::enable_if</code>，语法更简洁，代码更易读。</li>
<li>当类型不满足概念时，编译器会给出明确的错误信息，便于调试。</li>
</ul>
<p>虽然上述方法经典且有效，但在C++11及以后版本，存在更简洁和易读的方式来实现相同的功能。例如，使用<code>std::void_t</code>和更现代的检测技巧，或者直接使用C++20的概念（Concepts），使代码更加清晰。</p>
<h4 id="示例：使用std-void-t简化has-foo"><a href="#示例：使用std-void-t简化has-foo" class="headerlink" title="示例：使用std::void_t简化has_foo"></a>示例：使用<code>std::void_t</code>简化<code>has_foo</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> has_foo : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_foo</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">foo</span>())&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;has_foo&lt;T&gt;::value&gt; <span class="built_in">call_foo</span>(T&amp; obj) &#123;</span><br><span class="line">    obj.<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithFoo</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;WithFoo::foo() called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WithFoo wf;</span><br><span class="line">    <span class="built_in">call_foo</span>(wf);  <span class="comment">// 正常调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>利用<code>std::void_t</code>，<code>has_foo</code>结构更为简洁。</li>
<li><code>decltype(std::declval&lt;T&gt;().foo())</code>尝试在不实例化T对象的情况下检测<code>foo()</code>成员函数。</li>
<li>如果<code>foo()</code>存在，<code>has_foo&lt;T&gt;</code>继承自<code>std::true_type</code>，否则继承自<code>std::false_type</code>。</li>
</ul>
<h4 id="使用C-20概念"><a href="#使用C-20概念" class="headerlink" title="使用C++20概念"></a>使用C++20概念</h4><p>如果你使用的是支持C++20的编译器，可以利用概念（Concepts）进一步简化和增强可读性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> HasFoo = <span class="built_in">requires</span>(T t) &#123;</span><br><span class="line">    t.<span class="built_in">foo</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;HasFoo T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_foo</span><span class="params">(T&amp; obj)</span> </span>&#123;</span><br><span class="line">    obj.<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithFoo</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;WithFoo::foo() called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WithFoo wf;</span><br><span class="line">    <span class="built_in">call_foo</span>(wf);  <span class="comment">// 正常调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>HasFoo</code>概念：使用<code>requires</code>表达式检测类型T是否具有<code>void foo()</code>成员函数。</li>
<li><code>call_foo</code>函数模板：仅当T满足<code>HasFoo</code>概念时，模板被启用。</li>
<li>这种方式更直观，易于理解和维护。</li>
</ul>
<h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>SFINAE作为C++模板编程中的一项强大功能，通过在模板实例化过程中允许替换失败而不报错，实现了基于类型特性的编程。然而，SFINAE的语法复杂且难以维护，现代C++引入的新特性如概念等在某些情况下已经能够更简洁地实现类似的功能。尽管如此，理解SFINAE的工作机制依然对于掌握高级模板技术和阅读老旧代码具有重要意义。</p>
<h2 id="综合案例：结合模板特化与折叠表达式"><a href="#综合案例：结合模板特化与折叠表达式" class="headerlink" title="综合案例：结合模板特化与折叠表达式"></a>综合案例：结合模板特化与折叠表达式</h2><p>为了进一步巩固对模板特化和折叠表达式的理解，本节将通过一个综合案例展示如何将两者结合使用。</p>
<h3 id="案例描述"><a href="#案例描述" class="headerlink" title="案例描述"></a>案例描述</h3><p>实现一个通用的日志记录器<code>Logger</code>，能够处理任意数量和类型的参数，并根据不同的类型组合调整输出格式。具体需求包括：</p>
<ol>
<li>对于普通类型，使用通用的打印格式。</li>
<li>对于指针类型，打印指针地址或指向的值。</li>
<li>对于<code>std::string</code>类型，使用专门的格式。</li>
<li>支持可变数量的参数，通过折叠表达式实现参数的逐一打印。</li>
</ol>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li>定义通用类模板<code>Logger</code>，使用模板特化和偏特化处理不同类型。</li>
<li>实现<code>log</code>函数，使用模板折叠表达式逐一打印参数。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Enable = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Logger &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="built_in">log</span>(<span class="type">const</span> T&amp; value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;General Logger: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型的偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>&lt;T*, <span class="type">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(T* value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Pointer Logger: &quot;</span> &lt;&lt; *value &lt;&lt; <span class="string">&quot; (address: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Pointer Logger: nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::string类型的全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>&lt;std::string, <span class="type">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String Logger: \&quot;&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：记录单个值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logOne</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    Logger&lt;T&gt;::<span class="built_in">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用折叠表达式记录所有参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAll</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    (<span class="built_in">logOne</span>(args), ...);  <span class="comment">// C++17 折叠表达式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">3.14</span>;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line">    <span class="type">int</span>* nullPtr = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">logAll</span>(x, y, str, ptr, nullPtr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">General Logger: 42</span><br><span class="line">General Logger: 3.14</span><br><span class="line">String Logger: &quot;Hello World&quot;</span><br><span class="line">Pointer Logger: 42 (address: 0x7ffd...)</span><br><span class="line">Pointer Logger: nullptr</span><br></pre></td></tr></table></figure>

<h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><ol>
<li><p>**通用模板<code>Logger&lt;T, Enable&gt;</code>**：</p>
<ul>
<li>使用第二个模板参数<code>Enable</code>与SFINAE（Substitution Failure Is Not An Error）结合，控制模板特化。</li>
<li>对于非指针类型和非<code>std::string</code>类型，使用通用实现，打印”General Logger: value”。</li>
</ul>
</li>
<li><p>**类模板偏特化<code>Logger&lt;T, Enable&gt;</code>**：</p>
<ul>
<li>使用<code>std::enable_if</code>和<code>std::is_pointer</code>，当T是指针类型时，特化模板。</li>
<li>实现指针类型的特殊日志处理，打印指针指向的值或<code>nullptr</code>。</li>
</ul>
</li>
<li><p>**类模板全特化<code>Logger&lt;std::string&gt;</code>**：</p>
<ul>
<li>为<code>std::string</code>类型提供全特化版本，使用不同的输出格式。</li>
</ul>
</li>
<li><p><strong><code>logOne</code>函数模板</strong>：</p>
<ul>
<li>简化调用过程，调用相应的<code>Logger&lt;T&gt;::log</code>方法。</li>
</ul>
</li>
<li><p><strong><code>logAll</code>函数模板</strong>：</p>
<ul>
<li>使用模板折叠表达式<code>(logOne(args), ...)</code>，实现对所有参数的逐一日志记录。</li>
<li>通过左折叠的逗号表达式，确保每个<code>logOne</code>调用依次执行。</li>
</ul>
</li>
<li><p><strong>main函数</strong>：</p>
<ul>
<li>测试不同类型的日志记录，包括普通类型、指针类型和<code>std::string</code>类型。</li>
<li>调用<code>logAll</code>函数，实现多参数的综合日志记录。</li>
</ul>
</li>
</ol>
<h2 id="模板元编程（Template-Metaprogramming）"><a href="#模板元编程（Template-Metaprogramming）" class="headerlink" title="模板元编程（Template Metaprogramming）"></a>模板元编程（Template Metaprogramming）</h2><h3 id="什么是模板元编程"><a href="#什么是模板元编程" class="headerlink" title="什么是模板元编程"></a>什么是模板元编程</h3><p>模板元编程（Template Metaprogramming）是一种在编译期通过模板机制进行代码生成和计算的编程技术。它利用编译器的模板实例化机制，在编译期间执行代码逻辑，以提高程序的性能和灵活性。</p>
<h3 id="模板元编程的优势"><a href="#模板元编程的优势" class="headerlink" title="模板元编程的优势"></a>模板元编程的优势</h3><ul>
<li>提高代码的可重用性和泛化能力。</li>
<li>在编译期进行复杂计算，减少运行时开销。</li>
<li>实现类型安全的高级抽象。</li>
</ul>
<h3 id="模板元编程基础"><a href="#模板元编程基础" class="headerlink" title="模板元编程基础"></a>模板元编程基础</h3><ul>
<li><strong>模板特化（Template Specialization）</strong>：<ul>
<li>全特化（Full Specialization）：为特定类型提供特定实现。</li>
<li>偏特化（Partial Specialization）：为部分模板参数特定的情况提供实现。</li>
</ul>
</li>
<li><strong>递归模板（Recursive Templates）</strong>：利用模板的递归实例化机制，实现编译期计算。</li>
</ul>
<h3 id="编译期计算"><a href="#编译期计算" class="headerlink" title="编译期计算"></a>编译期计算</h3><p>模板元编程允许在编译时执行计算，如计算阶乘、斐波那契数列等。</p>
<h4 id="示例：编译期阶乘"><a href="#示例：编译期阶乘" class="headerlink" title="示例：编译期阶乘"></a>示例：编译期阶乘</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化模板：递归终止条件</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Factorial of 5: &quot;</span> &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Factorial of 5: 120</span><br></pre></td></tr></table></figure>

<p><strong>讲解：</strong></p>
<ol>
<li>基本模板<code>Factorial</code>定义了一个静态常量<code>value</code>，其值为<code>N * Factorial&lt;N - 1&gt;::value</code>，实现递归计算。</li>
<li>特化模板<code>Factorial&lt;0&gt;</code>定义递归终止条件，当N&#x3D;0时，<code>value</code>为1。</li>
<li>在main函数中，通过<code>Factorial&lt;5&gt;::value</code>获取5的阶乘结果，编译期即生成其值。</li>
</ol>
<h3 id="静态成员变量的基本规则"><a href="#静态成员变量的基本规则" class="headerlink" title="静态成员变量的基本规则"></a>静态成员变量的基本规则</h3><p>在 C++ 中，静态成员变量的声明与定义有以下基本规则：</p>
<ol>
<li><strong>声明（Declaration）</strong>：在类内部声明静态成员变量，告诉编译器该类包含这个静态成员。</li>
<li><strong>定义（Definition）</strong>：在类外部对静态成员变量进行定义，分配存储空间。</li>
</ol>
<p>通常，对于非 <code>constexpr</code> 或非 <code>inline</code> 的静态成员变量，必须 在类外进行定义，否则会导致链接器错误（undefined reference）。</p>
<h3 id="特殊情况：static-const-整数成员"><a href="#特殊情况：static-const-整数成员" class="headerlink" title="特殊情况：static const 整数成员"></a>特殊情况：static const 整数成员</h3><p>对于 <code>static const</code>整数类型 的静态成员变量，C++ 标准做了一些特殊的处理：</p>
<ul>
<li><strong>类内初始化</strong>：你可以在类内部初始化 <code>static const</code> 整数成员变量，例如 <code>static const int value = 42;</code>。</li>
<li><strong>使用场景</strong>：<ul>
<li>不需要类外定义：在某些情况下，编译器在编译阶段可以直接使用类内的初始化值，无需类外定义。</li>
<li>需要类外定义：如果你在程序中对该静态成员变量进行取址（例如，<code>&amp;Factorial&lt;5&gt;::value</code>），或者在其他需要该变量的存储位置时，就需要在类外进行定义。</li>
</ul>
</li>
</ul>
<h4 id="C-11-及之前的标准"><a href="#C-11-及之前的标准" class="headerlink" title="C++11 及之前的标准"></a>C++11 及之前的标准</h4><p>在 C++11 及更早的标准中，对于 <code>static const</code> 整数成员变量：</p>
<ul>
<li><strong>不需要类外定义的情况</strong>：<ul>
<li>仅在作为编译期常量使用时，不需要类外定义。例如，用于数组大小、模板参数等。</li>
</ul>
</li>
<li><strong>需要类外定义的情况</strong>：<ul>
<li>当你需要对变量进行取址，或者在需要其存储位置时，必须在类外定义。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类内声明</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义（如果需要进行取址操作）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ClassName::value;</span><br></pre></td></tr></table></figure>

<h4 id="C-17-及更新标准"><a href="#C-17-及更新标准" class="headerlink" title="C++17 及更新标准"></a>C++17 及更新标准</h4><p>从 C++17 开始，引入了 <strong>内联变量（inline variables）</strong>，使得在类内定义静态成员变量变得更加灵活：</p>
<ul>
<li><strong>内联静态成员变量</strong>：<ul>
<li>使用 <code>inline</code> 关键字，可以在类内对静态成员变量进行定义，无需在类外进行单独定义。</li>
<li>这适用于 C++17 及更高版本。</li>
</ul>
</li>
</ul>
<p>例如，你可以这样编写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，无需在类外进行定义，因为 <code>inline</code> 确保了该变量在每个翻译单元中都只有一个实例。</p>
<h3 id="在-C-11-及之前的标准"><a href="#在-C-11-及之前的标准" class="headerlink" title="在 C++11 及之前的标准"></a>在 C++11 及之前的标准</h3><p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要取址，需要在类外定义</span></span><br><span class="line"><span class="comment">// const int Factorial&lt;5&gt;::value;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作为编译期常量使用</strong>：<ul>
<li>例如，用于其他模板参数或编译期常量计算时，不需要类外定义。</li>
</ul>
</li>
<li><strong>取址或需要存储位置时</strong>：<ul>
<li>需要在类外进行定义。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl;  <span class="comment">// 不需要定义</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ptr = &amp;Factorial&lt;<span class="number">5</span>&gt;::value;          <span class="comment">// 需要定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在-C-17-及更高标准"><a href="#在-C-17-及更高标准" class="headerlink" title="在 C++17 及更高标准"></a>在 C++17 及更高标准</h3><p>如果你使用 C++17 及更高版本，可以使用 <code>inline</code> 关键字：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>无需类外定义</strong>：<ul>
<li><code>inline</code> 使得在类内的定义成为唯一的定义，即使在多个翻译单元中使用，也不会导致重复定义错误。</li>
</ul>
</li>
</ul>
<h3 id="实际示例与测试"><a href="#实际示例与测试" class="headerlink" title="实际示例与测试"></a>实际示例与测试</h3><h4 id="示例-1：仅作为编译期常量使用"><a href="#示例-1：仅作为编译期常量使用" class="headerlink" title="示例 1：仅作为编译期常量使用"></a>示例 1：仅作为编译期常量使用</h4><ul>
<li>C++11 及之前：无需类外定义。</li>
<li>C++17 及更新：同样无需类外定义，且可以使用 <code>inline</code> 进一步优化。</li>
</ul>
<h4 id="示例-2：取址"><a href="#示例-2：取址" class="headerlink" title="示例 2：取址"></a>示例 2：取址</h4><ul>
<li>C++11 及之前：必须提供类外定义，否则会在链接时出现错误。</li>
<li>C++17 及更新：若未使用 <code>inline</code>，仍需提供类外定义；使用 <code>inline</code> 则无需。</li>
</ul>
<h4 id="示例-3：使用-inline（C-17-及更高）"><a href="#示例-3：使用-inline（C-17-及更高）" class="headerlink" title="示例 3：使用 inline（C++17 及更高）"></a>示例 3：使用 inline（C++17 及更高）</h4><ul>
<li>C++17 及以上：<ul>
<li>无需类外定义。</li>
<li><code>inline</code> 保证了多重定义的合法性。</li>
</ul>
</li>
</ul>
<h3 id="详细解析"><a href="#详细解析" class="headerlink" title="详细解析"></a>详细解析</h3><h4 id="为什么有这样的特殊处理？"><a href="#为什么有这样的特殊处理？" class="headerlink" title="为什么有这样的特殊处理？"></a>为什么有这样的特殊处理？</h4><ul>
<li><strong>优化与性能</strong>：<ul>
<li>在编译期常量的情况下，不需要在运行时分配存储空间，编译器可以优化掉相关代码。</li>
</ul>
</li>
<li><strong>兼容性</strong>：<ul>
<li>早期 C++ 标准遵循这种规则，允许在类内初始化静态常量成员变量，便于模板元编程和常量表达式的使用。</li>
</ul>
</li>
<li><strong>inline 变量</strong>：<ul>
<li>C++17 引入 <code>inline</code> 关键字用于变量，解决了静态成员变量在多个翻译单元中的定义问题，使得代码更简洁。</li>
</ul>
</li>
</ul>
<h4 id="是否总是需要定义？"><a href="#是否总是需要定义？" class="headerlink" title="是否总是需要定义？"></a>是否总是需要定义？</h4><p>并非总是需要。关键在于 <strong>如何使用</strong> 这个静态成员变量：</p>
<ul>
<li><strong>仅作为编译期常量使用</strong>：无需类外定义。</li>
<li><strong>需要存储位置或取址</strong>：需要类外定义，除非使用 <code>inline</code>（C++17 及以上）。</li>
</ul>
<h4 id="编译器与链接器的行为"><a href="#编译器与链接器的行为" class="headerlink" title="编译器与链接器的行为"></a>编译器与链接器的行为</h4><ul>
<li><strong>编译阶段</strong>：<ul>
<li>类内的初始化用于编译期常量计算，不涉及存储分配。</li>
</ul>
</li>
<li><strong>链接阶段</strong>：<ul>
<li>如果没有类外定义，且静态成员被 odr-used（可能需要存储位置），链接器会报错，提示找不到符号定义。</li>
<li>使用 <code>inline</code> 关键字后，编译器处理为内联变量，避免了多重定义问题。</li>
</ul>
</li>
</ul>
<h4 id="示例：编译期斐波那契数列"><a href="#示例：编译期斐波那契数列" class="headerlink" title="示例：编译期斐波那契数列"></a>示例：编译期斐波那契数列</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = Fibonacci&lt;N - <span class="number">1</span>&gt;::value + Fibonacci&lt;N - <span class="number">2</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">1</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fibonacci(10): &quot;</span> &lt;&lt; Fibonacci&lt;<span class="number">10</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fibonacci(10): 55</span><br></pre></td></tr></table></figure>

<h3 id="要点：-4"><a href="#要点：-4" class="headerlink" title="要点："></a>要点：</h3><ul>
<li>模板元编程利用编译期计算提升程序性能。</li>
<li>需要理解模板递归与终止条件。</li>
<li>常与类型特性和模板特化结合使用。</li>
</ul>
<h2 id="类型计算与SFINAE"><a href="#类型计算与SFINAE" class="headerlink" title="类型计算与SFINAE"></a>类型计算与SFINAE</h2><ul>
<li><strong>类型计算</strong>：在编译期进行类型的推导和转换。</li>
<li><strong>SFINAE（Substitution Failure Is Not An Error）</strong>：模板实例化过程中，如果某个替换失败，编译器不会报错，而是忽略该模板，并尝试其他匹配。</li>
</ul>
<h3 id="示例：检测类型是否可加"><a href="#示例：检测类型是否可加" class="headerlink" title="示例：检测类型是否可加"></a>示例：检测类型是否可加</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> is_addable : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_addable</span>&lt;T, <span class="keyword">decltype</span>(<span class="built_in">void</span>(std::<span class="built_in">declval</span>&lt;T&gt;() + std::<span class="built_in">declval</span>&lt;T&gt;()))&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;is_addable&lt;T&gt;::value, T&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int is addable: &quot;</span> &lt;&lt; is_addable&lt;<span class="type">int</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::string is addable: &quot;</span> &lt;&lt; is_addable&lt;std::string&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>), std::<span class="built_in">string</span>(<span class="string">&quot; World&quot;</span>)) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>讲解：</strong></p>
<ol>
<li><p><code>struct is_addable&lt;...&gt; : std::true_type &#123;&#125;</code></p>
<ul>
<li>目的：定义一个名为 <code>is_addable</code> 的结构体模板，它继承自 <code>std::true_type</code>。</li>
<li>作用：当特定的模板参数满足条件时，这个特化版本将被选中，表示 T 类型是可加的，即支持 <code>+</code> 操作符。</li>
</ul>
</li>
<li><p>模板参数解释：<code>&lt;T, decltype(void(std::declval&lt;T&gt;() + std::declval&lt;T&gt;()))&gt;</code></p>
<ul>
<li><code>T</code>：这是要检查的类型。</li>
<li><code>std::declval&lt;T&gt;()</code>：<ul>
<li>用途：<code>std::declval&lt;T&gt;()</code> 是一个用于在不实际创建 T 类型对象的情况下，生成一个 T 类型的右值引用。</li>
<li>作用：它允许我们在编译时模拟 T 类型的对象，以便用于表达式的检测。</li>
</ul>
</li>
<li><code>std::declval&lt;T&gt;() + std::declval&lt;T&gt;()</code>：<ul>
<li>表达式：尝试对两个 T 类型的右值引用进行加法运算。</li>
<li>目的：检查 T 类型是否支持 <code>+</code> 操作符。</li>
</ul>
</li>
<li><code>void(...)</code>：<ul>
<li>将加法表达式的结果转换为 <code>void</code> 类型。这是为了在 <code>decltype</code> 中仅关心表达式是否有效，而不关心其具体类型。</li>
</ul>
</li>
<li><code>decltype(void(std::declval&lt;T&gt;() + std::declval&lt;T&gt;()))</code>：<ul>
<li>作用：如果 T 类型支持加法运算，则该 <code>decltype</code> 表达式的类型为 <code>void</code>，否则会导致替换失败。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="高级模板元编程技巧"><a href="#高级模板元编程技巧" class="headerlink" title="高级模板元编程技巧"></a>高级模板元编程技巧</h2><ul>
<li><strong>变参模板（Variadic Templates）</strong>：支持模板参数包，实现更加灵活的模板定义。</li>
</ul>
<h3 id="示例：求和模板"><a href="#示例：求和模板" class="headerlink" title="示例：求和模板"></a>示例：求和模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span>... Ns&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span>&lt;&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N, <span class="type">int</span>... Ns&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span>&lt;N, Ns...&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N + Sum&lt;Ns...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; Sum&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>讲解：</strong></p>
<ol>
<li>基本模板<code>Sum</code>接受一个整数参数包<code>Ns...</code>。</li>
<li>特化模板<code>Sum&lt;&gt;</code>定义递归终止条件，<code>value</code>为0。</li>
<li>递归定义<code>Sum&lt;N, Ns...&gt;</code>将第一个参数<code>N</code>与剩余参数的和相加。</li>
<li>在main函数中，通过<code>Sum&lt;1, 2, 3, 4, 5&gt;::value</code>计算1+2+3+4+5&#x3D;15。</li>
</ol>
<ul>
<li><strong>类型列表（Type Lists）</strong>：通过模板参数包管理类型的集合。</li>
</ul>
<h3 id="示例：类型列表和元素访问"><a href="#示例：类型列表和元素访问" class="headerlink" title="示例：类型列表和元素访问"></a>示例：类型列表和元素访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeList</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> List, <span class="type">unsigned</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeAt</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeAt</span>&lt;TypeList&lt;Head, Tail...&gt;, <span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = Head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail, <span class="type">unsigned</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeAt</span>&lt;TypeList&lt;Head, Tail...&gt;, N&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> TypeAt&lt;TypeList&lt;Tail...&gt;, N - <span class="number">1</span>&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> list = TypeList&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">char</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> third_type = TypeAt&lt;list, <span class="number">2</span>&gt;::type;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Third type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(third_type).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>讲解：</strong></p>
<ol>
<li><code>TypeList</code>：定义一个包含多个类型的类型列表。</li>
<li><code>TypeAt</code>：通过递归模板，从<code>TypeList</code>中获取第N个类型。<ul>
<li>当N为0时，类型为<code>Head</code>。</li>
<li>否则，递归获取<code>Tail...</code>中第N-1个类型。</li>
</ul>
</li>
<li>使用：定义<code>list</code>为<code>TypeList&lt;int, double, char&gt;</code>，<code>third_type</code>为第2个类型，即<code>char</code>。</li>
</ol>
<h2 id="实际应用案例"><a href="#实际应用案例" class="headerlink" title="实际应用案例"></a>实际应用案例</h2><h3 id="案例1：静态断言与类型检查"><a href="#案例1：静态断言与类型检查" class="headerlink" title="案例1：静态断言与类型检查"></a>案例1：静态断言与类型检查</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_arithmetic&lt;T&gt;::value, <span class="string">&quot;T must be arithmetic type&quot;</span>);</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(<span class="number">42</span>);      <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">process</span>(<span class="number">3.14</span>);    <span class="comment">// OK</span></span><br><span class="line">    <span class="comment">// process(&quot;hello&quot;); // 编译错误：静态断言失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例2：编译期字符串"><a href="#案例2：编译期字符串" class="headerlink" title="案例2：编译期字符串"></a>案例2：编译期字符串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> String&lt;Cs...&gt;::value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>] = &#123;Cs..., <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Hello = String&lt;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&gt;;</span><br><span class="line">    std::cout &lt;&lt; Hello::value &lt;&lt; std::endl;  <span class="comment">// 输出：Hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么需要外部定义-value"><a href="#为什么需要外部定义-value" class="headerlink" title="为什么需要外部定义 value"></a>为什么需要外部定义 value</h3><p>在 C++ 中，静态成员变量与类的实例无关，它们存在于全局命名空间中。然而，静态成员变量的声明和定义是不同的：</p>
<ol>
<li><strong>声明</strong>：告诉编译器类中存在这个变量。</li>
<li><strong>定义</strong>：为这个变量分配存储空间。</li>
</ol>
<p>对于非 <code>inline</code> 的静态成员变量，即使是 <code>constexpr</code>，都需要在类外部进行定义。否则，链接器在处理多个翻译单元时会因为找不到变量的定义而报错。</p>
<h4 id="具体原因"><a href="#具体原因" class="headerlink" title="具体原因"></a>具体原因</h4><ol>
<li><p><strong>模板类的静态成员变量</strong>：</p>
<ul>
<li>每当模板实例化时，都会产生一个新的类类型，每个类类型都有自己的一组静态成员变量。</li>
<li>因此，编译器需要知道这些静态成员变量在所有翻译单元中都唯一对应一个定义。</li>
</ul>
</li>
<li><p><strong>constexpr 静态成员变量</strong>：</p>
<ul>
<li>从 C++17 开始，<code>inline</code> 关键字引入，使得 <code>constexpr</code> 静态成员变量可以在类内定义，并且隐式地具有 <code>inline</code> 属性。这意味着不需要在类外定义它们，因为 <code>inline</code> 确保了在多个翻译单元中有同一份定义。</li>
<li>但在 C++17 之前或不使用 <code>inline</code> 的情况下，即使是 <code>constexpr</code>，仍需在类外定义。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>类内声明</strong>：<code>static constexpr char value[...]</code> 声明了 <code>value</code> 并给予了初始值。</li>
<li><strong>类外定义</strong>：<code>constexpr char String&lt;Cs...&gt;::value[...]</code> 为 <code>value</code> 分配了存储空间。</li>
</ul>
<p>如果省略类外定义，编译器会在链接阶段找不到 <code>value</code> 的定义，导致链接错误。这尤其适用于 C++14 及更早版本，以及 C++17 中未使用 <code>inline</code> 的情形。</p>
<h3 id="如何避免外部定义"><a href="#如何避免外部定义" class="headerlink" title="如何避免外部定义"></a>如何避免外部定义</h3><p>如果你使用的是 C++17 或更高版本，可以通过 <code>inline</code> 关键字将静态成员变量声明为 <code>inline</code>，从而在类内完成定义，无需再在外部定义。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span> value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>] = &#123;Cs..., <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个版本中，<code>inline</code> 关键字告诉编译器这是一个内联变量，允许在多个翻译单元中存在同一份定义，而不会导致重复定义错误。因此，无需在类外再次定义 <code>value</code>。</p>
<h3 id="完整示例对比"><a href="#完整示例对比" class="headerlink" title="完整示例对比"></a>完整示例对比</h3><h4 id="不使用-inline（需要类外定义）"><a href="#不使用-inline（需要类外定义）" class="headerlink" title="不使用 inline（需要类外定义）"></a>不使用 inline（需要类外定义）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++14 及更早版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> String&lt;Cs...&gt;::value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>] = &#123;Cs..., <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用-inline（无需类外定义，C-17-起）"><a href="#使用-inline（无需类外定义，C-17-起）" class="headerlink" title="使用 inline（无需类外定义，C++17 起）"></a>使用 inline（无需类外定义，C++17 起）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++17 及更高版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span> value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>] = &#123;Cs..., <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="C-20-Concepts"><a href="#C-20-Concepts" class="headerlink" title="C++20 Concepts"></a>C++20 Concepts</h2><p>C++20 引入了 Concepts，它们为模板参数提供了更强的约束和表达能力，使模板的使用更简洁、错误信息更友好。</p>
<h3 id="定义与使用"><a href="#定义与使用" class="headerlink" title="定义与使用"></a>定义与使用</h3><h4 id="定义一个-Concept"><a href="#定义一个-Concept" class="headerlink" title="定义一个 Concept"></a>定义一个 Concept</h4><p>Concepts 使用 <code>concept</code> 关键字定义，并作为函数或类模板的约束。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Arithmetic = std::integral&lt;T&gt; || std::floating_point&lt;T&gt;;</span><br></pre></td></tr></table></figure>

<h4 id="使用-Concept-约束模板"><a href="#使用-Concept-约束模板" class="headerlink" title="使用 Concept 约束模板"></a>使用 Concept 约束模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;Arithmetic T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 requires 子句</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> Arithmetic&lt;T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">multiply</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="限制与约束"><a href="#限制与约束" class="headerlink" title="限制与约束"></a>限制与约束</h3><p>Concepts 允许为模板参数定义复杂的约束，使得模板更具表达性，同时提升编译器错误信息的可理解性。</p>
<h4 id="示例：排序函数中的-Concepts"><a href="#示例：排序函数中的-Concepts" class="headerlink" title="示例：排序函数中的 Concepts"></a>示例：排序函数中的 Concepts</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Sortable = <span class="built_in">requires</span>(T a, T b) &#123;</span><br><span class="line">    &#123; a &lt; b &#125; -&gt; std::convertible_to&lt;<span class="type">bool</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;Sortable T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortAndPrint</span><span class="params">(std::vector&lt;T&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">sortAndPrint</span>(numbers);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::vector&lt;std::vector&lt;int&gt;&gt; nested; // 不会满足 Sortable 概念</span></span><br><span class="line">    <span class="comment">// sortAndPrint(nested); // 编译错误</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 3 4 5 </span><br></pre></td></tr></table></figure>

<h3 id="要点：-5"><a href="#要点：-5" class="headerlink" title="要点："></a>要点：</h3><ul>
<li>Concepts 提供了模板参数的语义约束。</li>
<li>使用 Concepts 提高模板的可读性和可维护性。</li>
<li>生成更友好的编译错误信息，易于调试。</li>
</ul>
<h2 id="模板实例化与编译器行为"><a href="#模板实例化与编译器行为" class="headerlink" title="模板实例化与编译器行为"></a>模板实例化与编译器行为</h2><p>理解模板实例化的过程有助于进行有效的模板设计与优化，尤其是在涉及链接和编译时间时。</p>
<h3 id="显式实例化（Explicit-Instantiation）"><a href="#显式实例化（Explicit-Instantiation）" class="headerlink" title="显式实例化（Explicit Instantiation）"></a>显式实例化（Explicit Instantiation）</h3><p>显式实例化告诉编译器生成特定类型下的模板代码，主要用于分离模板的声明与定义，减少编译时间。</p>
<h4 id="语法：-5"><a href="#语法：-5" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&lt;Type&gt;;      <span class="comment">// 类模板显式实例化</span></span><br><span class="line"><span class="keyword">template</span> returnType <span class="built_in">functionName</span>&lt;Type&gt;(parameters); <span class="comment">// 函数模板显式实例化</span></span><br></pre></td></tr></table></figure>

<h4 id="示例：分离类模板的声明与定义"><a href="#示例：分离类模板的声明与定义" class="headerlink" title="示例：分离类模板的声明与定义"></a>示例：分离类模板的声明与定义</h4><p><strong>MyClass.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(T v);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>MyClass.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyClass&lt;T&gt;::<span class="built_in">MyClass</span>(T v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> MyClass&lt;T&gt;::<span class="built_in">print</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">double</span>&gt;;</span><br></pre></td></tr></table></figure>

<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">int</span>&gt; <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">double</span>&gt; <span class="title">obj2</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    obj1.<span class="built_in">print</span>();</span><br><span class="line">    obj2.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value: 42</span><br><span class="line">Value: 3.14</span><br></pre></td></tr></table></figure>

<h4 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h4><ul>
<li>显式实例化需要在模板定义后进行。</li>
<li>只有显式实例化的类型在未实例化时可用于模板分离。</li>
<li>未显式实例化的类型可能导致链接错误。</li>
</ul>
<h3 id="隐式实例化（Implicit-Instantiation）"><a href="#隐式实例化（Implicit-Instantiation）" class="headerlink" title="隐式实例化（Implicit Instantiation）"></a>隐式实例化（Implicit Instantiation）</h3><p>隐式实例化是编译器在模板被实际使用时自动生成对应实例代码的过程。通常，模板定义与使用都在头文件中完成。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p><strong>MyClass.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(T v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">int</span>&gt; <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">double</span>&gt; <span class="title">obj2</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    obj1.<span class="built_in">print</span>();</span><br><span class="line">    obj2.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value: 42</span><br><span class="line">Value: 3.14</span><br></pre></td></tr></table></figure>

<h4 id="要点：-6"><a href="#要点：-6" class="headerlink" title="要点："></a>要点：</h4><ul>
<li>隐式实例化不需要显式声明或定义。</li>
<li>模板定义必须在使用前可见，通常通过头文件实现。</li>
<li>容易导致编译时间增加，尤其是大型模板库。</li>
</ul>
<h3 id="链接时问题与解决方案"><a href="#链接时问题与解决方案" class="headerlink" title="链接时问题与解决方案"></a>链接时问题与解决方案</h3><p>由于模板是在使用时被实例化，跨源文件使用模板可能导致链接时问题，如重复定义或未定义引用。</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ol>
<li><strong>内联实现</strong>：将模板的定义与声明一起放在头文件中，避免链接时重复定义。</li>
<li><strong>显式实例化</strong>：将常用的模板实例化放在源文件中，其他源文件通过 <code>extern</code> 或头文件引用已有实例。</li>
<li><strong>使用 extern template</strong>：告知编译器某些模板实例已在其他源文件中显式实例化。</li>
</ol>
<h4 id="示例：使用-extern-template"><a href="#示例：使用-extern-template" class="headerlink" title="示例：使用 extern template"></a>示例：使用 extern template</h4><p><strong>MyClass.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// ... 声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明外部实例化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">double</span>&gt;;</span><br></pre></td></tr></table></figure>

<p><strong>MyClass.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义（实例化）</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">double</span>&gt;;</span><br></pre></td></tr></table></figure>

<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">int</span>&gt; <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;    <span class="comment">// 使用外部实例化</span></span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">double</span>&gt; <span class="title">obj2</span><span class="params">(<span class="number">3.14</span>)</span></span>; <span class="comment">// 使用外部实例化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="要点：-7"><a href="#要点：-7" class="headerlink" title="要点："></a>要点：</h4><ul>
<li>使用 <code>extern template</code> 声明已在其他源文件中实例化的模板。</li>
<li>减少编译时间和链接大小，防止重复定义。</li>
</ul>
<h2 id="最佳实践与注意事项"><a href="#最佳实践与注意事项" class="headerlink" title="最佳实践与注意事项"></a>最佳实践与注意事项</h2><p>掌握模板的最佳实践有助于编写高效、可维护的代码，同时避免常见的陷阱和问题。</p>
<h3 id="模板定义与实现分离"><a href="#模板定义与实现分离" class="headerlink" title="模板定义与实现分离"></a>模板定义与实现分离</h3><p>对于类模板，通常将模板的声明和定义放在同一头文件中，以确保编译器在实例化模板时能够看到完整的定义。尽管可以尝试将模板定义分离到源文件，但需要结合显式实例化，这会增加复杂性，且不适用于广泛使用的模板。</p>
<h4 id="推荐做法："><a href="#推荐做法：" class="headerlink" title="推荐做法："></a>推荐做法：</h4><ul>
<li><strong>类模板</strong>：将声明和实现统一在头文件中。</li>
<li><strong>函数模板</strong>：同样将声明和实现统一在头文件中，或使用显式实例化。</li>
</ul>
<h3 id="避免过度模板化"><a href="#避免过度模板化" class="headerlink" title="避免过度模板化"></a>避免过度模板化</h3><p>虽然模板提供了极大的灵活性，但过度复杂的模板会导致代码难以理解、维护和编译时间增加。</p>
<h4 id="建议："><a href="#建议：" class="headerlink" title="建议："></a>建议：</h4><ul>
<li>只在必要时使用模板。</li>
<li>保持模板的简单性和可读性，避免过度嵌套和复杂的特化。</li>
<li>合理使用类型特性和 Concepts 进行约束。</li>
</ul>
<h3 id="提高编译速度的方法"><a href="#提高编译速度的方法" class="headerlink" title="提高编译速度的方法"></a>提高编译速度的方法</h3><p>模板的广泛使用可能导致编译时间显著增加。以下方法有助于优化编译速度：</p>
<ol>
<li><strong>预编译头文件（Precompiled Headers）</strong>：将频繁使用的模板库放入预编译头中，加速编译。</li>
<li><strong>显式实例化</strong>：通过显式实例化减少模板的重复编译。</li>
<li><strong>模块化编程（C++20 Modules）</strong>：利用模块化将模板库进行编译和链接，减少编译时间。</li>
<li><strong>合理分割头文件</strong>：避免头文件中的模板定义过大，分割成较小的模块。</li>
</ol>
<h3 id="代码复用与库设计"><a href="#代码复用与库设计" class="headerlink" title="代码复用与库设计"></a>代码复用与库设计</h3><p>模板是实现高度复用库组件的有效手段，如标准库（<code>std::vector</code>、<code>std::map</code> 等）广泛使用模板。设计模板库时，需考虑以下因素：</p>
<ul>
<li><strong>接口的一致性</strong>：保持模板库的接口简洁、一致，便于使用者理解和使用。</li>
<li><strong>文档与示例</strong>：提供详细的文档和示例代码，帮助使用者理解模板库的用法。</li>
<li><strong>错误信息友好</strong>：通过 Concepts、SFINAE 等机制提供清晰的错误信息，降低使用门槛。</li>
<li><strong>性能优化</strong>：利用模板的编译期计算和内联等特性，提高库组件的性能。</li>
</ul>
<h3 id="避免模板错误的困惑"><a href="#避免模板错误的困惑" class="headerlink" title="避免模板错误的困惑"></a>避免模板错误的困惑</h3><p>模板错误通常复杂且难以理解，以下方法有助于减少模板错误的困惑：</p>
<ul>
<li><strong>逐步调试</strong>：从简单的模板开始，逐步增加复杂性，便于定位错误。</li>
<li><strong>使用编译器警告与工具</strong>：开启编译器的警告选项，使用静态分析工具检测模板代码中的问题。</li>
<li><strong>代码注释与文档</strong>：详细注释复杂的模板代码，提供文档说明其设计和用途。</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>C++ 模板机制是实现泛型编程的核心工具，通过类型参数化和编译期计算，极大地提升了代码的复用性、灵活性和性能。从基础的函数模板和类模板，到高级的模板特化、变参模板、模板元编程、SFINAE 和 Concepts，掌握模板的各个方面能够帮助开发者编写更高效、更加通用的 C++ 代码。</p>
<p>在实际应用中，合理运用模板不仅可以简化代码结构，还可以提高代码的可维护性和可扩展性。然而，模板的复杂性也要求开发者具备扎实的 C++ 基础和良好的编程习惯，以避免过度复杂化和难以调试的问题。</p>
<p>通过本教案的系统学习，相信您已经具备了全面理解和运用 C++ 模板的能力，能够在实际项目中高效地利用模板特性，编写出更为优秀的代码。</p>
<h2 id="练习与习题"><a href="#练习与习题" class="headerlink" title="练习与习题"></a>练习与习题</h2><h3 id="练习-1：实现一个通用的-Swap-函数模板"><a href="#练习-1：实现一个通用的-Swap-函数模板" class="headerlink" title="练习 1：实现一个通用的 Swap 函数模板"></a>练习 1：实现一个通用的 Swap 函数模板</h3><p><strong>要求：</strong></p>
<ul>
<li>编写一个函数模板 <code>swapValues</code>，可以交换任意类型的两个变量。</li>
<li>在 main 函数中测试 int、double、std::string 类型的交换。</li>
</ul>
<p><strong>提示：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapValues</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现交换逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习-2：实现一个模板类-Triple，存储三个相同类型的值，并提供获取各个成员的函数。"><a href="#练习-2：实现一个模板类-Triple，存储三个相同类型的值，并提供获取各个成员的函数。" class="headerlink" title="练习 2：实现一个模板类 Triple，存储三个相同类型的值，并提供获取各个成员的函数。"></a>练习 2：实现一个模板类 Triple，存储三个相同类型的值，并提供获取各个成员的函数。</h3><p><strong>要求：</strong></p>
<ul>
<li>模板参数为类型 T。</li>
<li>提供构造函数、成员变量及访问函数。</li>
<li>在 main 中实例化 <code>Triple&lt;int&gt;</code> 和 <code>Triple&lt;std::string&gt;</code>，进行测试。</li>
</ul>
<h3 id="练习-3：使用模板特化，为类模板-Printer-提供针对-bool-类型的全特化，实现专门的输出格式。"><a href="#练习-3：使用模板特化，为类模板-Printer-提供针对-bool-类型的全特化，实现专门的输出格式。" class="headerlink" title="练习 3：使用模板特化，为类模板 Printer 提供针对 bool 类型的全特化，实现专门的输出格式。"></a>练习 3：使用模板特化，为类模板 Printer 提供针对 bool 类型的全特化，实现专门的输出格式。</h3><p><strong>要求：</strong></p>
<ul>
<li>通用模板类 Printer，具有 print 函数，输出 “General Printer: value”。</li>
<li>全特化 <code>Printer&lt;bool&gt;</code>，输出 “Boolean Printer: true” 或 “Boolean Printer: false”。</li>
</ul>
<h3 id="练习-4：实现一个变参模板函数-logMessages，可以接受任意数量和类型的参数，并依次打印它们。"><a href="#练习-4：实现一个变参模板函数-logMessages，可以接受任意数量和类型的参数，并依次打印它们。" class="headerlink" title="练习 4：实现一个变参模板函数 logMessages，可以接受任意数量和类型的参数，并依次打印它们。"></a>练习 4：实现一个变参模板函数 logMessages，可以接受任意数量和类型的参数，并依次打印它们。</h3><p><strong>要求：</strong></p>
<ul>
<li>使用递归方法实现。</li>
<li>在 main 中测试不同参数组合的调用。</li>
</ul>
<h3 id="练习-5：编写模板元编程结构-IsPointer-用于在编译期判断一个类型是否为指针类型。"><a href="#练习-5：编写模板元编程结构-IsPointer-用于在编译期判断一个类型是否为指针类型。" class="headerlink" title="练习 5：编写模板元编程结构 IsPointer, 用于在编译期判断一个类型是否为指针类型。"></a>练习 5：编写模板元编程结构 IsPointer, 用于在编译期判断一个类型是否为指针类型。</h3><p><strong>要求：</strong></p>
<ul>
<li>定义 <code>IsPointer&lt;T&gt;</code>，包含 value 静态常量成员，值为 true 或 false。</li>
<li>使用特化进行实现。</li>
<li>在 main 中使用 static_assert 进行测试。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(IsPointer&lt;<span class="type">int</span>*&gt;::value, <span class="string">&quot;int* should be a pointer&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(!IsPointer&lt;<span class="type">int</span>&gt;::value, <span class="string">&quot;int should not be a pointer&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="练习-6：使用-SFINAE，编写一个函数模板-enableIfExample，只有当类型-T-具有-size-成员函数时才启用。"><a href="#练习-6：使用-SFINAE，编写一个函数模板-enableIfExample，只有当类型-T-具有-size-成员函数时才启用。" class="headerlink" title="练习 6：使用 SFINAE，编写一个函数模板 enableIfExample，只有当类型 T 具有 size() 成员函数时才启用。"></a>练习 6：使用 SFINAE，编写一个函数模板 enableIfExample，只有当类型 T 具有 size() 成员函数时才启用。</h3><p><strong>要求：</strong></p>
<ul>
<li>使用 std::enable_if 和类型特性检测 size() 成员。</li>
<li>在 main 中测试 std::vector<int>（应启用）和 int（不应启用）。</li>
</ul>
<p><strong>提示：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;has_size&lt;T&gt;::value&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">enableIfExample</span><span class="params">(<span class="type">const</span> T&amp; container)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size: &quot;</span> &lt;&lt; container.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习-7：使用-C-20-Concepts，定义一个-Concept-Integral，要求类型必须是整型，并使用该-Concept-约束一个函数模板-isEven，判断传入的整数是否为偶数。"><a href="#练习-7：使用-C-20-Concepts，定义一个-Concept-Integral，要求类型必须是整型，并使用该-Concept-约束一个函数模板-isEven，判断传入的整数是否为偶数。" class="headerlink" title="练习 7：使用 C++20 Concepts，定义一个 Concept Integral，要求类型必须是整型，并使用该 Concept 约束一个函数模板 isEven，判断传入的整数是否为偶数。"></a>练习 7：使用 C++20 Concepts，定义一个 Concept Integral，要求类型必须是整型，并使用该 Concept 约束一个函数模板 isEven，判断传入的整数是否为偶数。</h3><p><strong>要求：</strong></p>
<ul>
<li>定义 Integral Concept。</li>
<li>编写函数模板 isEven(u)，仅接受满足 Integral 的类型。</li>
<li>在 main 中测试不同类型的调用。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;Integral T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEven</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习-8：实现一个固定大小的栈（FixedStack）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。"><a href="#练习-8：实现一个固定大小的栈（FixedStack）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。" class="headerlink" title="练习 8：实现一个固定大小的栈（FixedStack）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。"></a>练习 8：实现一个固定大小的栈（FixedStack）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。</h3><p><strong>要求：</strong></p>
<ul>
<li>模板参数为类型 T 和 std::size_t N。</li>
<li>提供 push, pop, top 等成员函数。</li>
<li>在 main 中测试 <code>FixedStack&lt;int, 5&gt;</code> 和 <code>FixedStack&lt;std::string, 3&gt;</code>。</li>
</ul>
<h3 id="练习-9：实现一个模板类-TypeIdentity，其成员类型-type-等同于模板参数-T。并使用-static-assert-检查类型关系。"><a href="#练习-9：实现一个模板类-TypeIdentity，其成员类型-type-等同于模板参数-T。并使用-static-assert-检查类型关系。" class="headerlink" title="练习 9：实现一个模板类 TypeIdentity，其成员类型 type 等同于模板参数 T。并使用 static_assert 检查类型关系。"></a>练习 9：实现一个模板类 TypeIdentity，其成员类型 type 等同于模板参数 T。并使用 static_assert 检查类型关系。</h3><p><strong>要求：</strong></p>
<ul>
<li>定义 <code>TypeIdentity&lt;T&gt;</code>，包含类型成员 type。</li>
<li>使用 std::is_same 与 static_assert 验证。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(std::is_same&lt;TypeIdentity&lt;<span class="type">int</span>&gt;::type, <span class="type">int</span>&gt;::value, <span class="string">&quot;TypeIdentity&lt;int&gt; should be int&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="练习-10：编写一个模板元编程结构-LengthOf-用于在编译期计算类型列表的长度。"><a href="#练习-10：编写一个模板元编程结构-LengthOf-用于在编译期计算类型列表的长度。" class="headerlink" title="练习 10：编写一个模板元编程结构 LengthOf, 用于在编译期计算类型列表的长度。"></a>练习 10：编写一个模板元编程结构 LengthOf, 用于在编译期计算类型列表的长度。</h3><p><strong>要求：</strong></p>
<ul>
<li>使用 TypeList 模板定义类型列表。</li>
<li>定义 <code>LengthOf&lt;TypeList&lt;...&gt;&gt;::value</code> 表示类型列表的长度。</li>
<li>在 main 中使用 static_assert 进行测试。</li>
</ul>
<p><strong>提示：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeList</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LengthOf</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LengthOf</span>&lt;TypeList&lt;Types...&gt;&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> std::<span class="type">size_t</span> value = <span class="keyword">sizeof</span>...(Types);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过上述内容及练习，相信您已全面掌握了 C++ 模板的各个方面。从基础概念到高级技术，模板为 C++ 编程提供了强大的工具。持续练习与应用，将进一步巩固您的模板编程能力。</p>

    

    

    
    <div class="declare"> 
      <ul class="post-copyright">
        <li>
          <strong>本文作者：</strong>
          迪丽惹Bug
        </li>
        <li>
          <strong>本文链接：</strong>
          <a href="https://lyroom.github.io/2025/09/26/C-朝花夕拾-模板详解/" title="C++朝花夕拾-模板详解" target="_blank">https://lyroom.github.io/2025/09/26/C-朝花夕拾-模板详解/</a>
        </li>
        
        <li>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，均采用 <a href="https://github.com/JoeyBling/hexo-theme-yilia-plus/blob/master/LICENSE" rel="external nofollow" target="_blank">MIT</a> 许可协议。转载请注明出处！
        </li>
        
      </ul>
    </div>
    

  </div>
  <div class="article-info article-info-index">
    
    
    

    

    
    
<div class="share-btn share-icons tooltip-left">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">
      <a href="javascript:;" class="share-sns share-outer">
        <i class="icon icon-share"></i>
      </a>
    </span>
    <span class="tooltip-content">
      <div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <!-- <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a> -->
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>
    </span>
  </div>
</div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
     <!-- <img src="//pan.baidu.com/share/qrcode?url=https://lyroom.github.io/2025/09/26/C-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%E6%A8%A1%E6%9D%BF%E8%AF%A6%E8%A7%A3/" alt="微信分享二维码"> -->
    </div>
</div>

<div class="mask js-mask"></div>

    
    <div class="clearfix"></div>
  </div>
  </div>
</article>


<nav id="article-nav">
  
  
    <a href="/2025/09/23/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3%EF%BC%9Ashared-ptr-auto-ptr-%E5%92%8C-weak-ptr/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">C++ 智能指针详解：shared_ptr, auto_ptr 和 weak_ptr</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>


<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
        <div class="toc-container tooltip-left">
            <i class="icon-font icon-category"></i>
            <div class="tooltip tooltip-east">
                <span class="tooltip-item">
                </span>
                <span class="tooltip-content">
                    <div class="toc-article">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">模板详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">模板基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.1.1.</span> <span class="toc-text">函数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">语法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">示例：最大值函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%EF%BC%9A"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">要点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.1.2.</span> <span class="toc-text">类模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%EF%BC%9A-1"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">语法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84-Pair-%E7%B1%BB"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">示例：简单的 Pair 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%EF%BC%9A"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">输出：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%EF%BC%9A-1"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">要点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">模板参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%EF%BC%88Type-Parameters%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">类型参数（Type Parameters）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%EF%BC%88Non-Type-Parameters%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">非类型参数（Non-Type Parameters）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%EF%BC%9A-2"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">语法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%95%B0%E7%BB%84%E7%B1%BB"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">示例：固定大小的数组类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">注意事项：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%EF%BC%88Template-Template-Parameters%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">模板模板参数（Template Template Parameters）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%EF%BC%9A-3"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">语法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">示例：容器适配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%EF%BC%9A-2"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">要点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%EF%BC%88Template-Specialization%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">模板特化（Template Specialization）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E7%89%B9%E5%8C%96%EF%BC%88Full-Specialization%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">全特化（Full Specialization）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%85%A8%E7%89%B9%E5%8C%96"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">示例：类模板全特化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E7%89%B9%E5%8C%96%EF%BC%88Partial-Specialization%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">偏特化（Partial Specialization）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%81%8F%E7%89%B9%E5%8C%96"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">示例：类模板偏特化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-1"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E5%8C%96"><span class="toc-number">1.3.3.</span> <span class="toc-text">函数模板的特化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%85%A8%E7%89%B9%E5%8C%96"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">示例：函数模板全特化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-2"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.3.4.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF%EF%BC%88Variadic-Templates%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">变参模板（Variadic Templates）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">定义与语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%EF%BC%9A-4"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">语法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%B8%8E%E5%B1%95%E5%BC%80%EF%BC%88Recursion-and-Expansion%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">递归与展开（Recursion and Expansion）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%89%93%E5%8D%B0%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">递归示例：打印所有参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%89%88%E6%9C%AC"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">折叠表达式版本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%80%BB%E5%92%8C"><span class="toc-number">1.4.3.</span> <span class="toc-text">折叠表达式示例：计算总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.4.</span> <span class="toc-text">应用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E5%99%A8"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">示例：日志记录器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%EF%BC%9A-3"><span class="toc-number">1.4.5.</span> <span class="toc-text">要点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%8A%98%E5%8F%A0%EF%BC%88Fold-Expressions%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">模板折叠（Fold Expressions）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%83%8C%E6%99%AF"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. 折叠表达式的概念与背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%80%E5%85%83%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88Unary-Fold%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. 一元折叠表达式（Unary Fold）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E4%B8%80%E5%85%83%E6%8A%98%E5%8F%A0%EF%BC%88Unary-Prefix-Fold%EF%BC%89"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">前置一元折叠（Unary Prefix Fold）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BD%AE%E4%B8%80%E5%85%83%E6%8A%98%E5%8F%A0%EF%BC%88Unary-Postfix-Fold%EF%BC%89"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">后置一元折叠（Unary Postfix Fold）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1%EF%BC%9A%E9%80%BB%E8%BE%91%E9%9D%9E%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">示例1：逻辑非操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BA%8C%E5%85%83%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88Binary-Fold%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">3. 二元折叠表达式（Binary Fold）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">二元折叠表达式语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E6%8A%98%E5%8F%A0%E4%B8%8E%E5%8F%B3%E6%8A%98%E5%8F%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">左折叠与右折叠的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1%EF%BC%9A%E6%B1%82%E5%92%8C%EF%BC%88Binary-Left-Fold%EF%BC%89"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">示例1：求和（Binary Left Fold）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2%EF%BC%9A%E4%B9%98%E7%A7%AF%EF%BC%88Binary-Right-Fold%EF%BC%89"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">示例2：乘积（Binary Right Fold）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B3%EF%BC%9A%E9%80%BB%E8%BE%91%E4%B8%8E%EF%BC%88Binary-Left-Fold%EF%BC%89"><span class="toc-number">1.5.3.5.</span> <span class="toc-text">示例3：逻辑与（Binary Left Fold）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B7%A6%E6%8A%98%E5%8F%A0%E4%B8%8E%E5%8F%B3%E6%8A%98%E5%8F%A0%EF%BC%88Left-and-Right-Folds%EF%BC%89"><span class="toc-number">1.5.4.</span> <span class="toc-text">4. 左折叠与右折叠（Left and Right Folds）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E5%B7%A6%E6%8A%98%E5%8F%A0%EF%BC%88Binary-Left-Fold%EF%BC%89"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">二元左折叠（Binary Left Fold）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E5%8F%B3%E6%8A%98%E5%8F%A0%EF%BC%88Binary-Right-Fold%EF%BC%89"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">二元右折叠（Binary Right Fold）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-op-%E5%9C%A8%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.5.</span> <span class="toc-text">5. op 在折叠表达式中的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8A%A0%E6%B3%95%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">示例1：使用加法操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%80%BB%E8%BE%91%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">示例2：使用逻辑与操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B3%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%B7%A6%E7%A7%BB%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E6%B5%81%E6%8F%92%E5%85%A5%EF%BC%89"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">示例3：使用左移操作符（流插入）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B4%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.5.5.4.</span> <span class="toc-text">示例4：使用自定义操作符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.6.</span> <span class="toc-text">6. 示例代码与应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">示例1：字符串拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2%EF%BC%9A%E8%AE%A1%E7%AE%97%E9%80%BB%E8%BE%91%E4%B8%8E"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">示例2：计算逻辑与</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B3%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">示例3：计算最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B4%EF%BC%9A%E7%AD%9B%E9%80%89%E9%80%BB%E8%BE%91"><span class="toc-number">1.5.6.4.</span> <span class="toc-text">示例4：筛选逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.5.7.</span> <span class="toc-text">7. 注意事项与最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SFINAE%EF%BC%88Substitution-Failure-Is-Not-An-Error%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">SFINAE（Substitution Failure Is Not An Error）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSFINAE%EF%BC%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">一、什么是SFINAE？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SFINAE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.2.</span> <span class="toc-text">二、SFINAE的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81SFINAE%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.6.3.</span> <span class="toc-text">三、SFINAE的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81SFINAE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.6.4.</span> <span class="toc-text">四、SFINAE的基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A%E9%80%9A%E8%BF%87std-enable-if%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">示例一：通过std::enable_if实现函数重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%85%B7%E6%9C%89%E7%89%B9%E5%AE%9A%E6%88%90%E5%91%98"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">示例二：检测类型是否具有特定成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%89%EF%BC%9A%E9%80%9A%E8%BF%87%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">示例三：通过模板特化实现不同的行为</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81SFINAE%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.6.5.</span> <span class="toc-text">五、SFINAE的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%8E%B0%E4%BB%A3C-%E4%B8%AD%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">1.6.6.</span> <span class="toc-text">六、现代C++中的替代方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%A6%82%E5%BF%B5%E6%9B%BF%E4%BB%A3SFINAE"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">示例：使用概念替代SFINAE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8std-void-t%E7%AE%80%E5%8C%96has-foo"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">示例：使用std::void_t简化has_foo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8C-20%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.6.3.</span> <span class="toc-text">使用C++20概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.7.</span> <span class="toc-text">七、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E7%BB%93%E5%90%88%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%E4%B8%8E%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">综合案例：结合模板特化与折叠表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.7.1.</span> <span class="toc-text">案例描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.7.2.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-3"><span class="toc-number">1.7.4.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%EF%BC%88Template-Metaprogramming%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">模板元编程（Template Metaprogramming）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-number">1.8.1.</span> <span class="toc-text">什么是模板元编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.8.2.</span> <span class="toc-text">模板元编程的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.8.3.</span> <span class="toc-text">模板元编程基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9F%E8%AE%A1%E7%AE%97"><span class="toc-number">1.8.4.</span> <span class="toc-text">编译期计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E9%98%B6%E4%B9%98"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">示例：编译期阶乘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99"><span class="toc-number">1.8.5.</span> <span class="toc-text">静态成员变量的基本规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%EF%BC%9Astatic-const-%E6%95%B4%E6%95%B0%E6%88%90%E5%91%98"><span class="toc-number">1.8.6.</span> <span class="toc-text">特殊情况：static const 整数成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-11-%E5%8F%8A%E4%B9%8B%E5%89%8D%E7%9A%84%E6%A0%87%E5%87%86"><span class="toc-number">1.8.6.1.</span> <span class="toc-text">C++11 及之前的标准</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-17-%E5%8F%8A%E6%9B%B4%E6%96%B0%E6%A0%87%E5%87%86"><span class="toc-number">1.8.6.2.</span> <span class="toc-text">C++17 及更新标准</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-C-11-%E5%8F%8A%E4%B9%8B%E5%89%8D%E7%9A%84%E6%A0%87%E5%87%86"><span class="toc-number">1.8.7.</span> <span class="toc-text">在 C++11 及之前的标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-C-17-%E5%8F%8A%E6%9B%B4%E9%AB%98%E6%A0%87%E5%87%86"><span class="toc-number">1.8.8.</span> <span class="toc-text">在 C++17 及更高标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E7%A4%BA%E4%BE%8B%E4%B8%8E%E6%B5%8B%E8%AF%95"><span class="toc-number">1.8.9.</span> <span class="toc-text">实际示例与测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1%EF%BC%9A%E4%BB%85%E4%BD%9C%E4%B8%BA%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E4%BD%BF%E7%94%A8"><span class="toc-number">1.8.9.1.</span> <span class="toc-text">示例 1：仅作为编译期常量使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2%EF%BC%9A%E5%8F%96%E5%9D%80"><span class="toc-number">1.8.9.2.</span> <span class="toc-text">示例 2：取址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3%EF%BC%9A%E4%BD%BF%E7%94%A8-inline%EF%BC%88C-17-%E5%8F%8A%E6%9B%B4%E9%AB%98%EF%BC%89"><span class="toc-number">1.8.9.3.</span> <span class="toc-text">示例 3：使用 inline（C++17 及更高）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90"><span class="toc-number">1.8.10.</span> <span class="toc-text">详细解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E8%BF%99%E6%A0%B7%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">1.8.10.1.</span> <span class="toc-text">为什么有这样的特殊处理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E6%80%BB%E6%98%AF%E9%9C%80%E8%A6%81%E5%AE%9A%E4%B9%89%EF%BC%9F"><span class="toc-number">1.8.10.2.</span> <span class="toc-text">是否总是需要定义？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8E%E9%93%BE%E6%8E%A5%E5%99%A8%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.8.10.3.</span> <span class="toc-text">编译器与链接器的行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">1.8.10.4.</span> <span class="toc-text">示例：编译期斐波那契数列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%EF%BC%9A-4"><span class="toc-number">1.8.11.</span> <span class="toc-text">要点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%AE%A1%E7%AE%97%E4%B8%8ESFINAE"><span class="toc-number">1.9.</span> <span class="toc-text">类型计算与SFINAE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%8F%AF%E5%8A%A0"><span class="toc-number">1.9.1.</span> <span class="toc-text">示例：检测类型是否可加</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7"><span class="toc-number">1.10.</span> <span class="toc-text">高级模板元编程技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%B1%82%E5%92%8C%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.10.1.</span> <span class="toc-text">示例：求和模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="toc-number">1.10.2.</span> <span class="toc-text">示例：类型列表和元素访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.11.</span> <span class="toc-text">实际应用案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B1%EF%BC%9A%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">1.11.1.</span> <span class="toc-text">案例1：静态断言与类型检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B2%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.11.2.</span> <span class="toc-text">案例2：编译期字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A4%96%E9%83%A8%E5%AE%9A%E4%B9%89-value"><span class="toc-number">1.11.3.</span> <span class="toc-text">为什么需要外部定义 value</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">具体原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%A4%96%E9%83%A8%E5%AE%9A%E4%B9%89"><span class="toc-number">1.11.4.</span> <span class="toc-text">如何避免外部定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">1.11.5.</span> <span class="toc-text">完整示例对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8-inline%EF%BC%88%E9%9C%80%E8%A6%81%E7%B1%BB%E5%A4%96%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="toc-number">1.11.5.1.</span> <span class="toc-text">不使用 inline（需要类外定义）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-inline%EF%BC%88%E6%97%A0%E9%9C%80%E7%B1%BB%E5%A4%96%E5%AE%9A%E4%B9%89%EF%BC%8CC-17-%E8%B5%B7%EF%BC%89"><span class="toc-number">1.11.5.2.</span> <span class="toc-text">使用 inline（无需类外定义，C++17 起）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-20-Concepts"><span class="toc-number">1.12.</span> <span class="toc-text">C++20 Concepts</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">1.12.1.</span> <span class="toc-text">定义与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-Concept"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">定义一个 Concept</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Concept-%E7%BA%A6%E6%9D%9F%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.12.1.2.</span> <span class="toc-text">使用 Concept 约束模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E4%B8%8E%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.12.2.</span> <span class="toc-text">限制与约束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84-Concepts"><span class="toc-number">1.12.2.1.</span> <span class="toc-text">示例：排序函数中的 Concepts</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%EF%BC%9A-5"><span class="toc-number">1.12.3.</span> <span class="toc-text">要点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.13.</span> <span class="toc-text">模板实例化与编译器行为</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%88Explicit-Instantiation%EF%BC%89"><span class="toc-number">1.13.1.</span> <span class="toc-text">显式实例化（Explicit Instantiation）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%EF%BC%9A-5"><span class="toc-number">1.13.1.1.</span> <span class="toc-text">语法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%86%E7%A6%BB%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="toc-number">1.13.1.2.</span> <span class="toc-text">示例：分离类模板的声明与定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-1"><span class="toc-number">1.13.1.3.</span> <span class="toc-text">注意事项：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%88Implicit-Instantiation%EF%BC%89"><span class="toc-number">1.13.2.</span> <span class="toc-text">隐式实例化（Implicit Instantiation）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.13.2.1.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%EF%BC%9A-6"><span class="toc-number">1.13.2.2.</span> <span class="toc-text">要点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%97%B6%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.13.3.</span> <span class="toc-text">链接时问题与解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">1.13.3.1.</span> <span class="toc-text">解决方案：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8-extern-template"><span class="toc-number">1.13.3.2.</span> <span class="toc-text">示例：使用 extern template</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%EF%BC%9A-7"><span class="toc-number">1.13.3.3.</span> <span class="toc-text">要点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.14.</span> <span class="toc-text">最佳实践与注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB"><span class="toc-number">1.14.1.</span> <span class="toc-text">模板定义与实现分离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E5%81%9A%E6%B3%95%EF%BC%9A"><span class="toc-number">1.14.1.1.</span> <span class="toc-text">推荐做法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E6%A8%A1%E6%9D%BF%E5%8C%96"><span class="toc-number">1.14.2.</span> <span class="toc-text">避免过度模板化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE%EF%BC%9A"><span class="toc-number">1.14.2.1.</span> <span class="toc-text">建议：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.14.3.</span> <span class="toc-text">提高编译速度的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.14.4.</span> <span class="toc-text">代码复用与库设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%A8%A1%E6%9D%BF%E9%94%99%E8%AF%AF%E7%9A%84%E5%9B%B0%E6%83%91"><span class="toc-number">1.14.5.</span> <span class="toc-text">避免模板错误的困惑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.15.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E4%B8%8E%E4%B9%A0%E9%A2%98"><span class="toc-number">1.16.</span> <span class="toc-text">练习与习题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-1%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84-Swap-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.16.1.</span> <span class="toc-text">练习 1：实现一个通用的 Swap 函数模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-2%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E7%B1%BB-Triple%EF%BC%8C%E5%AD%98%E5%82%A8%E4%B8%89%E4%B8%AA%E7%9B%B8%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%EF%BC%8C%E5%B9%B6%E6%8F%90%E4%BE%9B%E8%8E%B7%E5%8F%96%E5%90%84%E4%B8%AA%E6%88%90%E5%91%98%E7%9A%84%E5%87%BD%E6%95%B0%E3%80%82"><span class="toc-number">1.16.2.</span> <span class="toc-text">练习 2：实现一个模板类 Triple，存储三个相同类型的值，并提供获取各个成员的函数。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-3%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%EF%BC%8C%E4%B8%BA%E7%B1%BB%E6%A8%A1%E6%9D%BF-Printer-%E6%8F%90%E4%BE%9B%E9%92%88%E5%AF%B9-bool-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%A8%E7%89%B9%E5%8C%96%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%93%E9%97%A8%E7%9A%84%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E3%80%82"><span class="toc-number">1.16.3.</span> <span class="toc-text">练习 3：使用模板特化，为类模板 Printer 提供针对 bool 类型的全特化，实现专门的输出格式。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-4%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0-logMessages%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%8E%A5%E5%8F%97%E4%BB%BB%E6%84%8F%E6%95%B0%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E5%B9%B6%E4%BE%9D%E6%AC%A1%E6%89%93%E5%8D%B0%E5%AE%83%E4%BB%AC%E3%80%82"><span class="toc-number">1.16.4.</span> <span class="toc-text">练习 4：实现一个变参模板函数 logMessages，可以接受任意数量和类型的参数，并依次打印它们。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-5%EF%BC%9A%E7%BC%96%E5%86%99%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E7%BB%93%E6%9E%84-IsPointer-%E7%94%A8%E4%BA%8E%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E4%B8%BA%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E3%80%82"><span class="toc-number">1.16.5.</span> <span class="toc-text">练习 5：编写模板元编程结构 IsPointer, 用于在编译期判断一个类型是否为指针类型。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-6%EF%BC%9A%E4%BD%BF%E7%94%A8-SFINAE%EF%BC%8C%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF-enableIfExample%EF%BC%8C%E5%8F%AA%E6%9C%89%E5%BD%93%E7%B1%BB%E5%9E%8B-T-%E5%85%B7%E6%9C%89-size-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%97%B6%E6%89%8D%E5%90%AF%E7%94%A8%E3%80%82"><span class="toc-number">1.16.6.</span> <span class="toc-text">练习 6：使用 SFINAE，编写一个函数模板 enableIfExample，只有当类型 T 具有 size() 成员函数时才启用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-7%EF%BC%9A%E4%BD%BF%E7%94%A8-C-20-Concepts%EF%BC%8C%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-Concept-Integral%EF%BC%8C%E8%A6%81%E6%B1%82%E7%B1%BB%E5%9E%8B%E5%BF%85%E9%A1%BB%E6%98%AF%E6%95%B4%E5%9E%8B%EF%BC%8C%E5%B9%B6%E4%BD%BF%E7%94%A8%E8%AF%A5-Concept-%E7%BA%A6%E6%9D%9F%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF-isEven%EF%BC%8C%E5%88%A4%E6%96%AD%E4%BC%A0%E5%85%A5%E7%9A%84%E6%95%B4%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA%E5%81%B6%E6%95%B0%E3%80%82"><span class="toc-number">1.16.7.</span> <span class="toc-text">练习 7：使用 C++20 Concepts，定义一个 Concept Integral，要求类型必须是整型，并使用该 Concept 约束一个函数模板 isEven，判断传入的整数是否为偶数。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-8%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%A0%88%EF%BC%88FixedStack%EF%BC%89%E7%B1%BB%E6%A8%A1%E6%9D%BF%EF%BC%8C%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E3%80%82%E4%BD%BF%E7%94%A8%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A%E6%A0%88%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%82"><span class="toc-number">1.16.8.</span> <span class="toc-text">练习 8：实现一个固定大小的栈（FixedStack）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-9%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E7%B1%BB-TypeIdentity%EF%BC%8C%E5%85%B6%E6%88%90%E5%91%98%E7%B1%BB%E5%9E%8B-type-%E7%AD%89%E5%90%8C%E4%BA%8E%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0-T%E3%80%82%E5%B9%B6%E4%BD%BF%E7%94%A8-static-assert-%E6%A3%80%E6%9F%A5%E7%B1%BB%E5%9E%8B%E5%85%B3%E7%B3%BB%E3%80%82"><span class="toc-number">1.16.9.</span> <span class="toc-text">练习 9：实现一个模板类 TypeIdentity，其成员类型 type 等同于模板参数 T。并使用 static_assert 检查类型关系。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-10%EF%BC%9A%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E7%BB%93%E6%9E%84-LengthOf-%E7%94%A8%E4%BA%8E%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E8%AE%A1%E7%AE%97%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%E3%80%82"><span class="toc-number">1.16.10.</span> <span class="toc-text">练习 10：编写一个模板元编程结构 LengthOf, 用于在编译期计算类型列表的长度。</span></a></li></ol></li></ol></li></ol>
                    </div>
                </span>
            </div>
        </div>
        
    </div>
</aside>














          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2020-2025 <a href="https://lyroom.github.io/" target="_blank">迪丽惹Bug</a>
    	</div>
      	<div class="footer-right">
			
			
      		GitHub:<a href="https://github.com/JoeyBling/hexo-theme-yilia-plus" target="_blank">hexo-theme-yilia-plus</a> by Litten
      	</div>
    </div>
  </div>
  
  
	<script src="/lib/busuanzi.pure.js"></script>
	
  
  
	
	<span id="busuanzi_container_site_pv" style="display:none">
		本站总访问量<span id="busuanzi_value_site_pv"></span>次	
	        <span class="post-meta-divider" >|</span>
	</span>
  	<span id="busuanzi_container_site_uv" style='display:none'>
  		本站访客数<span id="busuanzi_value_site_uv"></span>人
  	</span>
  
</footer>

    </div>
    <script>
	var yiliaConfig = {
		mathjax: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: true
	}
</script>

<script>!function (r) { function e(t) { if (i[t]) return i[t].exports; var n = i[t] = { exports: {}, id: t, loaded: !1 }; return r[t].call(n.exports, n, n.exports, e), n.loaded = !0, n.exports } var i = {}; e.m = r, e.c = i, e.p = "./", e(0) }([function (t, n, r) { r(208), t.exports = r(205) }, function (t, n, r) { var d = r(3), y = r(46), g = r(26), b = r(27), x = r(47), m = "prototype", S = function (t, n, r) { var e, i, o, u, c = t & S.F, f = t & S.G, a = t & S.S, s = t & S.P, l = t & S.B, h = f ? d : a ? d[n] || (d[n] = {}) : (d[n] || {})[m], v = f ? y : y[n] || (y[n] = {}), p = v[m] || (v[m] = {}); for (e in f && (r = n), r) o = ((i = !c && h && void 0 !== h[e]) ? h : r)[e], u = l && i ? x(o, d) : s && "function" == typeof o ? x(Function.call, o) : o, h && b(h, e, o, t & S.U), v[e] != o && g(v, e, u), s && p[e] != o && (p[e] = o) }; d.core = y, S.F = 1, S.G = 2, S.S = 4, S.P = 8, S.B = 16, S.W = 32, S.U = 64, S.R = 128, t.exports = S }, function (t, n, r) { var e = r(5); t.exports = function (t) { if (!e(t)) throw TypeError(t + " is not an object!"); return t } }, function (t, n) { var r = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")(); "number" == typeof __g && (__g = r) }, function (t, n) { t.exports = function (t) { try { return !!t() } catch (t) { return !0 } } }, function (t, n) { t.exports = function (t) { return "object" == typeof t ? null !== t : "function" == typeof t } }, function (t, n) { var r = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")(); "number" == typeof __g && (__g = r) }, function (t, n, r) { var e = r(118)("wks"), i = r(79), o = r(3).Symbol, u = "function" == typeof o; (t.exports = function (t) { return e[t] || (e[t] = u && o[t] || (u ? o : i)("Symbol." + t)) }).store = e }, function (t, n, r) { var e = r(49), i = Math.min; t.exports = function (t) { return 0 < t ? i(e(t), 9007199254740991) : 0 } }, function (t, n) { var r = {}.hasOwnProperty; t.exports = function (t, n) { return r.call(t, n) } }, function (t, n, r) { t.exports = !r(4)(function () { return 7 != Object.defineProperty({}, "a", { get: function () { return 7 } }).a }) }, function (t, n, r) { var e = r(2), i = r(174), o = r(53), u = Object.defineProperty; n.f = r(10) ? Object.defineProperty : function (t, n, r) { if (e(t), n = o(n, !0), e(r), i) try { return u(t, n, r) } catch (t) { } if ("get" in r || "set" in r) throw TypeError("Accessors not supported!"); return "value" in r && (t[n] = r.value), t } }, function (t, n, r) { t.exports = !r(20)(function () { return 7 != Object.defineProperty({}, "a", { get: function () { return 7 } }).a }) }, function (t, n, r) { var e = r(14), i = r(24); t.exports = r(12) ? function (t, n, r) { return e.f(t, n, i(1, r)) } : function (t, n, r) { return t[n] = r, t } }, function (t, n, r) { var e = r(22), i = r(60), o = r(42), u = Object.defineProperty; n.f = r(12) ? Object.defineProperty : function (t, n, r) { if (e(t), n = o(n, !0), e(r), i) try { return u(t, n, r) } catch (t) { } if ("get" in r || "set" in r) throw TypeError("Accessors not supported!"); return "value" in r && (t[n] = r.value), t } }, function (t, n, r) { var e = r(96), i = r(34); t.exports = function (t) { return e(i(t)) } }, function (t, n, r) { var e = r(40)("wks"), i = r(25), o = r(6).Symbol, u = "function" == typeof o; (t.exports = function (t) { return e[t] || (e[t] = u && o[t] || (u ? o : i)("Symbol." + t)) }).store = e }, function (t, n, r) { var e = r(51); t.exports = function (t) { return Object(e(t)) } }, function (t, n) { t.exports = function (t) { return "object" == typeof t ? null !== t : "function" == typeof t } }, function (t, n) { var r = t.exports = { version: "2.6.9" }; "number" == typeof __e && (__e = r) }, function (t, n) { t.exports = function (t) { try { return !!t() } catch (t) { return !0 } } }, function (t, n) { t.exports = function (t) { if ("function" != typeof t) throw TypeError(t + " is not a function!"); return t } }, function (t, n, r) { var e = r(18); t.exports = function (t) { if (!e(t)) throw TypeError(t + " is not an object!"); return t } }, function (t, n) { t.exports = !0 }, function (t, n) { t.exports = function (t, n) { return { enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: n } } }, function (t, n) { var r = 0, e = Math.random(); t.exports = function (t) { return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++r + e).toString(36)) } }, function (t, n, r) { var e = r(11), i = r(75); t.exports = r(10) ? function (t, n, r) { return e.f(t, n, i(1, r)) } : function (t, n, r) { return t[n] = r, t } }, function (t, n, r) { var o = r(3), u = r(26), c = r(30), f = r(79)("src"), e = r(219), i = "toString", a = ("" + e).split(i); r(46).inspectSource = function (t) { return e.call(t) }, (t.exports = function (t, n, r, e) { var i = "function" == typeof r; i && (c(r, "name") || u(r, "name", n)), t[n] !== r && (i && (c(r, f) || u(r, f, t[n] ? "" + t[n] : a.join(String(n)))), t === o ? t[n] = r : e ? t[n] ? t[n] = r : u(t, n, r) : (delete t[n], u(t, n, r))) })(Function.prototype, i, function () { return "function" == typeof this && this[f] || e.call(this) }) }, function (t, n, r) { var e = r(1), i = r(4), u = r(51), c = /"/g, o = function (t, n, r, e) { var i = String(u(t)), o = "<" + n; return "" !== r && (o += " " + r + '="' + String(e).replace(c, "&quot;") + '"'), o + ">" + i + "</" + n + ">" }; t.exports = function (n, t) { var r = {}; r[n] = t(o), e(e.P + e.F * i(function () { var t = ""[n]('"'); return t !== t.toLowerCase() || 3 < t.split('"').length }), "String", r) } }, function (t, n, r) { var e = r(65), i = r(35); t.exports = Object.keys || function (t) { return e(t, i) } }, function (t, n) { var r = {}.hasOwnProperty; t.exports = function (t, n) { return r.call(t, n) } }, function (t, n, r) { var e = r(117), i = r(75), o = r(33), u = r(53), c = r(30), f = r(174), a = Object.getOwnPropertyDescriptor; n.f = r(10) ? a : function (t, n) { if (t = o(t), n = u(n, !0), f) try { return a(t, n) } catch (t) { } if (c(t, n)) return i(!e.f.call(t, n), t[n]) } }, function (t, n, r) { var e = r(30), i = r(17), o = r(154)("IE_PROTO"), u = Object.prototype; t.exports = Object.getPrototypeOf || function (t) { return t = i(t), e(t, o) ? t[o] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? u : null } }, function (t, n, r) { var e = r(116), i = r(51); t.exports = function (t) { return e(i(t)) } }, function (t, n) { t.exports = function (t) { if (null == t) throw TypeError("Can't call method on  " + t); return t } }, function (t, n) { t.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",") }, function (t, n) { t.exports = {} }, function (t, n) { n.f = {}.propertyIsEnumerable }, function (t, n, r) { var e = r(14).f, i = r(9), o = r(16)("toStringTag"); t.exports = function (t, n, r) { t && !i(t = r ? t : t.prototype, o) && e(t, o, { configurable: !0, value: n }) } }, function (t, n, r) { var e = r(40)("keys"), i = r(25); t.exports = function (t) { return e[t] || (e[t] = i(t)) } }, function (t, n, r) { var e = r(19), i = r(6), o = "__core-js_shared__", u = i[o] || (i[o] = {}); (t.exports = function (t, n) { return u[t] || (u[t] = void 0 !== n ? n : {}) })("versions", []).push({ version: e.version, mode: r(23) ? "pure" : "global", copyright: "© 2019 Denis Pushkarev (zloirock.ru)" }) }, function (t, n) { var r = Math.ceil, e = Math.floor; t.exports = function (t) { return isNaN(t = +t) ? 0 : (0 < t ? e : r)(t) } }, function (t, n, r) { var i = r(18); t.exports = function (t, n) { if (!i(t)) return t; var r, e; if (n && "function" == typeof (r = t.toString) && !i(e = r.call(t))) return e; if ("function" == typeof (r = t.valueOf) && !i(e = r.call(t))) return e; if (!n && "function" == typeof (r = t.toString) && !i(e = r.call(t))) return e; throw TypeError("Can't convert object to primitive value") } }, function (t, n, r) { var e = r(6), i = r(19), o = r(23), u = r(44), c = r(14).f; t.exports = function (t) { var n = i.Symbol || (i.Symbol = o ? {} : e.Symbol || {}); "_" == t.charAt(0) || t in n || c(n, t, { value: u.f(t) }) } }, function (t, n, r) { n.f = r(16) }, function (t, n) { var r = {}.toString; t.exports = function (t) { return r.call(t).slice(8, -1) } }, function (t, n) { var r = t.exports = { version: "2.6.9" }; "number" == typeof __e && (__e = r) }, function (t, n, r) { var o = r(21); t.exports = function (e, i, t) { if (o(e), void 0 === i) return e; switch (t) { case 1: return function (t) { return e.call(i, t) }; case 2: return function (t, n) { return e.call(i, t, n) }; case 3: return function (t, n, r) { return e.call(i, t, n, r) } }return function () { return e.apply(i, arguments) } } }, function (t, n, r) { "use strict"; var e = r(4); t.exports = function (t, n) { return !!t && e(function () { n ? t.call(null, function () { }, 1) : t.call(null) }) } }, function (t, n) { var r = Math.ceil, e = Math.floor; t.exports = function (t) { return isNaN(t = +t) ? 0 : (0 < t ? e : r)(t) } }, function (t, n, r) { var x = r(47), m = r(116), S = r(17), w = r(8), e = r(138); t.exports = function (l, t) { var h = 1 == l, v = 2 == l, p = 3 == l, d = 4 == l, y = 6 == l, g = 5 == l || y, b = t || e; return function (t, n, r) { for (var e, i, o = S(t), u = m(o), c = x(n, r, 3), f = w(u.length), a = 0, s = h ? b(t, f) : v ? b(t, 0) : void 0; a < f; a++)if ((g || a in u) && (i = c(e = u[a], a, o), l)) if (h) s[a] = i; else if (i) switch (l) { case 3: return !0; case 5: return e; case 6: return a; case 2: s.push(e) } else if (d) return !1; return y ? -1 : p || d ? d : s } } }, function (t, n) { t.exports = function (t) { if (null == t) throw TypeError("Can't call method on  " + t); return t } }, function (t, n, r) { var i = r(1), o = r(46), u = r(4); t.exports = function (t, n) { var r = (o.Object || {})[t] || Object[t], e = {}; e[t] = n(r), i(i.S + i.F * u(function () { r(1) }), "Object", e) } }, function (t, n, r) { var i = r(5); t.exports = function (t, n) { if (!i(t)) return t; var r, e; if (n && "function" == typeof (r = t.toString) && !i(e = r.call(t))) return e; if ("function" == typeof (r = t.valueOf) && !i(e = r.call(t))) return e; if (!n && "function" == typeof (r = t.toString) && !i(e = r.call(t))) return e; throw TypeError("Can't convert object to primitive value") } }, function (t, n, r) { var d = r(6), y = r(19), g = r(93), b = r(13), x = r(9), m = "prototype", S = function (t, n, r) { var e, i, o, u = t & S.F, c = t & S.G, f = t & S.S, a = t & S.P, s = t & S.B, l = t & S.W, h = c ? y : y[n] || (y[n] = {}), v = h[m], p = c ? d : f ? d[n] : (d[n] || {})[m]; for (e in c && (r = n), r) (i = !u && p && void 0 !== p[e]) && x(h, e) || (o = i ? p[e] : r[e], h[e] = c && "function" != typeof p[e] ? r[e] : s && i ? g(o, d) : l && p[e] == o ? function (e) { var t = function (t, n, r) { if (this instanceof e) { switch (arguments.length) { case 0: return new e; case 1: return new e(t); case 2: return new e(t, n) }return new e(t, n, r) } return e.apply(this, arguments) }; return t[m] = e[m], t }(o) : a && "function" == typeof o ? g(Function.call, o) : o, a && ((h.virtual || (h.virtual = {}))[e] = o, t & S.R && v && !v[e] && b(v, e, o))) }; S.F = 1, S.G = 2, S.S = 4, S.P = 8, S.B = 16, S.W = 32, S.U = 64, S.R = 128, t.exports = S }, function (t, n, r) { var e = r(34); t.exports = function (t) { return Object(e(t)) } }, function (t, n, r) { var o = r(196), e = r(1), i = r(118)("metadata"), u = i.store || (i.store = new (r(200))), c = function (t, n, r) { var e = u.get(t); if (!e) { if (!r) return; u.set(t, e = new o) } var i = e.get(n); if (!i) { if (!r) return; e.set(n, i = new o) } return i }; t.exports = { store: u, map: c, has: function (t, n, r) { var e = c(n, r, !1); return void 0 !== e && e.has(t) }, get: function (t, n, r) { var e = c(n, r, !1); return void 0 === e ? void 0 : e.get(t) }, set: function (t, n, r, e) { c(r, e, !0).set(t, n) }, keys: function (t, n) { var r = c(t, n, !1), e = []; return r && r.forEach(function (t, n) { e.push(n) }), e }, key: function (t) { return void 0 === t || "symbol" == typeof t ? t : String(t) }, exp: function (t) { e(e.S, "Reflect", t) } } }, function (t, n, r) { "use strict"; if (r(10)) { var g = r(68), b = r(3), x = r(4), m = r(1), S = r(132), e = r(159), h = r(47), w = r(70), i = r(75), _ = r(26), o = r(76), u = r(49), O = r(8), E = r(194), c = r(78), f = r(53), a = r(30), M = r(81), P = r(5), v = r(17), p = r(145), j = r(72), F = r(32), A = r(73).f, d = r(161), s = r(79), l = r(7), y = r(50), I = r(120), L = r(119), N = r(162), T = r(82), k = r(125), R = r(77), C = r(137), D = r(166), G = r(11), W = r(31), U = G.f, V = W.f, B = b.RangeError, q = b.TypeError, z = b.Uint8Array, K = "ArrayBuffer", H = "Shared" + K, J = "BYTES_PER_ELEMENT", $ = "prototype", Y = Array[$], X = e.ArrayBuffer, Q = e.DataView, Z = y(0), tt = y(2), nt = y(3), rt = y(4), et = y(5), it = y(6), ot = I(!0), ut = I(!1), ct = N.values, ft = N.keys, at = N.entries, st = Y.lastIndexOf, lt = Y.reduce, ht = Y.reduceRight, vt = Y.join, pt = Y.sort, dt = Y.slice, yt = Y.toString, gt = Y.toLocaleString, bt = l("iterator"), xt = l("toStringTag"), mt = s("typed_constructor"), St = s("def_constructor"), wt = S.CONSTR, _t = S.TYPED, Ot = S.VIEW, Et = "Wrong length!", Mt = y(1, function (t, n) { return It(L(t, t[St]), n) }), Pt = x(function () { return 1 === new z(new Uint16Array([1]).buffer)[0] }), jt = !!z && !!z[$].set && x(function () { new z(1).set({}) }), Ft = function (t, n) { var r = u(t); if (r < 0 || r % n) throw B("Wrong offset!"); return r }, At = function (t) { if (P(t) && _t in t) return t; throw q(t + " is not a typed array!") }, It = function (t, n) { if (!(P(t) && mt in t)) throw q("It is not a typed array constructor!"); return new t(n) }, Lt = function (t, n) { return Nt(L(t, t[St]), n) }, Nt = function (t, n) { for (var r = 0, e = n.length, i = It(t, e); r < e;)i[r] = n[r++]; return i }, Tt = function (t, n, r) { U(t, n, { get: function () { return this._d[r] } }) }, kt = function (t) { var n, r, e, i, o, u, c = v(t), f = arguments.length, a = 1 < f ? arguments[1] : void 0, s = void 0 !== a, l = d(c); if (null != l && !p(l)) { for (u = l.call(c), e = [], n = 0; !(o = u.next()).done; n++)e.push(o.value); c = e } for (s && 2 < f && (a = h(a, arguments[2], 2)), n = 0, r = O(c.length), i = It(this, r); n < r; n++)i[n] = s ? a(c[n], n) : c[n]; return i }, Rt = function () { for (var t = 0, n = arguments.length, r = It(this, n); t < n;)r[t] = arguments[t++]; return r }, Ct = !!z && x(function () { gt.call(new z(1)) }), Dt = function () { return gt.apply(Ct ? dt.call(At(this)) : At(this), arguments) }, Gt = { copyWithin: function (t, n) { return D.call(At(this), t, n, 2 < arguments.length ? arguments[2] : void 0) }, every: function (t) { return rt(At(this), t, 1 < arguments.length ? arguments[1] : void 0) }, fill: function (t) { return C.apply(At(this), arguments) }, filter: function (t) { return Lt(this, tt(At(this), t, 1 < arguments.length ? arguments[1] : void 0)) }, find: function (t) { return et(At(this), t, 1 < arguments.length ? arguments[1] : void 0) }, findIndex: function (t) { return it(At(this), t, 1 < arguments.length ? arguments[1] : void 0) }, forEach: function (t) { Z(At(this), t, 1 < arguments.length ? arguments[1] : void 0) }, indexOf: function (t) { return ut(At(this), t, 1 < arguments.length ? arguments[1] : void 0) }, includes: function (t) { return ot(At(this), t, 1 < arguments.length ? arguments[1] : void 0) }, join: function (t) { return vt.apply(At(this), arguments) }, lastIndexOf: function (t) { return st.apply(At(this), arguments) }, map: function (t) { return Mt(At(this), t, 1 < arguments.length ? arguments[1] : void 0) }, reduce: function (t) { return lt.apply(At(this), arguments) }, reduceRight: function (t) { return ht.apply(At(this), arguments) }, reverse: function () { for (var t, n = this, r = At(n).length, e = Math.floor(r / 2), i = 0; i < e;)t = n[i], n[i++] = n[--r], n[r] = t; return n }, some: function (t) { return nt(At(this), t, 1 < arguments.length ? arguments[1] : void 0) }, sort: function (t) { return pt.call(At(this), t) }, subarray: function (t, n) { var r = At(this), e = r.length, i = c(t, e); return new (L(r, r[St]))(r.buffer, r.byteOffset + i * r.BYTES_PER_ELEMENT, O((void 0 === n ? e : c(n, e)) - i)) } }, Wt = function (t, n) { return Lt(this, dt.call(At(this), t, n)) }, Ut = function (t) { At(this); var n = Ft(arguments[1], 1), r = this.length, e = v(t), i = O(e.length), o = 0; if (r < i + n) throw B(Et); for (; o < i;)this[n + o] = e[o++] }, Vt = { entries: function () { return at.call(At(this)) }, keys: function () { return ft.call(At(this)) }, values: function () { return ct.call(At(this)) } }, Bt = function (t, n) { return P(t) && t[_t] && "symbol" != typeof n && n in t && String(+n) == String(n) }, qt = function (t, n) { return Bt(t, n = f(n, !0)) ? i(2, t[n]) : V(t, n) }, zt = function (t, n, r) { return !(Bt(t, n = f(n, !0)) && P(r) && a(r, "value")) || a(r, "get") || a(r, "set") || r.configurable || a(r, "writable") && !r.writable || a(r, "enumerable") && !r.enumerable ? U(t, n, r) : (t[n] = r.value, t) }; wt || (W.f = qt, G.f = zt), m(m.S + m.F * !wt, "Object", { getOwnPropertyDescriptor: qt, defineProperty: zt }), x(function () { yt.call({}) }) && (yt = gt = function () { return vt.call(this) }); var Kt = o({}, Gt); o(Kt, Vt), _(Kt, bt, Vt.values), o(Kt, { slice: Wt, set: Ut, constructor: function () { }, toString: yt, toLocaleString: Dt }), Tt(Kt, "buffer", "b"), Tt(Kt, "byteOffset", "o"), Tt(Kt, "byteLength", "l"), Tt(Kt, "length", "e"), U(Kt, xt, { get: function () { return this[_t] } }), t.exports = function (t, l, n, o) { var h = t + ((o = !!o) ? "Clamped" : "") + "Array", r = "get" + t, u = "set" + t, v = b[h], c = v || {}, e = v && F(v), i = !v || !S.ABV, f = {}, a = v && v[$], p = function (t, i) { U(t, i, { get: function () { return t = i, (n = this._d).v[r](t * l + n.o, Pt); var t, n }, set: function (t) { return n = i, r = t, e = this._d, o && (r = (r = Math.round(r)) < 0 ? 0 : 255 < r ? 255 : 255 & r), void e.v[u](n * l + e.o, r, Pt); var n, r, e }, enumerable: !0 }) }; i ? (v = n(function (t, n, r, e) { w(t, v, h, "_d"); var i, o, u, c, f = 0, a = 0; if (P(n)) { if (!(n instanceof X || (c = M(n)) == K || c == H)) return _t in n ? Nt(v, n) : kt.call(v, n); i = n, a = Ft(r, l); var s = n.byteLength; if (void 0 === e) { if (s % l) throw B(Et); if ((o = s - a) < 0) throw B(Et) } else if (s < (o = O(e) * l) + a) throw B(Et); u = o / l } else u = E(n), i = new X(o = u * l); for (_(t, "_d", { b: i, o: a, l: o, e: u, v: new Q(i) }); f < u;)p(t, f++) }), a = v[$] = j(Kt), _(a, "constructor", v)) : x(function () { v(1) }) && x(function () { new v(-1) }) && k(function (t) { new v, new v(null), new v(1.5), new v(t) }, !0) || (v = n(function (t, n, r, e) { var i; return w(t, v, h), P(n) ? n instanceof X || (i = M(n)) == K || i == H ? void 0 !== e ? new c(n, Ft(r, l), e) : void 0 !== r ? new c(n, Ft(r, l)) : new c(n) : _t in n ? Nt(v, n) : kt.call(v, n) : new c(E(n)) }), Z(e !== Function.prototype ? A(c).concat(A(e)) : A(c), function (t) { t in v || _(v, t, c[t]) }), v[$] = a, g || (a.constructor = v)); var s = a[bt], d = !!s && ("values" == s.name || null == s.name), y = Vt.values; _(v, mt, !0), _(a, _t, h), _(a, Ot, !0), _(a, St, v), (o ? new v(1)[xt] == h : xt in a) || U(a, xt, { get: function () { return h } }), f[h] = v, m(m.G + m.W + m.F * (v != c), f), m(m.S, h, { BYTES_PER_ELEMENT: l }), m(m.S + m.F * x(function () { c.of.call(v, 1) }), h, { from: kt, of: Rt }), J in a || _(a, J, l), m(m.P, h, Gt), R(h), m(m.P + m.F * jt, h, { set: Ut }), m(m.P + m.F * !d, h, Vt), g || a.toString == yt || (a.toString = yt), m(m.P + m.F * x(function () { new v(1).slice() }), h, { slice: Wt }), m(m.P + m.F * (x(function () { return [1, 2].toLocaleString() != new v([1, 2]).toLocaleString() }) || !x(function () { a.toLocaleString.call([1, 2]) })), h, { toLocaleString: Dt }), T[h] = d ? s : y, g || d || _(a, bt, y) } } else t.exports = function () { } }, function (t, n) { var r = {}.toString; t.exports = function (t) { return r.call(t).slice(8, -1) } }, function (t, n, r) { var e = r(18), i = r(6).document, o = e(i) && e(i.createElement); t.exports = function (t) { return o ? i.createElement(t) : {} } }, function (t, n, r) { t.exports = !r(12) && !r(20)(function () { return 7 != Object.defineProperty(r(59)("div"), "a", { get: function () { return 7 } }).a }) }, function (t, n, r) { "use strict"; var x = r(23), m = r(54), S = r(66), w = r(13), _ = r(36), O = r(98), E = r(38), M = r(104), P = r(16)("iterator"), j = !([].keys && "next" in [].keys()), F = "values", A = function () { return this }; t.exports = function (t, n, r, e, i, o, u) { O(r, n, e); var c, f, a, s = function (t) { if (!j && t in p) return p[t]; switch (t) { case "keys": case F: return function () { return new r(this, t) } }return function () { return new r(this, t) } }, l = n + " Iterator", h = i == F, v = !1, p = t.prototype, d = p[P] || p["@@iterator"] || i && p[i], y = d || s(i), g = i ? h ? s("entries") : y : void 0, b = "Array" == n && p.entries || d; if (b && ((a = M(b.call(new t))) !== Object.prototype && a.next && (E(a, l, !0), x || "function" == typeof a[P] || w(a, P, A))), h && d && d.name !== F && (v = !0, y = function () { return d.call(this) }), x && !u || !j && !v && p[P] || w(p, P, y), _[n] = y, _[l] = A, i) if (c = { values: h ? y : s(F), keys: o ? y : s("keys"), entries: g }, u) for (f in c) f in p || S(p, f, c[f]); else m(m.P + m.F * (j || v), n, c); return c } }, function (t, n, e) { var i = e(22), o = e(101), u = e(35), c = e(39)("IE_PROTO"), f = function () { }, a = "prototype", s = function () { var t, n = e(59)("iframe"), r = u.length; for (n.style.display = "none", e(95).appendChild(n), n.src = "javascript:", (t = n.contentWindow.document).open(), t.write("<script>document.F=Object<\/script>"), t.close(), s = t.F; r--;)delete s[a][u[r]]; return s() }; t.exports = Object.create || function (t, n) { var r; return null !== t ? (f[a] = i(t), r = new f, f[a] = null, r[c] = t) : r = s(), void 0 === n ? r : o(r, n) } }, function (t, n, r) { var e = r(65), i = r(35).concat("length", "prototype"); n.f = Object.getOwnPropertyNames || function (t) { return e(t, i) } }, function (t, n) { n.f = Object.getOwnPropertySymbols }, function (t, n, r) { var u = r(9), c = r(15), f = r(92)(!1), a = r(39)("IE_PROTO"); t.exports = function (t, n) { var r, e = c(t), i = 0, o = []; for (r in e) r != a && u(e, r) && o.push(r); for (; n.length > i;)u(e, r = n[i++]) && (~f(o, r) || o.push(r)); return o } }, function (t, n, r) { t.exports = r(13) }, function (t, n, r) { var e = r(7)("unscopables"), i = Array.prototype; null == i[e] && r(26)(i, e, {}), t.exports = function (t) { i[e][t] = !0 } }, function (t, n) { t.exports = !1 }, function (t, n, r) { var e = r(79)("meta"), i = r(5), o = r(30), u = r(11).f, c = 0, f = Object.isExtensible || function () { return !0 }, a = !r(4)(function () { return f(Object.preventExtensions({})) }), s = function (t) { u(t, e, { value: { i: "O" + ++c, w: {} } }) }, l = t.exports = { KEY: e, NEED: !1, fastKey: function (t, n) { if (!i(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t; if (!o(t, e)) { if (!f(t)) return "F"; if (!n) return "E"; s(t) } return t[e].i }, getWeak: function (t, n) { if (!o(t, e)) { if (!f(t)) return !0; if (!n) return !1; s(t) } return t[e].w }, onFreeze: function (t) { return a && l.NEED && f(t) && !o(t, e) && s(t), t } } }, function (t, n) { t.exports = function (t, n, r, e) { if (!(t instanceof n) || void 0 !== e && e in t) throw TypeError(r + ": incorrect invocation!"); return t } }, function (t, n, r) { var h = r(47), v = r(177), p = r(145), d = r(2), y = r(8), g = r(161), b = {}, x = {}; (n = t.exports = function (t, n, r, e, i) { var o, u, c, f, a = i ? function () { return t } : g(t), s = h(r, e, n ? 2 : 1), l = 0; if ("function" != typeof a) throw TypeError(t + " is not iterable!"); if (p(a)) { for (o = y(t.length); l < o; l++)if ((f = n ? s(d(u = t[l])[0], u[1]) : s(t[l])) === b || f === x) return f } else for (c = a.call(t); !(u = c.next()).done;)if ((f = v(c, s, u.value, n)) === b || f === x) return f }).BREAK = b, n.RETURN = x }, function (t, n, e) { var i = e(2), o = e(183), u = e(141), c = e(154)("IE_PROTO"), f = function () { }, a = "prototype", s = function () { var t, n = e(140)("iframe"), r = u.length; for (n.style.display = "none", e(143).appendChild(n), n.src = "javascript:", (t = n.contentWindow.document).open(), t.write("<script>document.F=Object<\/script>"), t.close(), s = t.F; r--;)delete s[a][u[r]]; return s() }; t.exports = Object.create || function (t, n) { var r; return null !== t ? (f[a] = i(t), r = new f, f[a] = null, r[c] = t) : r = s(), void 0 === n ? r : o(r, n) } }, function (t, n, r) { var e = r(185), i = r(141).concat("length", "prototype"); n.f = Object.getOwnPropertyNames || function (t) { return e(t, i) } }, function (t, n, r) { var e = r(185), i = r(141); t.exports = Object.keys || function (t) { return e(t, i) } }, function (t, n) { t.exports = function (t, n) { return { enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: n } } }, function (t, n, r) { var i = r(27); t.exports = function (t, n, r) { for (var e in n) i(t, e, n[e], r); return t } }, function (t, n, r) { "use strict"; var e = r(3), i = r(11), o = r(10), u = r(7)("species"); t.exports = function (t) { var n = e[t]; o && n && !n[u] && i.f(n, u, { configurable: !0, get: function () { return this } }) } }, function (t, n, r) { var e = r(49), i = Math.max, o = Math.min; t.exports = function (t, n) { return (t = e(t)) < 0 ? i(t + n, 0) : o(t, n) } }, function (t, n) { var r = 0, e = Math.random(); t.exports = function (t) { return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++r + e).toString(36)) } }, function (t, n, r) { var e = r(5); t.exports = function (t, n) { if (!e(t) || t._t !== n) throw TypeError("Incompatible receiver, " + n + " required!"); return t } }, function (t, n, r) { var i = r(45), o = r(7)("toStringTag"), u = "Arguments" == i(function () { return arguments }()); t.exports = function (t) { var n, r, e; return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (r = function (t, n) { try { return t[n] } catch (t) { } }(n = Object(t), o)) ? r : u ? i(n) : "Object" == (e = i(n)) && "function" == typeof n.callee ? "Arguments" : e } }, function (t, n) { t.exports = {} }, function (t, n, r) { var e = r(11).f, i = r(30), o = r(7)("toStringTag"); t.exports = function (t, n, r) { t && !i(t = r ? t : t.prototype, o) && e(t, o, { configurable: !0, value: n }) } }, function (t, n, r) { var u = r(1), e = r(51), c = r(4), f = r(157), i = "[" + f + "]", o = RegExp("^" + i + i + "*"), a = RegExp(i + i + "*$"), s = function (t, n, r) { var e = {}, i = c(function () { return !!f[t]() || "​" != "​"[t]() }), o = e[t] = i ? n(l) : f[t]; r && (e[r] = o), u(u.P + u.F * i, "String", e) }, l = s.trim = function (t, n) { return t = String(e(t)), 1 & n && (t = t.replace(o, "")), 2 & n && (t = t.replace(a, "")), t }; t.exports = s }, function (t, n, r) { t.exports = { default: r(88), __esModule: !0 } }, function (t, n, r) { t.exports = { default: r(89), __esModule: !0 } }, function (t, n, r) { "use strict"; function e(t) { return t && t.__esModule ? t : { default: t } } n.__esModule = !0; var i = e(r(86)), o = e(r(85)), u = "function" == typeof o.default && "symbol" == typeof i.default ? function (t) { return typeof t } : function (t) { return t && "function" == typeof o.default && t.constructor === o.default && t !== o.default.prototype ? "symbol" : typeof t }; n.default = "function" == typeof o.default && "symbol" === u(i.default) ? function (t) { return void 0 === t ? "undefined" : u(t) } : function (t) { return t && "function" == typeof o.default && t.constructor === o.default && t !== o.default.prototype ? "symbol" : void 0 === t ? "undefined" : u(t) } }, function (t, n, r) { r(111), r(109), r(112), r(113), t.exports = r(19).Symbol }, function (t, n, r) { r(110), r(114), t.exports = r(44).f("iterator") }, function (t, n) { t.exports = function (t) { if ("function" != typeof t) throw TypeError(t + " is not a function!"); return t } }, function (t, n) { t.exports = function () { } }, function (t, n, r) { var f = r(15), a = r(107), s = r(106); t.exports = function (c) { return function (t, n, r) { var e, i = f(t), o = a(i.length), u = s(r, o); if (c && n != n) { for (; u < o;)if ((e = i[u++]) != e) return !0 } else for (; u < o; u++)if ((c || u in i) && i[u] === n) return c || u || 0; return !c && -1 } } }, function (t, n, r) { var o = r(90); t.exports = function (e, i, t) { if (o(e), void 0 === i) return e; switch (t) { case 1: return function (t) { return e.call(i, t) }; case 2: return function (t, n) { return e.call(i, t, n) }; case 3: return function (t, n, r) { return e.call(i, t, n, r) } }return function () { return e.apply(i, arguments) } } }, function (t, n, r) { var c = r(29), f = r(64), a = r(37); t.exports = function (t) { var n = c(t), r = f.f; if (r) for (var e, i = r(t), o = a.f, u = 0; i.length > u;)o.call(t, e = i[u++]) && n.push(e); return n } }, function (t, n, r) { var e = r(6).document; t.exports = e && e.documentElement }, function (t, n, r) { var e = r(58); t.exports = Object("z").propertyIsEnumerable(0) ? Object : function (t) { return "String" == e(t) ? t.split("") : Object(t) } }, function (t, n, r) { var e = r(58); t.exports = Array.isArray || function (t) { return "Array" == e(t) } }, function (t, n, r) { "use strict"; var e = r(62), i = r(24), o = r(38), u = {}; r(13)(u, r(16)("iterator"), function () { return this }), t.exports = function (t, n, r) { t.prototype = e(u, { next: i(1, r) }), o(t, n + " Iterator") } }, function (t, n) { t.exports = function (t, n) { return { value: n, done: !!t } } }, function (t, n, r) { var e = r(25)("meta"), i = r(18), o = r(9), u = r(14).f, c = 0, f = Object.isExtensible || function () { return !0 }, a = !r(20)(function () { return f(Object.preventExtensions({})) }), s = function (t) { u(t, e, { value: { i: "O" + ++c, w: {} } }) }, l = t.exports = { KEY: e, NEED: !1, fastKey: function (t, n) { if (!i(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t; if (!o(t, e)) { if (!f(t)) return "F"; if (!n) return "E"; s(t) } return t[e].i }, getWeak: function (t, n) { if (!o(t, e)) { if (!f(t)) return !0; if (!n) return !1; s(t) } return t[e].w }, onFreeze: function (t) { return a && l.NEED && f(t) && !o(t, e) && s(t), t } } }, function (t, n, r) { var u = r(14), c = r(22), f = r(29); t.exports = r(12) ? Object.defineProperties : function (t, n) { c(t); for (var r, e = f(n), i = e.length, o = 0; o < i;)u.f(t, r = e[o++], n[r]); return t } }, function (t, n, r) { var e = r(37), i = r(24), o = r(15), u = r(42), c = r(9), f = r(60), a = Object.getOwnPropertyDescriptor; n.f = r(12) ? a : function (t, n) { if (t = o(t), n = u(n, !0), f) try { return a(t, n) } catch (t) { } if (c(t, n)) return i(!e.f.call(t, n), t[n]) } }, function (t, n, r) { var e = r(15), i = r(63).f, o = {}.toString, u = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []; t.exports.f = function (t) { return u && "[object Window]" == o.call(t) ? function (t) { try { return i(t) } catch (t) { return u.slice() } }(t) : i(e(t)) } }, function (t, n, r) { var e = r(9), i = r(55), o = r(39)("IE_PROTO"), u = Object.prototype; t.exports = Object.getPrototypeOf || function (t) { return t = i(t), e(t, o) ? t[o] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? u : null } }, function (t, n, r) { var f = r(41), a = r(34); t.exports = function (c) { return function (t, n) { var r, e, i = String(a(t)), o = f(n), u = i.length; return o < 0 || u <= o ? c ? "" : void 0 : (r = i.charCodeAt(o)) < 55296 || 56319 < r || o + 1 === u || (e = i.charCodeAt(o + 1)) < 56320 || 57343 < e ? c ? i.charAt(o) : r : c ? i.slice(o, o + 2) : e - 56320 + (r - 55296 << 10) + 65536 } } }, function (t, n, r) { var e = r(41), i = Math.max, o = Math.min; t.exports = function (t, n) { return (t = e(t)) < 0 ? i(t + n, 0) : o(t, n) } }, function (t, n, r) { var e = r(41), i = Math.min; t.exports = function (t) { return 0 < t ? i(e(t), 9007199254740991) : 0 } }, function (t, n, r) { "use strict"; var e = r(91), i = r(99), o = r(36), u = r(15); t.exports = r(61)(Array, "Array", function (t, n) { this._t = u(t), this._i = 0, this._k = n }, function () { var t = this._t, n = this._k, r = this._i++; return !t || r >= t.length ? (this._t = void 0, i(1)) : i(0, "keys" == n ? r : "values" == n ? t[r] : [r, t[r]]) }, "values"), o.Arguments = o.Array, e("keys"), e("values"), e("entries") }, function (t, n) { }, function (t, n, r) { "use strict"; var e = r(105)(!0); r(61)(String, "String", function (t) { this._t = String(t), this._i = 0 }, function () { var t, n = this._t, r = this._i; return r >= n.length ? { value: void 0, done: !0 } : (t = e(n, r), this._i += t.length, { value: t, done: !1 }) }) }, function (t, n, r) { "use strict"; var e = r(6), u = r(9), i = r(12), o = r(54), c = r(66), f = r(100).KEY, a = r(20), s = r(40), l = r(38), h = r(25), v = r(16), p = r(44), d = r(43), y = r(94), g = r(97), b = r(22), x = r(18), m = r(55), S = r(15), w = r(42), _ = r(24), O = r(62), E = r(103), M = r(102), P = r(64), j = r(14), F = r(29), A = M.f, I = j.f, L = E.f, N = e.Symbol, T = e.JSON, k = T && T.stringify, R = "prototype", C = v("_hidden"), D = v("toPrimitive"), G = {}.propertyIsEnumerable, W = s("symbol-registry"), U = s("symbols"), V = s("op-symbols"), B = Object[R], q = "function" == typeof N && !!P.f, z = e.QObject, K = !z || !z[R] || !z[R].findChild, H = i && a(function () { return 7 != O(I({}, "a", { get: function () { return I(this, "a", { value: 7 }).a } })).a }) ? function (t, n, r) { var e = A(B, n); e && delete B[n], I(t, n, r), e && t !== B && I(B, n, e) } : I, J = function (t) { var n = U[t] = O(N[R]); return n._k = t, n }, $ = q && "symbol" == typeof N.iterator ? function (t) { return "symbol" == typeof t } : function (t) { return t instanceof N }, Y = function (t, n, r) { return t === B && Y(V, n, r), b(t), n = w(n, !0), b(r), u(U, n) ? (r.enumerable ? (u(t, C) && t[C][n] && (t[C][n] = !1), r = O(r, { enumerable: _(0, !1) })) : (u(t, C) || I(t, C, _(1, {})), t[C][n] = !0), H(t, n, r)) : I(t, n, r) }, X = function (t, n) { b(t); for (var r, e = y(n = S(n)), i = 0, o = e.length; i < o;)Y(t, r = e[i++], n[r]); return t }, Q = function (t) { var n = G.call(this, t = w(t, !0)); return !(this === B && u(U, t) && !u(V, t)) && (!(n || !u(this, t) || !u(U, t) || u(this, C) && this[C][t]) || n) }, Z = function (t, n) { if (t = S(t), n = w(n, !0), t !== B || !u(U, n) || u(V, n)) { var r = A(t, n); return !r || !u(U, n) || u(t, C) && t[C][n] || (r.enumerable = !0), r } }, tt = function (t) { for (var n, r = L(S(t)), e = [], i = 0; r.length > i;)u(U, n = r[i++]) || n == C || n == f || e.push(n); return e }, nt = function (t) { for (var n, r = t === B, e = L(r ? V : S(t)), i = [], o = 0; e.length > o;)!u(U, n = e[o++]) || r && !u(B, n) || i.push(U[n]); return i }; q || (c((N = function () { if (this instanceof N) throw TypeError("Symbol is not a constructor!"); var n = h(0 < arguments.length ? arguments[0] : void 0), r = function (t) { this === B && r.call(V, t), u(this, C) && u(this[C], n) && (this[C][n] = !1), H(this, n, _(1, t)) }; return i && K && H(B, n, { configurable: !0, set: r }), J(n) })[R], "toString", function () { return this._k }), M.f = Z, j.f = Y, r(63).f = E.f = tt, r(37).f = Q, P.f = nt, i && !r(23) && c(B, "propertyIsEnumerable", Q, !0), p.f = function (t) { return J(v(t)) }), o(o.G + o.W + o.F * !q, { Symbol: N }); for (var rt = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), et = 0; rt.length > et;)v(rt[et++]); for (var it = F(v.store), ot = 0; it.length > ot;)d(it[ot++]); o(o.S + o.F * !q, "Symbol", { for: function (t) { return u(W, t += "") ? W[t] : W[t] = N(t) }, keyFor: function (t) { if (!$(t)) throw TypeError(t + " is not a symbol!"); for (var n in W) if (W[n] === t) return n }, useSetter: function () { K = !0 }, useSimple: function () { K = !1 } }), o(o.S + o.F * !q, "Object", { create: function (t, n) { return void 0 === n ? O(t) : X(O(t), n) }, defineProperty: Y, defineProperties: X, getOwnPropertyDescriptor: Z, getOwnPropertyNames: tt, getOwnPropertySymbols: nt }); var ut = a(function () { P.f(1) }); o(o.S + o.F * ut, "Object", { getOwnPropertySymbols: function (t) { return P.f(m(t)) } }), T && o(o.S + o.F * (!q || a(function () { var t = N(); return "[null]" != k([t]) || "{}" != k({ a: t }) || "{}" != k(Object(t)) })), "JSON", { stringify: function (t) { for (var n, r, e = [t], i = 1; arguments.length > i;)e.push(arguments[i++]); if (r = n = e[1], (x(n) || void 0 !== t) && !$(t)) return g(n) || (n = function (t, n) { if ("function" == typeof r && (n = r.call(this, t, n)), !$(n)) return n }), e[1] = n, k.apply(T, e) } }), N[R][D] || r(13)(N[R], D, N[R].valueOf), l(N, "Symbol"), l(Math, "Math", !0), l(e.JSON, "JSON", !0) }, function (t, n, r) { r(43)("asyncIterator") }, function (t, n, r) { r(43)("observable") }, function (t, n, r) { r(108); for (var e = r(6), i = r(13), o = r(36), u = r(16)("toStringTag"), c = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), f = 0; f < c.length; f++) { var a = c[f], s = e[a], l = s && s.prototype; l && !l[u] && i(l, u, a), o[a] = o.Array } }, function (t, n, r) { "use strict"; var e = r(2); t.exports = function () { var t = e(this), n = ""; return t.global && (n += "g"), t.ignoreCase && (n += "i"), t.multiline && (n += "m"), t.unicode && (n += "u"), t.sticky && (n += "y"), n } }, function (t, n, r) { var e = r(45); t.exports = Object("z").propertyIsEnumerable(0) ? Object : function (t) { return "String" == e(t) ? t.split("") : Object(t) } }, function (t, n) { n.f = {}.propertyIsEnumerable }, function (t, n, r) { var e = r(46), i = r(3), o = "__core-js_shared__", u = i[o] || (i[o] = {}); (t.exports = function (t, n) { return u[t] || (u[t] = void 0 !== n ? n : {}) })("versions", []).push({ version: e.version, mode: r(68) ? "pure" : "global", copyright: "© 2019 Denis Pushkarev (zloirock.ru)" }) }, function (t, n, r) { var i = r(2), o = r(21), u = r(7)("species"); t.exports = function (t, n) { var r, e = i(t).constructor; return void 0 === e || null == (r = i(e)[u]) ? n : o(r) } }, function (t, n, r) { var f = r(33), a = r(8), s = r(78); t.exports = function (c) { return function (t, n, r) { var e, i = f(t), o = a(i.length), u = s(r, o); if (c && n != n) { for (; u < o;)if ((e = i[u++]) != e) return !0 } else for (; u < o; u++)if ((c || u in i) && i[u] === n) return c || u || 0; return !c && -1 } } }, function (t, n, r) { "use strict"; var g = r(3), b = r(1), x = r(27), m = r(76), S = r(69), w = r(71), _ = r(70), O = r(5), E = r(4), M = r(125), P = r(83), j = r(144); t.exports = function (e, t, n, r, i, o) { var u = g[e], c = u, f = i ? "set" : "add", a = c && c.prototype, s = {}, l = function (t) { var r = a[t]; x(a, t, "delete" == t ? function (t) { return !(o && !O(t)) && r.call(this, 0 === t ? 0 : t) } : "has" == t ? function (t) { return !(o && !O(t)) && r.call(this, 0 === t ? 0 : t) } : "get" == t ? function (t) { return o && !O(t) ? void 0 : r.call(this, 0 === t ? 0 : t) } : "add" == t ? function (t) { return r.call(this, 0 === t ? 0 : t), this } : function (t, n) { return r.call(this, 0 === t ? 0 : t, n), this }) }; if ("function" == typeof c && (o || a.forEach && !E(function () { (new c).entries().next() }))) { var h = new c, v = h[f](o ? {} : -0, 1) != h, p = E(function () { h.has(1) }), d = M(function (t) { new c(t) }), y = !o && E(function () { for (var t = new c, n = 5; n--;)t[f](n, n); return !t.has(-0) }); d || (((c = t(function (t, n) { _(t, c, e); var r = j(new u, t, c); return null != n && w(n, i, r[f], r), r })).prototype = a).constructor = c), (p || y) && (l("delete"), l("has"), i && l("get")), (y || v) && l(f), o && a.clear && delete a.clear } else c = r.getConstructor(t, e, i, f), m(c.prototype, n), S.NEED = !0; return P(c, e), s[e] = c, b(b.G + b.W + b.F * (c != u), s), o || r.setStrong(c, e, i), c } }, function (t, n, r) { "use strict"; r(197); var s = r(27), l = r(26), h = r(4), v = r(51), p = r(7), d = r(152), y = p("species"), g = !h(function () { var t = /./; return t.exec = function () { var t = []; return t.groups = { a: "7" }, t }, "7" !== "".replace(t, "$<a>") }), b = function () { var t = /(?:)/, n = t.exec; t.exec = function () { return n.apply(this, arguments) }; var r = "ab".split(t); return 2 === r.length && "a" === r[0] && "b" === r[1] }(); t.exports = function (r, t, n) { var e = p(r), o = !h(function () { var t = {}; return t[e] = function () { return 7 }, 7 != ""[r](t) }), i = o ? !h(function () { var t = !1, n = /a/; return n.exec = function () { return t = !0, null }, "split" === r && (n.constructor = {}, n.constructor[y] = function () { return n }), n[e](""), !t }) : void 0; if (!o || !i || "replace" === r && !g || "split" === r && !b) { var u = /./[e], c = n(v, e, ""[r], function (t, n, r, e, i) { return n.exec === d ? o && !i ? { done: !0, value: u.call(n, r, e) } : { done: !0, value: t.call(r, n, e) } : { done: !1 } }), f = c[0], a = c[1]; s(String.prototype, r, f), l(RegExp.prototype, e, 2 == t ? function (t, n) { return a.call(t, this, n) } : function (t) { return a.call(t, this) }) } } }, function (t, n, r) { var e = r(45); t.exports = Array.isArray || function (t) { return "Array" == e(t) } }, function (t, n, r) { var e = r(5), i = r(45), o = r(7)("match"); t.exports = function (t) { var n; return e(t) && (void 0 !== (n = t[o]) ? !!n : "RegExp" == i(t)) } }, function (t, n, r) { var o = r(7)("iterator"), u = !1; try { var e = [7][o](); e.return = function () { u = !0 }, Array.from(e, function () { throw 2 }) } catch (t) { } t.exports = function (t, n) { if (!n && !u) return !1; var r = !1; try { var e = [7], i = e[o](); i.next = function () { return { done: r = !0 } }, e[o] = function () { return i }, t(e) } catch (t) { } return r } }, function (t, n, r) { "use strict"; t.exports = r(68) || !r(4)(function () { var t = Math.random(); __defineSetter__.call(null, t, function () { }), delete r(3)[t] }) }, function (t, n) { n.f = Object.getOwnPropertySymbols }, function (t, n, r) { "use strict"; var i = r(81), o = RegExp.prototype.exec; t.exports = function (t, n) { var r = t.exec; if ("function" == typeof r) { var e = r.call(t, n); if ("object" != typeof e) throw new TypeError("RegExp exec method returned something other than an Object or null"); return e } if ("RegExp" !== i(t)) throw new TypeError("RegExp#exec called on incompatible receiver"); return o.call(t, n) } }, function (t, n, r) { "use strict"; var e = r(1), u = r(21), c = r(47), f = r(71); t.exports = function (t) { e(e.S, t, { from: function (t) { var n, r, e, i, o = arguments[1]; return u(this), (n = void 0 !== o) && u(o), null == t ? new this : (r = [], n ? (e = 0, i = c(o, arguments[2], 2), f(t, !1, function (t) { r.push(i(t, e++)) })) : f(t, !1, r.push, r), new this(r)) } }) } }, function (t, n, r) { "use strict"; var e = r(1); t.exports = function (t) { e(e.S, t, { of: function () { for (var t = arguments.length, n = new Array(t); t--;)n[t] = arguments[t]; return new this(n) } }) } }, function (t, n, r) { var f = r(49), a = r(51); t.exports = function (c) { return function (t, n) { var r, e, i = String(a(t)), o = f(n), u = i.length; return o < 0 || u <= o ? c ? "" : void 0 : (r = i.charCodeAt(o)) < 55296 || 56319 < r || o + 1 === u || (e = i.charCodeAt(o + 1)) < 56320 || 57343 < e ? c ? i.charAt(o) : r : c ? i.slice(o, o + 2) : e - 56320 + (r - 55296 << 10) + 65536 } } }, function (t, n, r) { for (var e, i = r(3), o = r(26), u = r(79), c = u("typed_array"), f = u("view"), a = !(!i.ArrayBuffer || !i.DataView), s = a, l = 0, h = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(","); l < 9;)(e = i[h[l++]]) ? (o(e.prototype, c, !0), o(e.prototype, f, !0)) : s = !1; t.exports = { ABV: a, CONSTR: s, TYPED: c, VIEW: f } }, function (t, n, r) { var e = r(3).navigator; t.exports = e && e.userAgent || "" }, function (t, n) { "use strict"; var r, e = { versions: (r = window.navigator.userAgent, { trident: -1 < r.indexOf("Trident"), presto: -1 < r.indexOf("Presto"), webKit: -1 < r.indexOf("AppleWebKit"), gecko: -1 < r.indexOf("Gecko") && -1 == r.indexOf("KHTML"), mobile: !!r.match(/AppleWebKit.*Mobile.*/), ios: !!r.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), android: -1 < r.indexOf("Android") || -1 < r.indexOf("Linux"), iPhone: -1 < r.indexOf("iPhone") || -1 < r.indexOf("Mac"), iPad: -1 < r.indexOf("iPad"), webApp: -1 == r.indexOf("Safari"), weixin: -1 == r.indexOf("MicroMessenger") }) }; t.exports = e }, function (t, n, r) { "use strict"; var e, i = r(87), l = (e = i) && e.__esModule ? e : { default: e }, h = function () { function n(t, n, r) { return n || r ? String.fromCharCode(n || r) : o[t] || t } function r(t) { return s[t] } var e = /&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g, i = /['<> "&]/g, o = { "&quot;": '"', "&lt;": "<", "&gt;": ">", "&amp;": "&", "&nbsp;": " " }, u = /\u00a0/g, c = /<br\s*\/?>/gi, f = /\r?\n/g, a = /\s/g, s = {}; for (var t in o) s[o[t]] = t; return o["&apos;"] = "'", s["'"] = "&#39;", { encode: function (t) { return t ? ("" + t).replace(i, r).replace(f, "<br/>").replace(a, "&nbsp;") : "" }, decode: function (t) { return t ? ("" + t).replace(c, "\n").replace(e, n).replace(u, " ") : "" }, encodeBase16: function (t) { if (!t) return t; for (var n = [], r = 0, e = (t += "").length; r < e; r++)n.push(t.charCodeAt(r).toString(16).toUpperCase()); return n.join("") }, encodeBase16forJSON: function (t) { if (!t) return t; for (var n = [], r = 0, e = (t = t.replace(/[\u4E00-\u9FBF]/gi, function (t) { return escape(t).replace("%u", "\\u") })).length; r < e; r++)n.push(t.charCodeAt(r).toString(16).toUpperCase()); return n.join("") }, decodeBase16: function (t) { if (!t) return t; for (var n = [], r = 0, e = (t += "").length; r < e; r += 2)n.push(String.fromCharCode("0x" + t.slice(r, r + 2))); return n.join("") }, encodeObject: function (t) { if (t instanceof Array) for (var n = 0, r = t.length; n < r; n++)t[n] = h.encodeObject(t[n]); else if ("object" == (void 0 === t ? "undefined" : (0, l.default)(t))) for (var e in t) t[e] = h.encodeObject(t[e]); else if ("string" == typeof t) return h.encode(t); return t }, loadScript: function (t) { var n = document.createElement("script"); document.getElementsByTagName("body")[0].appendChild(n), n.setAttribute("src", t) }, addLoadEvent: function (t) { var n = window.onload; "function" != typeof window.onload ? window.onload = t : window.onload = function () { n(), t() } } } }(); t.exports = h }, function (t, n, r) { "use strict"; var e = r(131)(!0); t.exports = function (t, n, r) { return n + (r ? e(t, n).length : 1) } }, function (t, n, r) { "use strict"; var c = r(17), f = r(78), a = r(8); t.exports = function (t) { for (var n = c(this), r = a(n.length), e = arguments.length, i = f(1 < e ? arguments[1] : void 0, r), o = 2 < e ? arguments[2] : void 0, u = void 0 === o ? r : f(o, r); i < u;)n[i++] = t; return n } }, function (t, n, r) { var e = r(215); t.exports = function (t, n) { return new (e(t))(n) } }, function (t, n, r) { "use strict"; var e = r(11), i = r(75); t.exports = function (t, n, r) { n in t ? e.f(t, n, i(0, r)) : t[n] = r } }, function (t, n, r) { var e = r(5), i = r(3).document, o = e(i) && e(i.createElement); t.exports = function (t) { return o ? i.createElement(t) : {} } }, function (t, n) { t.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",") }, function (t, n, r) { var e = r(7)("match"); t.exports = function (n) { var r = /./; try { "/./"[n](r) } catch (t) { try { return r[e] = !1, !"/./"[n](r) } catch (n) { } } return !0 } }, function (t, n, r) { var e = r(3).document; t.exports = e && e.documentElement }, function (t, n, r) { var o = r(5), u = r(153).set; t.exports = function (t, n, r) { var e, i = n.constructor; return i !== r && "function" == typeof i && (e = i.prototype) !== r.prototype && o(e) && u && u(t, e), t } }, function (t, n, r) { var e = r(82), i = r(7)("iterator"), o = Array.prototype; t.exports = function (t) { return void 0 !== t && (e.Array === t || o[i] === t) } }, function (t, n, r) { "use strict"; var e = r(72), i = r(75), o = r(83), u = {}; r(26)(u, r(7)("iterator"), function () { return this }), t.exports = function (t, n, r) { t.prototype = e(u, { next: i(1, r) }), o(t, n + " Iterator") } }, function (t, n, r) { "use strict"; var x = r(68), m = r(1), S = r(27), w = r(26), _ = r(82), O = r(146), E = r(83), M = r(32), P = r(7)("iterator"), j = !([].keys && "next" in [].keys()), F = "values", A = function () { return this }; t.exports = function (t, n, r, e, i, o, u) { O(r, n, e); var c, f, a, s = function (t) { if (!j && t in p) return p[t]; switch (t) { case "keys": case F: return function () { return new r(this, t) } }return function () { return new r(this, t) } }, l = n + " Iterator", h = i == F, v = !1, p = t.prototype, d = p[P] || p["@@iterator"] || i && p[i], y = d || s(i), g = i ? h ? s("entries") : y : void 0, b = "Array" == n && p.entries || d; if (b && ((a = M(b.call(new t))) !== Object.prototype && a.next && (E(a, l, !0), x || "function" == typeof a[P] || w(a, P, A))), h && d && d.name !== F && (v = !0, y = function () { return d.call(this) }), x && !u || !j && !v && p[P] || w(p, P, y), _[n] = y, _[l] = A, i) if (c = { values: h ? y : s(F), keys: o ? y : s("keys"), entries: g }, u) for (f in c) f in p || S(p, f, c[f]); else m(m.P + m.F * (j || v), n, c); return c } }, function (t, n) { var r = Math.expm1; t.exports = !r || 22025.465794806718 < r(10) || r(10) < 22025.465794806718 || -2e-17 != r(-2e-17) ? function (t) { return 0 == (t = +t) ? t : -1e-6 < t && t < 1e-6 ? t + t * t / 2 : Math.exp(t) - 1 } : r }, function (t, n) { t.exports = Math.sign || function (t) { return 0 == (t = +t) || t != t ? t : t < 0 ? -1 : 1 } }, function (t, n, r) { var c = r(3), f = r(158).set, a = c.MutationObserver || c.WebKitMutationObserver, s = c.process, l = c.Promise, h = "process" == r(45)(s); t.exports = function () { var r, e, i, t = function () { var t, n; for (h && (t = s.domain) && t.exit(); r;) { n = r.fn, r = r.next; try { n() } catch (t) { throw r ? i() : e = void 0, t } } e = void 0, t && t.enter() }; if (h) i = function () { s.nextTick(t) }; else if (!a || c.navigator && c.navigator.standalone) if (l && l.resolve) { var n = l.resolve(void 0); i = function () { n.then(t) } } else i = function () { f.call(c, t) }; else { var o = !0, u = document.createTextNode(""); new a(t).observe(u, { characterData: !0 }), i = function () { u.data = o = !o } } return function (t) { var n = { fn: t, next: void 0 }; e && (e.next = n), r || (r = n, i()), e = n } } }, function (t, n, r) { "use strict"; function e(t) { var r, e; this.promise = new t(function (t, n) { if (void 0 !== r || void 0 !== e) throw TypeError("Bad Promise constructor"); r = t, e = n }), this.resolve = i(r), this.reject = i(e) } var i = r(21); t.exports.f = function (t) { return new e(t) } }, function (t, n, r) { "use strict"; var e, i, u = r(115), c = RegExp.prototype.exec, f = String.prototype.replace, o = c, a = "lastIndex", s = (e = /a/, i = /b*/g, c.call(e, "a"), c.call(i, "a"), 0 !== e[a] || 0 !== i[a]), l = void 0 !== /()??/.exec("")[1]; (s || l) && (o = function (t) { var n, r, e, i, o = this; return l && (r = new RegExp("^" + o.source + "$(?!\\s)", u.call(o))), s && (n = o[a]), e = c.call(o, t), s && e && (o[a] = o.global ? e.index + e[0].length : n), l && e && 1 < e.length && f.call(e[0], r, function () { for (i = 1; i < arguments.length - 2; i++)void 0 === arguments[i] && (e[i] = void 0) }), e }), t.exports = o }, function (t, n, i) { var r = i(5), e = i(2), o = function (t, n) { if (e(t), !r(n) && null !== n) throw TypeError(n + ": can't set as prototype!") }; t.exports = { set: Object.setPrototypeOf || ("__proto__" in {} ? function (t, r, e) { try { (e = i(47)(Function.call, i(31).f(Object.prototype, "__proto__").set, 2))(t, []), r = !(t instanceof Array) } catch (t) { r = !0 } return function (t, n) { return o(t, n), r ? t.__proto__ = n : e(t, n), t } }({}, !1) : void 0), check: o } }, function (t, n, r) { var e = r(118)("keys"), i = r(79); t.exports = function (t) { return e[t] || (e[t] = i(t)) } }, function (t, n, r) { var e = r(124), i = r(51); t.exports = function (t, n, r) { if (e(n)) throw TypeError("String#" + r + " doesn't accept regex!"); return String(i(t)) } }, function (t, n, r) { "use strict"; var i = r(49), o = r(51); t.exports = function (t) { var n = String(o(this)), r = "", e = i(t); if (e < 0 || e == 1 / 0) throw RangeError("Count can't be negative"); for (; 0 < e; (e >>>= 1) && (n += n))1 & e && (r += n); return r } }, function (t, n) { t.exports = "\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff" }, function (t, n, r) { var e, i, o, u = r(47), c = r(175), f = r(143), a = r(140), s = r(3), l = s.process, h = s.setImmediate, v = s.clearImmediate, p = s.MessageChannel, d = s.Dispatch, y = 0, g = {}, b = "onreadystatechange", x = function () { var t = +this; if (g.hasOwnProperty(t)) { var n = g[t]; delete g[t], n() } }, m = function (t) { x.call(t.data) }; h && v || (h = function (t) { for (var n = [], r = 1; arguments.length > r;)n.push(arguments[r++]); return g[++y] = function () { c("function" == typeof t ? t : Function(t), n) }, e(y), y }, v = function (t) { delete g[t] }, "process" == r(45)(l) ? e = function (t) { l.nextTick(u(x, t, 1)) } : d && d.now ? e = function (t) { d.now(u(x, t, 1)) } : p ? (o = (i = new p).port2, i.port1.onmessage = m, e = u(o.postMessage, o, 1)) : s.addEventListener && "function" == typeof postMessage && !s.importScripts ? (e = function (t) { s.postMessage(t + "", "*") }, s.addEventListener("message", m, !1)) : e = b in a("script") ? function (t) { f.appendChild(a("script"))[b] = function () { f.removeChild(this), x.call(t) } } : function (t) { setTimeout(u(x, t, 1), 0) }), t.exports = { set: h, clear: v } }, function (t, n, r) { "use strict"; function e(t, n, r) { var e, i, o, u = new Array(r), c = 8 * r - n - 1, f = (1 << c) - 1, a = f >> 1, s = 23 === n ? W(2, -24) - W(2, -77) : 0, l = 0, h = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0; for ((t = G(t)) != t || t === C ? (i = t != t ? 1 : 0, e = f) : (e = U(V(t) / B), t * (o = W(2, -e)) < 1 && (e--, o *= 2), 2 <= (t += 1 <= e + a ? s / o : s * W(2, 1 - a)) * o && (e++, o /= 2), f <= e + a ? (i = 0, e = f) : 1 <= e + a ? (i = (t * o - 1) * W(2, n), e += a) : (i = t * W(2, a - 1) * W(2, n), e = 0)); 8 <= n; u[l++] = 255 & i, i /= 256, n -= 8); for (e = e << n | i, c += n; 0 < c; u[l++] = 255 & e, e /= 256, c -= 8); return u[--l] |= 128 * h, u } function i(t, n, r) { var e, i = 8 * r - n - 1, o = (1 << i) - 1, u = o >> 1, c = i - 7, f = r - 1, a = t[f--], s = 127 & a; for (a >>= 7; 0 < c; s = 256 * s + t[f], f--, c -= 8); for (e = s & (1 << -c) - 1, s >>= -c, c += n; 0 < c; e = 256 * e + t[f], f--, c -= 8); if (0 === s) s = 1 - u; else { if (s === o) return e ? NaN : a ? -C : C; e += W(2, n), s -= u } return (a ? -1 : 1) * e * W(2, s - n) } function o(t) { return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0] } function u(t) { return [255 & t] } function c(t) { return [255 & t, t >> 8 & 255] } function f(t) { return [255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255] } function a(t) { return e(t, 52, 8) } function s(t) { return e(t, 23, 4) } function l(t, n, r) { M(t[I], n, { get: function () { return this[r] } }) } function h(t, n, r, e) { var i = O(+r); if (i + n > t[H]) throw R(L); var o = t[K]._b, u = i + t[J], c = o.slice(u, u + n); return e ? c : c.reverse() } function v(t, n, r, e, i, o) { var u = O(+r); if (u + n > t[H]) throw R(L); for (var c = t[K]._b, f = u + t[J], a = e(+i), s = 0; s < n; s++)c[f + s] = a[o ? s : n - s - 1] } var p = r(3), d = r(10), y = r(68), g = r(132), b = r(26), x = r(76), m = r(4), S = r(70), w = r(49), _ = r(8), O = r(194), E = r(73).f, M = r(11).f, P = r(137), j = r(83), F = "ArrayBuffer", A = "DataView", I = "prototype", L = "Wrong index!", N = p[F], T = p[A], k = p.Math, R = p.RangeError, C = p.Infinity, D = N, G = k.abs, W = k.pow, U = k.floor, V = k.log, B = k.LN2, q = "byteLength", z = "byteOffset", K = d ? "_b" : "buffer", H = d ? "_l" : q, J = d ? "_o" : z; if (g.ABV) { if (!m(function () { N(1) }) || !m(function () { new N(-1) }) || m(function () { return new N, new N(1.5), new N(NaN), N.name != F })) { for (var $, Y = (N = function (t) { return S(this, N), new D(O(t)) })[I] = D[I], X = E(D), Q = 0; X.length > Q;)($ = X[Q++]) in N || b(N, $, D[$]); y || (Y.constructor = N) } var Z = new T(new N(2)), tt = T[I].setInt8; Z.setInt8(0, 2147483648), Z.setInt8(1, 2147483649), !Z.getInt8(0) && Z.getInt8(1) || x(T[I], { setInt8: function (t, n) { tt.call(this, t, n << 24 >> 24) }, setUint8: function (t, n) { tt.call(this, t, n << 24 >> 24) } }, !0) } else N = function (t) { S(this, N, F); var n = O(t); this._b = P.call(new Array(n), 0), this[H] = n }, T = function (t, n, r) { S(this, T, A), S(t, N, A); var e = t[H], i = w(n); if (i < 0 || e < i) throw R("Wrong offset!"); if (e < i + (r = void 0 === r ? e - i : _(r))) throw R("Wrong length!"); this[K] = t, this[J] = i, this[H] = r }, d && (l(N, q, "_l"), l(T, "buffer", "_b"), l(T, q, "_l"), l(T, z, "_o")), x(T[I], { getInt8: function (t) { return h(this, 1, t)[0] << 24 >> 24 }, getUint8: function (t) { return h(this, 1, t)[0] }, getInt16: function (t) { var n = h(this, 2, t, arguments[1]); return (n[1] << 8 | n[0]) << 16 >> 16 }, getUint16: function (t) { var n = h(this, 2, t, arguments[1]); return n[1] << 8 | n[0] }, getInt32: function (t) { return o(h(this, 4, t, arguments[1])) }, getUint32: function (t) { return o(h(this, 4, t, arguments[1])) >>> 0 }, getFloat32: function (t) { return i(h(this, 4, t, arguments[1]), 23, 4) }, getFloat64: function (t) { return i(h(this, 8, t, arguments[1]), 52, 8) }, setInt8: function (t, n) { v(this, 1, t, u, n) }, setUint8: function (t, n) { v(this, 1, t, u, n) }, setInt16: function (t, n) { v(this, 2, t, c, n, arguments[2]) }, setUint16: function (t, n) { v(this, 2, t, c, n, arguments[2]) }, setInt32: function (t, n) { v(this, 4, t, f, n, arguments[2]) }, setUint32: function (t, n) { v(this, 4, t, f, n, arguments[2]) }, setFloat32: function (t, n) { v(this, 4, t, s, n, arguments[2]) }, setFloat64: function (t, n) { v(this, 8, t, a, n, arguments[2]) } }); j(N, F), j(T, A), b(T[I], g.VIEW, !0), n[F] = N, n[A] = T }, function (t, n, r) { var e = r(3), i = r(46), o = r(68), u = r(195), c = r(11).f; t.exports = function (t) { var n = i.Symbol || (i.Symbol = o ? {} : e.Symbol || {}); "_" == t.charAt(0) || t in n || c(n, t, { value: u.f(t) }) } }, function (t, n, r) { var e = r(81), i = r(7)("iterator"), o = r(82); t.exports = r(46).getIteratorMethod = function (t) { if (null != t) return t[i] || t["@@iterator"] || o[e(t)] } }, function (t, n, r) { "use strict"; var e = r(67), i = r(178), o = r(82), u = r(33); t.exports = r(147)(Array, "Array", function (t, n) { this._t = u(t), this._i = 0, this._k = n }, function () { var t = this._t, n = this._k, r = this._i++; return !t || r >= t.length ? (this._t = void 0, i(1)) : i(0, "keys" == n ? r : "values" == n ? t[r] : [r, t[r]]) }, "values"), o.Arguments = o.Array, e("keys"), e("values"), e("entries") }, function (t, n) { t.exports = function (t, n) { t.classList ? t.classList.add(n) : t.className += " " + n } }, function (t, n) { t.exports = function (t, n) { if (t.classList) t.classList.remove(n); else { var r = new RegExp("(^|\\b)" + n.split(" ").join("|") + "(\\b|$)", "gi"); t.className = t.className.replace(r, " ") } } }, function (t, n, r) { var e = r(45); t.exports = function (t, n) { if ("number" != typeof t && "Number" != e(t)) throw TypeError(n); return +t } }, function (t, n, r) { "use strict"; var a = r(17), s = r(78), l = r(8); t.exports = [].copyWithin || function (t, n) { var r = a(this), e = l(r.length), i = s(t, e), o = s(n, e), u = 2 < arguments.length ? arguments[2] : void 0, c = Math.min((void 0 === u ? e : s(u, e)) - o, e - i), f = 1; for (o < i && i < o + c && (f = -1, o += c - 1, i += c - 1); 0 < c--;)o in r ? r[i] = r[o] : delete r[i], i += f, o += f; return r } }, function (t, n, r) { var e = r(71); t.exports = function (t, n) { var r = []; return e(t, !1, r.push, r, n), r } }, function (t, n, r) { var s = r(21), l = r(17), h = r(116), v = r(8); t.exports = function (t, n, r, e, i) { s(n); var o = l(t), u = h(o), c = v(o.length), f = i ? c - 1 : 0, a = i ? -1 : 1; if (r < 2) for (; ;) { if (f in u) { e = u[f], f += a; break } if (f += a, i ? f < 0 : c <= f) throw TypeError("Reduce of empty array with no initial value") } for (; i ? 0 <= f : f < c; f += a)f in u && (e = n(e, u[f], f, o)); return e } }, function (t, n, r) { "use strict"; var o = r(21), u = r(5), c = r(175), f = [].slice, a = {}; t.exports = Function.bind || function (n) { var r = o(this), e = f.call(arguments, 1), i = function () { var t = e.concat(f.call(arguments)); return this instanceof i ? function (t, n, r) { if (!(n in a)) { for (var e = [], i = 0; i < n; i++)e[i] = "a[" + i + "]"; a[n] = Function("F,a", "return new F(" + e.join(",") + ")") } return a[n](t, r) }(r, t.length, t) : c(r, t, n) }; return u(r.prototype) && (i.prototype = r.prototype), i } }, function (t, n, r) { "use strict"; var u = r(11).f, c = r(72), f = r(76), a = r(47), s = r(70), l = r(71), e = r(147), i = r(178), o = r(77), h = r(10), v = r(69).fastKey, p = r(80), d = h ? "_s" : "size", y = function (t, n) { var r, e = v(n); if ("F" !== e) return t._i[e]; for (r = t._f; r; r = r.n)if (r.k == n) return r }; t.exports = { getConstructor: function (t, o, r, e) { var i = t(function (t, n) { s(t, i, o, "_i"), t._t = o, t._i = c(null), t._f = void 0, t._l = void 0, t[d] = 0, null != n && l(n, r, t[e], t) }); return f(i.prototype, { clear: function () { for (var t = p(this, o), n = t._i, r = t._f; r; r = r.n)r.r = !0, r.p && (r.p = r.p.n = void 0), delete n[r.i]; t._f = t._l = void 0, t[d] = 0 }, delete: function (t) { var n = p(this, o), r = y(n, t); if (r) { var e = r.n, i = r.p; delete n._i[r.i], r.r = !0, i && (i.n = e), e && (e.p = i), n._f == r && (n._f = e), n._l == r && (n._l = i), n[d]-- } return !!r }, forEach: function (t) { p(this, o); for (var n, r = a(t, 1 < arguments.length ? arguments[1] : void 0, 3); n = n ? n.n : this._f;)for (r(n.v, n.k, this); n && n.r;)n = n.p }, has: function (t) { return !!y(p(this, o), t) } }), h && u(i.prototype, "size", { get: function () { return p(this, o)[d] } }), i }, def: function (t, n, r) { var e, i, o = y(t, n); return o ? o.v = r : (t._l = o = { i: i = v(n, !0), k: n, v: r, p: e = t._l, n: void 0, r: !1 }, t._f || (t._f = o), e && (e.n = o), t[d]++, "F" !== i && (t._i[i] = o)), t }, getEntry: y, setStrong: function (t, r, n) { e(t, r, function (t, n) { this._t = p(t, r), this._k = n, this._l = void 0 }, function () { for (var t = this, n = t._k, r = t._l; r && r.r;)r = r.p; return t._t && (t._l = r = r ? r.n : t._t._f) ? i(0, "keys" == n ? r.k : "values" == n ? r.v : [r.k, r.v]) : (t._t = void 0, i(1)) }, n ? "entries" : "values", !n, !0), o(r) } } }, function (t, n, r) { var e = r(81), i = r(167); t.exports = function (t) { return function () { if (e(this) != t) throw TypeError(t + "#toJSON isn't generic"); return i(this) } } }, function (t, n, r) { "use strict"; var u = r(76), c = r(69).getWeak, i = r(2), f = r(5), a = r(70), s = r(71), e = r(50), l = r(30), h = r(80), o = e(5), v = e(6), p = 0, d = function (t) { return t._l || (t._l = new y) }, y = function () { this.a = [] }, g = function (t, n) { return o(t.a, function (t) { return t[0] === n }) }; y.prototype = { get: function (t) { var n = g(this, t); if (n) return n[1] }, has: function (t) { return !!g(this, t) }, set: function (t, n) { var r = g(this, t); r ? r[1] = n : this.a.push([t, n]) }, delete: function (n) { var t = v(this.a, function (t) { return t[0] === n }); return ~t && this.a.splice(t, 1), !!~t } }, t.exports = { getConstructor: function (t, r, e, i) { var o = t(function (t, n) { a(t, o, r, "_i"), t._t = r, t._i = p++, t._l = void 0, null != n && s(n, e, t[i], t) }); return u(o.prototype, { delete: function (t) { if (!f(t)) return !1; var n = c(t); return !0 === n ? d(h(this, r)).delete(t) : n && l(n, this._i) && delete n[this._i] }, has: function (t) { if (!f(t)) return !1; var n = c(t); return !0 === n ? d(h(this, r)).has(t) : n && l(n, this._i) } }), o }, def: function (t, n, r) { var e = c(i(n), !0); return !0 === e ? d(t).set(n, r) : e[t._i] = r, t }, ufstore: d } }, function (t, n, r) { "use strict"; var p = r(123), d = r(5), y = r(8), g = r(47), b = r(7)("isConcatSpreadable"); t.exports = function t(n, r, e, i, o, u, c, f) { for (var a, s, l = o, h = 0, v = !!c && g(c, f, 3); h < i;) { if (h in e) { if (a = v ? v(e[h], h, r) : e[h], s = !1, d(a) && (s = void 0 !== (s = a[b]) ? !!s : p(a)), s && 0 < u) l = t(n, r, a, y(a.length), l, u - 1) - 1; else { if (9007199254740991 <= l) throw TypeError(); n[l] = a } l++ } h++ } return l } }, function (t, n, r) { t.exports = !r(10) && !r(4)(function () { return 7 != Object.defineProperty(r(140)("div"), "a", { get: function () { return 7 } }).a }) }, function (t, n) { t.exports = function (t, n, r) { var e = void 0 === r; switch (n.length) { case 0: return e ? t() : t.call(r); case 1: return e ? t(n[0]) : t.call(r, n[0]); case 2: return e ? t(n[0], n[1]) : t.call(r, n[0], n[1]); case 3: return e ? t(n[0], n[1], n[2]) : t.call(r, n[0], n[1], n[2]); case 4: return e ? t(n[0], n[1], n[2], n[3]) : t.call(r, n[0], n[1], n[2], n[3]) }return t.apply(r, n) } }, function (t, n, r) { var e = r(5), i = Math.floor; t.exports = function (t) { return !e(t) && isFinite(t) && i(t) === t } }, function (t, n, r) { var o = r(2); t.exports = function (t, n, r, e) { try { return e ? n(o(r)[0], r[1]) : n(r) } catch (n) { var i = t.return; throw void 0 !== i && o(i.call(t)), n } } }, function (t, n) { t.exports = function (t, n) { return { value: n, done: !!t } } }, function (t, n, r) { var o = r(149), e = Math.pow, u = e(2, -52), c = e(2, -23), f = e(2, 127) * (2 - c), a = e(2, -126); t.exports = Math.fround || function (t) { var n, r, e = Math.abs(t), i = o(t); return e < a ? i * (e / a / c + 1 / u - 1 / u) * a * c : f < (r = (n = (1 + c / u) * e) - (n - e)) || r != r ? i * (1 / 0) : i * r } }, function (t, n) { t.exports = Math.log1p || function (t) { return -1e-8 < (t = +t) && t < 1e-8 ? t - t * t / 2 : Math.log(1 + t) } }, function (t, n) { t.exports = Math.scale || function (t, n, r, e, i) { return 0 === arguments.length || t != t || n != n || r != r || e != e || i != i ? NaN : t === 1 / 0 || t === -1 / 0 ? t : (t - n) * (i - e) / (r - n) + e } }, function (t, n, r) { "use strict"; var h = r(10), v = r(74), p = r(127), d = r(117), y = r(17), g = r(116), i = Object.assign; t.exports = !i || r(4)(function () { var t = {}, n = {}, r = Symbol(), e = "abcdefghijklmnopqrst"; return t[r] = 7, e.split("").forEach(function (t) { n[t] = t }), 7 != i({}, t)[r] || Object.keys(i({}, n)).join("") != e }) ? function (t, n) { for (var r = y(t), e = arguments.length, i = 1, o = p.f, u = d.f; i < e;)for (var c, f = g(arguments[i++]), a = o ? v(f).concat(o(f)) : v(f), s = a.length, l = 0; l < s;)c = a[l++], h && !u.call(f, c) || (r[c] = f[c]); return r } : i }, function (t, n, r) { var u = r(11), c = r(2), f = r(74); t.exports = r(10) ? Object.defineProperties : function (t, n) { c(t); for (var r, e = f(n), i = e.length, o = 0; o < i;)u.f(t, r = e[o++], n[r]); return t } }, function (t, n, r) { var e = r(33), i = r(73).f, o = {}.toString, u = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []; t.exports.f = function (t) { return u && "[object Window]" == o.call(t) ? function (t) { try { return i(t) } catch (t) { return u.slice() } }(t) : i(e(t)) } }, function (t, n, r) { var u = r(30), c = r(33), f = r(120)(!1), a = r(154)("IE_PROTO"); t.exports = function (t, n) { var r, e = c(t), i = 0, o = []; for (r in e) r != a && u(e, r) && o.push(r); for (; n.length > i;)u(e, r = n[i++]) && (~f(o, r) || o.push(r)); return o } }, function (t, n, r) { var f = r(10), a = r(74), s = r(33), l = r(117).f; t.exports = function (c) { return function (t) { for (var n, r = s(t), e = a(r), i = e.length, o = 0, u = []; o < i;)n = e[o++], f && !l.call(r, n) || u.push(c ? [n, r[n]] : r[n]); return u } } }, function (t, n, r) { var e = r(73), i = r(127), o = r(2), u = r(3).Reflect; t.exports = u && u.ownKeys || function (t) { var n = e.f(o(t)), r = i.f; return r ? n.concat(r(t)) : n } }, function (t, n, r) { var e = r(3).parseFloat, i = r(84).trim; t.exports = 1 / e(r(157) + "-0") != -1 / 0 ? function (t) { var n = i(String(t), 3), r = e(n); return 0 === r && "-" == n.charAt(0) ? -0 : r } : e }, function (t, n, r) { var e = r(3).parseInt, i = r(84).trim, o = r(157), u = /^[-+]?0[xX]/; t.exports = 8 !== e(o + "08") || 22 !== e(o + "0x16") ? function (t, n) { var r = i(String(t), 3); return e(r, n >>> 0 || (u.test(r) ? 16 : 10)) } : e }, function (t, n) { t.exports = function (t) { try { return { e: !1, v: t() } } catch (t) { return { e: !0, v: t } } } }, function (t, n, r) { var e = r(2), i = r(5), o = r(151); t.exports = function (t, n) { if (e(t), i(n) && n.constructor === t) return n; var r = o.f(t); return (0, r.resolve)(n), r.promise } }, function (t, n) { t.exports = Object.is || function (t, n) { return t === n ? 0 !== t || 1 / t == 1 / n : t != t && n != n } }, function (t, n, r) { var s = r(8), l = r(156), h = r(51); t.exports = function (t, n, r, e) { var i = String(h(t)), o = i.length, u = void 0 === r ? " " : String(r), c = s(n); if (c <= o || "" == u) return i; var f = c - o, a = l.call(u, Math.ceil(f / u.length)); return a.length > f && (a = a.slice(0, f)), e ? a + i : i + a } }, function (t, n, r) { var e = r(49), i = r(8); t.exports = function (t) { if (void 0 === t) return 0; var n = e(t), r = i(n); if (n !== r) throw RangeError("Wrong length!"); return r } }, function (t, n, r) { n.f = r(7) }, function (t, n, r) { "use strict"; var e = r(170), i = r(80); t.exports = r(121)("Map", function (t) { return function () { return t(this, 0 < arguments.length ? arguments[0] : void 0) } }, { get: function (t) { var n = e.getEntry(i(this, "Map"), t); return n && n.v }, set: function (t, n) { return e.def(i(this, "Map"), 0 === t ? 0 : t, n) } }, e, !0) }, function (t, n, r) { "use strict"; var e = r(152); r(1)({ target: "RegExp", proto: !0, forced: e !== /./.exec }, { exec: e }) }, function (t, n, r) { r(10) && "g" != /./g.flags && r(11).f(RegExp.prototype, "flags", { configurable: !0, get: r(115) }) }, function (t, n, r) { "use strict"; var e = r(170), i = r(80); t.exports = r(121)("Set", function (t) { return function () { return t(this, 0 < arguments.length ? arguments[0] : void 0) } }, { add: function (t) { return e.def(i(this, "Set"), t = 0 === t ? 0 : t, t) } }, e) }, function (t, n, r) { "use strict"; var o, e = r(3), i = r(50)(0), u = r(27), c = r(69), f = r(182), a = r(172), s = r(5), l = r(80), h = r(80), v = !e.ActiveXObject && "ActiveXObject" in e, p = "WeakMap", d = c.getWeak, y = Object.isExtensible, g = a.ufstore, b = function (t) { return function () { return t(this, 0 < arguments.length ? arguments[0] : void 0) } }, x = { get: function (t) { if (s(t)) { var n = d(t); return !0 === n ? g(l(this, p)).get(t) : n ? n[this._i] : void 0 } }, set: function (t, n) { return a.def(l(this, p), t, n) } }, m = t.exports = r(121)(p, b, x, a, !0, !0); h && v && (f((o = a.getConstructor(b, p)).prototype, x), c.NEED = !0, i(["delete", "has", "get", "set"], function (e) { var t = m.prototype, i = t[e]; u(t, e, function (t, n) { if (!s(t) || y(t)) return i.call(this, t, n); this._f || (this._f = new o); var r = this._f[e](t, n); return "set" == e ? this : r }) })) }, , , , function (t, n) { "use strict"; t.exports = { init: function () { var t = document.querySelector("#page-nav"); t && !document.querySelector("#page-nav .extend.prev") && (t.innerHTML = '<a class="extend prev disabled" rel="prev">上一页</a>' + t.innerHTML), t && !document.querySelector("#page-nav .extend.next") && (t.innerHTML = t.innerHTML + '<a class="extend next disabled" rel="next">下一页</a>'), yiliaConfig && yiliaConfig.open_in_new && document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function (t) { var n = t.getAttribute("target"); n && "" !== n || t.setAttribute("target", "_blank") }), yiliaConfig && yiliaConfig.toc_hide_index && document.querySelectorAll(".toc-number").forEach(function (t) { t.style.display = "none" }) } } }, function (t, n, r) { "use strict"; function e(t) { return t && t.__esModule ? t : { default: t } } function i(t, n, r, e, i) { var o = function (t) { for (var n = t.offsetLeft, r = t.offsetParent; null !== r;)n += r.offsetLeft, r = r.offsetParent; return n }(t), u = function (t) { for (var n = t.offsetTop, r = t.offsetParent; null !== r;)n += r.offsetTop, r = r.offsetParent; return n }(t) - n; if (u - r <= i) { var c = t.$newDom; c || (c = t.cloneNode(!0), (0, a.default)(t, c), (t.$newDom = c).style.position = "fixed", c.style.top = (r || u) + "px", c.style.left = o + "px", c.style.zIndex = e || 2, c.style.width = "100%", c.style.color = "#fff"), c.style.visibility = "visible", t.style.visibility = "hidden" } else { t.style.visibility = "visible"; var f = t.$newDom; f && (f.style.visibility = "hidden") } } function o() { var t = document.querySelector(".js-overlay"), n = document.querySelector(".js-header-menu"); i(t, document.body.scrollTop, -63, 2, 0), i(n, document.body.scrollTop, 1, 3, 0) } var f = e(r(163)), a = e((e(r(164)), r(414))), u = e(r(134)), c = e(r(204)), s = r(135); u.default.versions.mobile && window.screen.width < 800 && (function () { for (var t = document.querySelectorAll(".js-header-menu li a"), n = window.location.pathname, r = 0, e = t.length; r < e; r++) { var i = t[r]; o = n, u = i.getAttribute("href"), c = /\/|index.html/g, o.replace(c, "") === u.replace(c, "") && (0, f.default)(i, "active") } var o, u, c }(), document.querySelector("#container").addEventListener("scroll", function (t) { o() }), window.addEventListener("scroll", function (t) { o() }), o()), (0, s.addLoadEvent)(function () { c.default.init() }), t.exports = {} }, , , function (t, n, r) { (function (t) { "use strict"; function n(t, n, r) { t[n] || Object.defineProperty(t, n, { writable: !0, configurable: !0, value: r }) } if (r(413), r(209), r(211), t._babelPolyfill) throw new Error("only one instance of babel-polyfill is allowed"); t._babelPolyfill = !0; n(String.prototype, "padLeft", "".padStart), n(String.prototype, "padRight", "".padEnd), "pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (t) { [][t] && n(Array, t, Function.call.bind([][t])) }) }).call(n, function () { return this }()) }, function (L, t) { (function (t) { !function (t) { "use strict"; function o(t, n, r, e) { var o, u, c, f, i = n && n.prototype instanceof h ? n : h, a = Object.create(i.prototype), s = new p(e || []); return a._invoke = (o = t, u = r, c = s, f = _, function (t, n) { if (f === E) throw new Error("Generator is already running"); if (f === M) { if ("throw" === t) throw n; return d() } for (c.method = t, c.arg = n; ;) { var r = c.delegate; if (r) { var e = v(r, c); if (e) { if (e === P) continue; return e } } if ("next" === c.method) c.sent = c._sent = c.arg; else if ("throw" === c.method) { if (f === _) throw f = M, c.arg; c.dispatchException(c.arg) } else "return" === c.method && c.abrupt("return", c.arg); f = E; var i = l(o, u, c); if ("normal" === i.type) { if (f = c.done ? M : O, i.arg === P) continue; return { value: i.arg, done: c.done } } "throw" === i.type && (f = M, c.method = "throw", c.arg = i.arg) } }), a } function l(t, n, r) { try { return { type: "normal", arg: t.call(n, r) } } catch (t) { return { type: "throw", arg: t } } } function h() { } function r() { } function n() { } function e(t) { ["next", "throw", "return"].forEach(function (n) { t[n] = function (t) { return this._invoke(n, t) } }) } function u(c) { function f(t, n, r, e) { var i = l(c[t], c, n); if ("throw" !== i.type) { var o = i.arg, u = o.value; return u && "object" == typeof u && y.call(u, "__await") ? Promise.resolve(u.__await).then(function (t) { f("next", t, r, e) }, function (t) { f("throw", t, r, e) }) : Promise.resolve(u).then(function (t) { o.value = t, r(o) }, e) } e(i.arg) } var n; "object" == typeof t.process && t.process.domain && (f = t.process.domain.bind(f)), this._invoke = function (r, e) { function t() { return new Promise(function (t, n) { f(r, e, t, n) }) } return n = n ? n.then(t, t) : t() } } function v(t, n) { var r = t.iterator[n.method]; if (r === a) { if (n.delegate = null, "throw" === n.method) { if (t.iterator.return && (n.method = "return", n.arg = a, v(t, n), "throw" === n.method)) return P; n.method = "throw", n.arg = new TypeError("The iterator does not provide a 'throw' method") } return P } var e = l(r, t.iterator, n.arg); if ("throw" === e.type) return n.method = "throw", n.arg = e.arg, n.delegate = null, P; var i = e.arg; return i ? i.done ? (n[t.resultName] = i.value, n.next = t.nextLoc, "return" !== n.method && (n.method = "next", n.arg = a), n.delegate = null, P) : i : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, P) } function i(t) { var n = { tryLoc: t[0] }; 1 in t && (n.catchLoc = t[1]), 2 in t && (n.finallyLoc = t[2], n.afterLoc = t[3]), this.tryEntries.push(n) } function c(t) { var n = t.completion || {}; n.type = "normal", delete n.arg, t.completion = n } function p(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(i, this), this.reset(!0) } function f(n) { if (n) { var t = n[b]; if (t) return t.call(n); if ("function" == typeof n.next) return n; if (!isNaN(n.length)) { var r = -1, e = function t() { for (; ++r < n.length;)if (y.call(n, r)) return t.value = n[r], t.done = !1, t; return t.value = a, t.done = !0, t }; return e.next = e } } return { next: d } } function d() { return { value: a, done: !0 } } var a, s = Object.prototype, y = s.hasOwnProperty, g = "function" == typeof Symbol ? Symbol : {}, b = g.iterator || "@@iterator", x = g.asyncIterator || "@@asyncIterator", m = g.toStringTag || "@@toStringTag", S = "object" == typeof L, w = t.regeneratorRuntime; if (w) S && (L.exports = w); else { (w = t.regeneratorRuntime = S ? L.exports : {}).wrap = o; var _ = "suspendedStart", O = "suspendedYield", E = "executing", M = "completed", P = {}, j = {}; j[b] = function () { return this }; var F = Object.getPrototypeOf, A = F && F(F(f([]))); A && A !== s && y.call(A, b) && (j = A); var I = n.prototype = h.prototype = Object.create(j); r.prototype = I.constructor = n, n.constructor = r, n[m] = r.displayName = "GeneratorFunction", w.isGeneratorFunction = function (t) { var n = "function" == typeof t && t.constructor; return !!n && (n === r || "GeneratorFunction" === (n.displayName || n.name)) }, w.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, n) : (t.__proto__ = n, m in t || (t[m] = "GeneratorFunction")), t.prototype = Object.create(I), t }, w.awrap = function (t) { return { __await: t } }, e(u.prototype), u.prototype[x] = function () { return this }, w.AsyncIterator = u, w.async = function (t, n, r, e) { var i = new u(o(t, n, r, e)); return w.isGeneratorFunction(n) ? i : i.next().then(function (t) { return t.done ? t.value : i.next() }) }, e(I), I[m] = "Generator", I[b] = function () { return this }, I.toString = function () { return "[object Generator]" }, w.keys = function (r) { var e = []; for (var t in r) e.push(t); return e.reverse(), function t() { for (; e.length;) { var n = e.pop(); if (n in r) return t.value = n, t.done = !1, t } return t.done = !0, t } }, w.values = f, p.prototype = { constructor: p, reset: function (t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = a, this.done = !1, this.delegate = null, this.method = "next", this.arg = a, this.tryEntries.forEach(c), !t) for (var n in this) "t" === n.charAt(0) && y.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = a) }, stop: function () { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval }, dispatchException: function (r) { function t(t, n) { return o.type = "throw", o.arg = r, e.next = t, n && (e.method = "next", e.arg = a), !!n } if (this.done) throw r; for (var e = this, n = this.tryEntries.length - 1; 0 <= n; --n) { var i = this.tryEntries[n], o = i.completion; if ("root" === i.tryLoc) return t("end"); if (i.tryLoc <= this.prev) { var u = y.call(i, "catchLoc"), c = y.call(i, "finallyLoc"); if (u && c) { if (this.prev < i.catchLoc) return t(i.catchLoc, !0); if (this.prev < i.finallyLoc) return t(i.finallyLoc) } else if (u) { if (this.prev < i.catchLoc) return t(i.catchLoc, !0) } else { if (!c) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return t(i.finallyLoc) } } } }, abrupt: function (t, n) { for (var r = this.tryEntries.length - 1; 0 <= r; --r) { var e = this.tryEntries[r]; if (e.tryLoc <= this.prev && y.call(e, "finallyLoc") && this.prev < e.finallyLoc) { var i = e; break } } i && ("break" === t || "continue" === t) && i.tryLoc <= n && n <= i.finallyLoc && (i = null); var o = i ? i.completion : {}; return o.type = t, o.arg = n, i ? (this.method = "next", this.next = i.finallyLoc, P) : this.complete(o) }, complete: function (t, n) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && n && (this.next = n), P }, finish: function (t) { for (var n = this.tryEntries.length - 1; 0 <= n; --n) { var r = this.tryEntries[n]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), c(r), P } }, catch: function (t) { for (var n = this.tryEntries.length - 1; 0 <= n; --n) { var r = this.tryEntries[n]; if (r.tryLoc === t) { var e = r.completion; if ("throw" === e.type) { var i = e.arg; c(r) } return i } } throw new Error("illegal catch attempt") }, delegateYield: function (t, n, r) { return this.delegate = { iterator: f(t), resultName: n, nextLoc: r }, "next" === this.method && (this.arg = a), P } } } }("object" == typeof t ? t : "object" == typeof window ? window : "object" == typeof self ? self : this) }).call(t, function () { return this }()) }, , function (t, n, r) { r(221), t.exports = r(46).RegExp.escape }, , , , function (t, n, r) { var e = r(5), i = r(123), o = r(7)("species"); t.exports = function (t) { var n; return i(t) && ("function" != typeof (n = t.constructor) || n !== Array && !i(n.prototype) || (n = void 0), e(n) && (null === (n = n[o]) && (n = void 0))), void 0 === n ? Array : n } }, function (t, n, r) { "use strict"; var e = r(4), i = Date.prototype.getTime, o = Date.prototype.toISOString, u = function (t) { return 9 < t ? t : "0" + t }; t.exports = e(function () { return "0385-07-25T07:06:39.999Z" != o.call(new Date(-5e13 - 1)) }) || !e(function () { o.call(new Date(NaN)) }) ? function () { if (!isFinite(i.call(this))) throw RangeError("Invalid time value"); var t = this, n = t.getUTCFullYear(), r = t.getUTCMilliseconds(), e = n < 0 ? "-" : 9999 < n ? "+" : ""; return e + ("00000" + Math.abs(n)).slice(e ? -6 : -4) + "-" + u(t.getUTCMonth() + 1) + "-" + u(t.getUTCDate()) + "T" + u(t.getUTCHours()) + ":" + u(t.getUTCMinutes()) + ":" + u(t.getUTCSeconds()) + "." + (99 < r ? r : "0" + u(r)) + "Z" } : o }, function (t, n, r) { "use strict"; var e = r(2), i = r(53); t.exports = function (t) { if ("string" !== t && "number" !== t && "default" !== t) throw TypeError("Incorrect hint"); return i(e(this), "number" != t) } }, function (t, n, r) { var c = r(74), f = r(127), a = r(117); t.exports = function (t) { var n = c(t), r = f.f; if (r) for (var e, i = r(t), o = a.f, u = 0; i.length > u;)o.call(t, e = i[u++]) && n.push(e); return n } }, function (t, n, r) { t.exports = r(118)("native-function-to-string", Function.toString) }, function (t, n) { t.exports = function (n, r) { var e = r === Object(r) ? function (t) { return r[t] } : r; return function (t) { return String(t).replace(n, e) } } }, function (t, n, r) { var e = r(1), i = r(220)(/[\\^$*+?.()|[\]{}]/g, "\\$&"); e(e.S, "RegExp", { escape: function (t) { return i(t) } }) }, function (t, n, r) { var e = r(1); e(e.P, "Array", { copyWithin: r(166) }), r(67)("copyWithin") }, function (t, n, r) { "use strict"; var e = r(1), i = r(50)(4); e(e.P + e.F * !r(48)([].every, !0), "Array", { every: function (t) { return i(this, t, arguments[1]) } }) }, function (t, n, r) { var e = r(1); e(e.P, "Array", { fill: r(137) }), r(67)("fill") }, function (t, n, r) { "use strict"; var e = r(1), i = r(50)(2); e(e.P + e.F * !r(48)([].filter, !0), "Array", { filter: function (t) { return i(this, t, arguments[1]) } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(50)(6), o = "findIndex", u = !0; o in [] && Array(1)[o](function () { u = !1 }), e(e.P + e.F * u, "Array", { findIndex: function (t) { return i(this, t, 1 < arguments.length ? arguments[1] : void 0) } }), r(67)(o) }, function (t, n, r) { "use strict"; var e = r(1), i = r(50)(5), o = "find", u = !0; o in [] && Array(1)[o](function () { u = !1 }), e(e.P + e.F * u, "Array", { find: function (t) { return i(this, t, 1 < arguments.length ? arguments[1] : void 0) } }), r(67)(o) }, function (t, n, r) { "use strict"; var e = r(1), i = r(50)(0), o = r(48)([].forEach, !0); e(e.P + e.F * !o, "Array", { forEach: function (t) { return i(this, t, arguments[1]) } }) }, function (t, n, r) { "use strict"; var h = r(47), e = r(1), v = r(17), p = r(177), d = r(145), y = r(8), g = r(139), b = r(161); e(e.S + e.F * !r(125)(function (t) { Array.from(t) }), "Array", { from: function (t) { var n, r, e, i, o = v(t), u = "function" == typeof this ? this : Array, c = arguments.length, f = 1 < c ? arguments[1] : void 0, a = void 0 !== f, s = 0, l = b(o); if (a && (f = h(f, 2 < c ? arguments[2] : void 0, 2)), null == l || u == Array && d(l)) for (r = new u(n = y(o.length)); s < n; s++)g(r, s, a ? f(o[s], s) : o[s]); else for (i = l.call(o), r = new u; !(e = i.next()).done; s++)g(r, s, a ? p(i, f, [e.value, s], !0) : e.value); return r.length = s, r } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(120)(!1), o = [].indexOf, u = !!o && 1 / [1].indexOf(1, -0) < 0; e(e.P + e.F * (u || !r(48)(o)), "Array", { indexOf: function (t) { return u ? o.apply(this, arguments) || 0 : i(this, t, arguments[1]) } }) }, function (t, n, r) { var e = r(1); e(e.S, "Array", { isArray: r(123) }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(33), o = [].join; e(e.P + e.F * (r(116) != Object || !r(48)(o)), "Array", { join: function (t) { return o.call(i(this), void 0 === t ? "," : t) } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(33), o = r(49), u = r(8), c = [].lastIndexOf, f = !!c && 1 / [1].lastIndexOf(1, -0) < 0; e(e.P + e.F * (f || !r(48)(c)), "Array", { lastIndexOf: function (t) { if (f) return c.apply(this, arguments) || 0; var n = i(this), r = u(n.length), e = r - 1; for (1 < arguments.length && (e = Math.min(e, o(arguments[1]))), e < 0 && (e = r + e); 0 <= e; e--)if (e in n && n[e] === t) return e || 0; return -1 } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(50)(1); e(e.P + e.F * !r(48)([].map, !0), "Array", { map: function (t) { return i(this, t, arguments[1]) } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(139); e(e.S + e.F * r(4)(function () { function t() { } return !(Array.of.call(t) instanceof t) }), "Array", { of: function () { for (var t = 0, n = arguments.length, r = new ("function" == typeof this ? this : Array)(n); t < n;)i(r, t, arguments[t++]); return r.length = n, r } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(168); e(e.P + e.F * !r(48)([].reduceRight, !0), "Array", { reduceRight: function (t) { return i(this, t, arguments.length, arguments[1], !0) } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(168); e(e.P + e.F * !r(48)([].reduce, !0), "Array", { reduce: function (t) { return i(this, t, arguments.length, arguments[1], !1) } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(143), a = r(45), s = r(78), l = r(8), h = [].slice; e(e.P + e.F * r(4)(function () { i && h.call(i) }), "Array", { slice: function (t, n) { var r = l(this.length), e = a(this); if (n = void 0 === n ? r : n, "Array" == e) return h.call(this, t, n); for (var i = s(t, r), o = s(n, r), u = l(o - i), c = new Array(u), f = 0; f < u; f++)c[f] = "String" == e ? this.charAt(i + f) : this[i + f]; return c } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(50)(3); e(e.P + e.F * !r(48)([].some, !0), "Array", { some: function (t) { return i(this, t, arguments[1]) } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(21), o = r(17), u = r(4), c = [].sort, f = [1, 2, 3]; e(e.P + e.F * (u(function () { f.sort(void 0) }) || !u(function () { f.sort(null) }) || !r(48)(c)), "Array", { sort: function (t) { return void 0 === t ? c.call(o(this)) : c.call(o(this), i(t)) } }) }, function (t, n, r) { r(77)("Array") }, function (t, n, r) { var e = r(1); e(e.S, "Date", { now: function () { return (new Date).getTime() } }) }, function (t, n, r) { var e = r(1), i = r(216); e(e.P + e.F * (Date.prototype.toISOString !== i), "Date", { toISOString: i }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(17), o = r(53); e(e.P + e.F * r(4)(function () { return null !== new Date(NaN).toJSON() || 1 !== Date.prototype.toJSON.call({ toISOString: function () { return 1 } }) }), "Date", { toJSON: function (t) { var n = i(this), r = o(n); return "number" != typeof r || isFinite(r) ? n.toISOString() : null } }) }, function (t, n, r) { var e = r(7)("toPrimitive"), i = Date.prototype; e in i || r(26)(i, e, r(217)) }, function (t, n, r) { var e = Date.prototype, i = "Invalid Date", o = "toString", u = e[o], c = e.getTime; new Date(NaN) + "" != i && r(27)(e, o, function () { var t = c.call(this); return t == t ? u.call(this) : i }) }, function (t, n, r) { var e = r(1); e(e.P, "Function", { bind: r(169) }) }, function (t, n, r) { "use strict"; var e = r(5), i = r(32), o = r(7)("hasInstance"), u = Function.prototype; o in u || r(11).f(u, o, { value: function (t) { if ("function" != typeof this || !e(t)) return !1; if (!e(this.prototype)) return t instanceof this; for (; t = i(t);)if (this.prototype === t) return !0; return !1 } }) }, function (t, n, r) { var e = r(11).f, i = Function.prototype, o = /^\s*function ([^ (]*)/; "name" in i || r(10) && e(i, "name", { configurable: !0, get: function () { try { return ("" + this).match(o)[1] } catch (t) { return "" } } }) }, function (t, n, r) { var e = r(1), i = r(180), o = Math.sqrt, u = Math.acosh; e(e.S + e.F * !(u && 710 == Math.floor(u(Number.MAX_VALUE)) && u(1 / 0) == 1 / 0), "Math", { acosh: function (t) { return (t = +t) < 1 ? NaN : 94906265.62425156 < t ? Math.log(t) + Math.LN2 : i(t - 1 + o(t - 1) * o(t + 1)) } }) }, function (t, n, r) { var e = r(1), i = Math.asinh; e(e.S + e.F * !(i && 0 < 1 / i(0)), "Math", { asinh: function t(n) { return isFinite(n = +n) && 0 != n ? n < 0 ? -t(-n) : Math.log(n + Math.sqrt(n * n + 1)) : n } }) }, function (t, n, r) { var e = r(1), i = Math.atanh; e(e.S + e.F * !(i && 1 / i(-0) < 0), "Math", { atanh: function (t) { return 0 == (t = +t) ? t : Math.log((1 + t) / (1 - t)) / 2 } }) }, function (t, n, r) { var e = r(1), i = r(149); e(e.S, "Math", { cbrt: function (t) { return i(t = +t) * Math.pow(Math.abs(t), 1 / 3) } }) }, function (t, n, r) { var e = r(1); e(e.S, "Math", { clz32: function (t) { return (t >>>= 0) ? 31 - Math.floor(Math.log(t + .5) * Math.LOG2E) : 32 } }) }, function (t, n, r) { var e = r(1), i = Math.exp; e(e.S, "Math", { cosh: function (t) { return (i(t = +t) + i(-t)) / 2 } }) }, function (t, n, r) { var e = r(1), i = r(148); e(e.S + e.F * (i != Math.expm1), "Math", { expm1: i }) }, function (t, n, r) { var e = r(1); e(e.S, "Math", { fround: r(179) }) }, function (t, n, r) { var e = r(1), f = Math.abs; e(e.S, "Math", { hypot: function (t, n) { for (var r, e, i = 0, o = 0, u = arguments.length, c = 0; o < u;)c < (r = f(arguments[o++])) ? (i = i * (e = c / r) * e + 1, c = r) : 0 < r ? i += (e = r / c) * e : i += r; return c === 1 / 0 ? 1 / 0 : c * Math.sqrt(i) } }) }, function (t, n, r) { var e = r(1), i = Math.imul; e(e.S + e.F * r(4)(function () { return -5 != i(4294967295, 5) || 2 != i.length }), "Math", { imul: function (t, n) { var r = 65535, e = +t, i = +n, o = r & e, u = r & i; return 0 | o * u + ((r & e >>> 16) * u + o * (r & i >>> 16) << 16 >>> 0) } }) }, function (t, n, r) { var e = r(1); e(e.S, "Math", { log10: function (t) { return Math.log(t) * Math.LOG10E } }) }, function (t, n, r) { var e = r(1); e(e.S, "Math", { log1p: r(180) }) }, function (t, n, r) { var e = r(1); e(e.S, "Math", { log2: function (t) { return Math.log(t) / Math.LN2 } }) }, function (t, n, r) { var e = r(1); e(e.S, "Math", { sign: r(149) }) }, function (t, n, r) { var e = r(1), i = r(148), o = Math.exp; e(e.S + e.F * r(4)(function () { return -2e-17 != !Math.sinh(-2e-17) }), "Math", { sinh: function (t) { return Math.abs(t = +t) < 1 ? (i(t) - i(-t)) / 2 : (o(t - 1) - o(-t - 1)) * (Math.E / 2) } }) }, function (t, n, r) { var e = r(1), i = r(148), o = Math.exp; e(e.S, "Math", { tanh: function (t) { var n = i(t = +t), r = i(-t); return n == 1 / 0 ? 1 : r == 1 / 0 ? -1 : (n - r) / (o(t) + o(-t)) } }) }, function (t, n, r) { var e = r(1); e(e.S, "Math", { trunc: function (t) { return (0 < t ? Math.floor : Math.ceil)(t) } }) }, function (t, n, r) { "use strict"; var e = r(3), i = r(30), o = r(45), u = r(144), s = r(53), c = r(4), f = r(73).f, a = r(31).f, l = r(11).f, h = r(84).trim, v = "Number", p = e[v], d = p, y = p.prototype, g = o(r(72)(y)) == v, b = "trim" in String.prototype, x = function (t) { var n = s(t, !1); if ("string" == typeof n && 2 < n.length) { var r, e, i, o = (n = b ? n.trim() : h(n, 3)).charCodeAt(0); if (43 === o || 45 === o) { if (88 === (r = n.charCodeAt(2)) || 120 === r) return NaN } else if (48 === o) { switch (n.charCodeAt(1)) { case 66: case 98: e = 2, i = 49; break; case 79: case 111: e = 8, i = 55; break; default: return +n }for (var u, c = n.slice(2), f = 0, a = c.length; f < a; f++)if ((u = c.charCodeAt(f)) < 48 || i < u) return NaN; return parseInt(c, e) } } return +n }; if (!p(" 0o1") || !p("0b1") || p("+0x1")) { p = function (t) { var n = arguments.length < 1 ? 0 : t, r = this; return r instanceof p && (g ? c(function () { y.valueOf.call(r) }) : o(r) != v) ? u(new d(x(n)), r, p) : x(n) }; for (var m, S = r(10) ? f(d) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), w = 0; S.length > w; w++)i(d, m = S[w]) && !i(p, m) && l(p, m, a(d, m)); (p.prototype = y).constructor = p, r(27)(e, v, p) } }, function (t, n, r) { var e = r(1); e(e.S, "Number", { EPSILON: Math.pow(2, -52) }) }, function (t, n, r) { var e = r(1), i = r(3).isFinite; e(e.S, "Number", { isFinite: function (t) { return "number" == typeof t && i(t) } }) }, function (t, n, r) { var e = r(1); e(e.S, "Number", { isInteger: r(176) }) }, function (t, n, r) { var e = r(1); e(e.S, "Number", { isNaN: function (t) { return t != t } }) }, function (t, n, r) { var e = r(1), i = r(176), o = Math.abs; e(e.S, "Number", { isSafeInteger: function (t) { return i(t) && o(t) <= 9007199254740991 } }) }, function (t, n, r) { var e = r(1); e(e.S, "Number", { MAX_SAFE_INTEGER: 9007199254740991 }) }, function (t, n, r) { var e = r(1); e(e.S, "Number", { MIN_SAFE_INTEGER: -9007199254740991 }) }, function (t, n, r) { var e = r(1), i = r(188); e(e.S + e.F * (Number.parseFloat != i), "Number", { parseFloat: i }) }, function (t, n, r) { var e = r(1), i = r(189); e(e.S + e.F * (Number.parseInt != i), "Number", { parseInt: i }) }, function (t, n, r) { "use strict"; var e = r(1), a = r(49), s = r(165), l = r(156), i = 1..toFixed, o = Math.floor, u = [0, 0, 0, 0, 0, 0], h = "Number.toFixed: incorrect invocation!", v = function (t, n) { for (var r = -1, e = n; ++r < 6;)e += t * u[r], u[r] = e % 1e7, e = o(e / 1e7) }, p = function (t) { for (var n = 6, r = 0; 0 <= --n;)r += u[n], u[n] = o(r / t), r = r % t * 1e7 }, d = function () { for (var t = 6, n = ""; 0 <= --t;)if ("" !== n || 0 === t || 0 !== u[t]) { var r = String(u[t]); n = "" === n ? r : n + l.call("0", 7 - r.length) + r } return n }, y = function (t, n, r) { return 0 === n ? r : n % 2 == 1 ? y(t, n - 1, r * t) : y(t * t, n / 2, r) }; e(e.P + e.F * (!!i && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9.toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== (0xde0b6b3a7640080).toFixed(0)) || !r(4)(function () { i.call({}) })), "Number", { toFixed: function (t) { var n, r, e, i, o = s(this, h), u = a(t), c = "", f = "0"; if (u < 0 || 20 < u) throw RangeError(h); if (o != o) return "NaN"; if (o <= -1e21 || 1e21 <= o) return String(o); if (o < 0 && (c = "-", o = -o), 1e-21 < o) if (r = (n = function (t) { for (var n = 0, r = t; 4096 <= r;)n += 12, r /= 4096; for (; 2 <= r;)n += 1, r /= 2; return n }(o * y(2, 69, 1)) - 69) < 0 ? o * y(2, -n, 1) : o / y(2, n, 1), r *= 4503599627370496, 0 < (n = 52 - n)) { for (v(0, r), e = u; 7 <= e;)v(1e7, 0), e -= 7; for (v(y(10, e, 1), 0), e = n - 1; 23 <= e;)p(1 << 23), e -= 23; p(1 << e), v(1, 1), p(2), f = d() } else v(0, r), v(1 << -n, 0), f = d() + l.call("0", u); return f = 0 < u ? c + ((i = f.length) <= u ? "0." + l.call("0", u - i) + f : f.slice(0, i - u) + "." + f.slice(i - u)) : c + f } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(4), o = r(165), u = 1..toPrecision; e(e.P + e.F * (i(function () { return "1" !== u.call(1, void 0) }) || !i(function () { u.call({}) })), "Number", { toPrecision: function (t) { var n = o(this, "Number#toPrecision: incorrect invocation!"); return void 0 === t ? u.call(n) : u.call(n, t) } }) }, function (t, n, r) { var e = r(1); e(e.S + e.F, "Object", { assign: r(182) }) }, function (t, n, r) { var e = r(1); e(e.S, "Object", { create: r(72) }) }, function (t, n, r) { var e = r(1); e(e.S + e.F * !r(10), "Object", { defineProperties: r(183) }) }, function (t, n, r) { var e = r(1); e(e.S + e.F * !r(10), "Object", { defineProperty: r(11).f }) }, function (t, n, r) { var e = r(5), i = r(69).onFreeze; r(52)("freeze", function (n) { return function (t) { return n && e(t) ? n(i(t)) : t } }) }, function (t, n, r) { var e = r(33), i = r(31).f; r(52)("getOwnPropertyDescriptor", function () { return function (t, n) { return i(e(t), n) } }) }, function (t, n, r) { r(52)("getOwnPropertyNames", function () { return r(184).f }) }, function (t, n, r) { var e = r(17), i = r(32); r(52)("getPrototypeOf", function () { return function (t) { return i(e(t)) } }) }, function (t, n, r) { var e = r(5); r(52)("isExtensible", function (n) { return function (t) { return !!e(t) && (!n || n(t)) } }) }, function (t, n, r) { var e = r(5); r(52)("isFrozen", function (n) { return function (t) { return !e(t) || !!n && n(t) } }) }, function (t, n, r) { var e = r(5); r(52)("isSealed", function (n) { return function (t) { return !e(t) || !!n && n(t) } }) }, function (t, n, r) { var e = r(1); e(e.S, "Object", { is: r(192) }) }, function (t, n, r) { var e = r(17), i = r(74); r(52)("keys", function () { return function (t) { return i(e(t)) } }) }, function (t, n, r) { var e = r(5), i = r(69).onFreeze; r(52)("preventExtensions", function (n) { return function (t) { return n && e(t) ? n(i(t)) : t } }) }, function (t, n, r) { var e = r(5), i = r(69).onFreeze; r(52)("seal", function (n) { return function (t) { return n && e(t) ? n(i(t)) : t } }) }, function (t, n, r) { var e = r(1); e(e.S, "Object", { setPrototypeOf: r(153).set }) }, function (t, n, r) { "use strict"; var e = r(81), i = {}; i[r(7)("toStringTag")] = "z", i + "" != "[object z]" && r(27)(Object.prototype, "toString", function () { return "[object " + e(this) + "]" }, !0) }, function (t, n, r) { var e = r(1), i = r(188); e(e.G + e.F * (parseFloat != i), { parseFloat: i }) }, function (t, n, r) { var e = r(1), i = r(189); e(e.G + e.F * (parseInt != i), { parseInt: i }) }, function (t, n, r) { "use strict"; var e, i, o, u, c = r(68), f = r(3), a = r(47), s = r(81), l = r(1), h = r(5), v = r(21), p = r(70), d = r(71), y = r(119), g = r(158).set, b = r(150)(), x = r(151), m = r(190), S = r(133), w = r(191), _ = "Promise", O = f.TypeError, E = f.process, M = E && E.versions, P = M && M.v8 || "", j = f[_], F = "process" == s(E), A = function () { }, I = i = x.f, L = !!function () { try { var t = j.resolve(1), n = (t.constructor = {})[r(7)("species")] = function (t) { t(A, A) }; return (F || "function" == typeof PromiseRejectionEvent) && t.then(A) instanceof n && 0 !== P.indexOf("6.6") && -1 === S.indexOf("Chrome/66") } catch (t) { } }(), N = function (t) { var n; return !(!h(t) || "function" != typeof (n = t.then)) && n }, T = function (s, r) { if (!s._n) { s._n = !0; var e = s._c; b(function () { for (var f = s._v, a = 1 == s._s, t = 0, n = function (t) { var n, r, e, i = a ? t.ok : t.fail, o = t.resolve, u = t.reject, c = t.domain; try { i ? (a || (2 == s._h && C(s), s._h = 1), !0 === i ? n = f : (c && c.enter(), n = i(f), c && (c.exit(), e = !0)), n === t.promise ? u(O("Promise-chain cycle")) : (r = N(n)) ? r.call(n, o, u) : o(n)) : u(f) } catch (t) { c && !e && c.exit(), u(t) } }; e.length > t;)n(e[t++]); s._c = [], s._n = !1, r && !s._h && k(s) }) } }, k = function (o) { g.call(f, function () { var t, n, r, e = o._v, i = R(o); if (i && (t = m(function () { F ? E.emit("unhandledRejection", e, o) : (n = f.onunhandledrejection) ? n({ promise: o, reason: e }) : (r = f.console) && r.error && r.error("Unhandled promise rejection", e) }), o._h = F || R(o) ? 2 : 1), o._a = void 0, i && t.e) throw t.v }) }, R = function (t) { return 1 !== t._h && 0 === (t._a || t._c).length }, C = function (n) { g.call(f, function () { var t; F ? E.emit("rejectionHandled", n) : (t = f.onrejectionhandled) && t({ promise: n, reason: n._v }) }) }, D = function (t) { var n = this; n._d || (n._d = !0, (n = n._w || n)._v = t, n._s = 2, n._a || (n._a = n._c.slice()), T(n, !0)) }, G = function (t) { var r, e = this; if (!e._d) { e._d = !0, e = e._w || e; try { if (e === t) throw O("Promise can't be resolved itself"); (r = N(t)) ? b(function () { var n = { _w: e, _d: !1 }; try { r.call(t, a(G, n, 1), a(D, n, 1)) } catch (t) { D.call(n, t) } }) : (e._v = t, e._s = 1, T(e, !1)) } catch (t) { D.call({ _w: e, _d: !1 }, t) } } }; L || (j = function (t) { p(this, j, _, "_h"), v(t), e.call(this); try { t(a(G, this, 1), a(D, this, 1)) } catch (t) { D.call(this, t) } }, (e = function (t) { this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1 }).prototype = r(76)(j.prototype, { then: function (t, n) { var r = I(y(this, j)); return r.ok = "function" != typeof t || t, r.fail = "function" == typeof n && n, r.domain = F ? E.domain : void 0, this._c.push(r), this._a && this._a.push(r), this._s && T(this, !1), r.promise }, catch: function (t) { return this.then(void 0, t) } }), o = function () { var t = new e; this.promise = t, this.resolve = a(G, t, 1), this.reject = a(D, t, 1) }, x.f = I = function (t) { return t === j || t === u ? new o(t) : i(t) }), l(l.G + l.W + l.F * !L, { Promise: j }), r(83)(j, _), r(77)(_), u = r(46)[_], l(l.S + l.F * !L, _, { reject: function (t) { var n = I(this); return (0, n.reject)(t), n.promise } }), l(l.S + l.F * (c || !L), _, { resolve: function (t) { return w(c && this === u ? j : this, t) } }), l(l.S + l.F * !(L && r(125)(function (t) { j.all(t).catch(A) })), _, { all: function (t) { var u = this, n = I(u), c = n.resolve, f = n.reject, r = m(function () { var e = [], i = 0, o = 1; d(t, !1, function (t) { var n = i++, r = !1; e.push(void 0), o++, u.resolve(t).then(function (t) { r || (r = !0, e[n] = t, --o || c(e)) }, f) }), --o || c(e) }); return r.e && f(r.v), n.promise }, race: function (t) { var n = this, r = I(n), e = r.reject, i = m(function () { d(t, !1, function (t) { n.resolve(t).then(r.resolve, e) }) }); return i.e && e(i.v), r.promise } }) }, function (t, n, r) { var e = r(1), o = r(21), u = r(2), c = (r(3).Reflect || {}).apply, f = Function.apply; e(e.S + e.F * !r(4)(function () { c(function () { }) }), "Reflect", { apply: function (t, n, r) { var e = o(t), i = u(r); return c ? c(e, n, i) : f.call(e, n, i) } }) }, function (t, n, r) { var e = r(1), c = r(72), f = r(21), a = r(2), s = r(5), i = r(4), l = r(169), h = (r(3).Reflect || {}).construct, v = i(function () { function t() { } return !(h(function () { }, [], t) instanceof t) }), p = !i(function () { h(function () { }) }); e(e.S + e.F * (v || p), "Reflect", { construct: function (t, n) { f(t), a(n); var r = arguments.length < 3 ? t : f(arguments[2]); if (p && !v) return h(t, n, r); if (t == r) { switch (n.length) { case 0: return new t; case 1: return new t(n[0]); case 2: return new t(n[0], n[1]); case 3: return new t(n[0], n[1], n[2]); case 4: return new t(n[0], n[1], n[2], n[3]) }var e = [null]; return e.push.apply(e, n), new (l.apply(t, e)) } var i = r.prototype, o = c(s(i) ? i : Object.prototype), u = Function.apply.call(t, o, n); return s(u) ? u : o } }) }, function (t, n, r) { var e = r(11), i = r(1), o = r(2), u = r(53); i(i.S + i.F * r(4)(function () { Reflect.defineProperty(e.f({}, 1, { value: 1 }), 1, { value: 2 }) }), "Reflect", { defineProperty: function (t, n, r) { o(t), n = u(n, !0), o(r); try { return e.f(t, n, r), !0 } catch (t) { return !1 } } }) }, function (t, n, r) { var e = r(1), i = r(31).f, o = r(2); e(e.S, "Reflect", { deleteProperty: function (t, n) { var r = i(o(t), n); return !(r && !r.configurable) && delete t[n] } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(2), o = function (t) { this._t = i(t), this._i = 0; var n, r = this._k = []; for (n in t) r.push(n) }; r(146)(o, "Object", function () { var t, n = this._k; do { if (this._i >= n.length) return { value: void 0, done: !0 } } while (!((t = n[this._i++]) in this._t)); return { value: t, done: !1 } }), e(e.S, "Reflect", { enumerate: function (t) { return new o(t) } }) }, function (t, n, r) { var e = r(31), i = r(1), o = r(2); i(i.S, "Reflect", { getOwnPropertyDescriptor: function (t, n) { return e.f(o(t), n) } }) }, function (t, n, r) { var e = r(1), i = r(32), o = r(2); e(e.S, "Reflect", { getPrototypeOf: function (t) { return i(o(t)) } }) }, function (t, n, r) { var u = r(31), c = r(32), f = r(30), e = r(1), a = r(5), s = r(2); e(e.S, "Reflect", { get: function t(n, r) { var e, i, o = arguments.length < 3 ? n : arguments[2]; return s(n) === o ? n[r] : (e = u.f(n, r)) ? f(e, "value") ? e.value : void 0 !== e.get ? e.get.call(o) : void 0 : a(i = c(n)) ? t(i, r, o) : void 0 } }) }, function (t, n, r) { var e = r(1); e(e.S, "Reflect", { has: function (t, n) { return n in t } }) }, function (t, n, r) { var e = r(1), i = r(2), o = Object.isExtensible; e(e.S, "Reflect", { isExtensible: function (t) { return i(t), !o || o(t) } }) }, function (t, n, r) { var e = r(1); e(e.S, "Reflect", { ownKeys: r(187) }) }, function (t, n, r) { var e = r(1), i = r(2), o = Object.preventExtensions; e(e.S, "Reflect", { preventExtensions: function (t) { i(t); try { return o && o(t), !0 } catch (t) { return !1 } } }) }, function (t, n, r) { var e = r(1), i = r(153); i && e(e.S, "Reflect", { setPrototypeOf: function (t, n) { i.check(t, n); try { return i.set(t, n), !0 } catch (t) { return !1 } } }) }, function (t, n, r) { var f = r(11), a = r(31), s = r(32), l = r(30), e = r(1), h = r(75), v = r(2), p = r(5); e(e.S, "Reflect", { set: function t(n, r, e) { var i, o, u = arguments.length < 4 ? n : arguments[3], c = a.f(v(n), r); if (!c) { if (p(o = s(n))) return t(o, r, e, u); c = h(0) } if (l(c, "value")) { if (!1 === c.writable || !p(u)) return !1; if (i = a.f(u, r)) { if (i.get || i.set || !1 === i.writable) return !1; i.value = e, f.f(u, r, i) } else f.f(u, r, h(0, e)); return !0 } return void 0 !== c.set && (c.set.call(u, e), !0) } }) }, function (t, n, r) { var e = r(3), o = r(144), i = r(11).f, u = r(73).f, c = r(124), f = r(115), a = e.RegExp, s = a, l = a.prototype, h = /a/g, v = /a/g, p = new a(h) !== h; if (r(10) && (!p || r(4)(function () { return v[r(7)("match")] = !1, a(h) != h || a(v) == v || "/a/i" != a(h, "i") }))) { a = function (t, n) { var r = this instanceof a, e = c(t), i = void 0 === n; return !r && e && t.constructor === a && i ? t : o(p ? new s(e && !i ? t.source : t, n) : s((e = t instanceof a) ? t.source : t, e && i ? f.call(t) : n), r ? this : l, a) }; for (var d = function (n) { n in a || i(a, n, { configurable: !0, get: function () { return s[n] }, set: function (t) { s[n] = t } }) }, y = u(s), g = 0; y.length > g;)d(y[g++]); (l.constructor = a).prototype = l, r(27)(e, "RegExp", a) } r(77)("RegExp") }, function (t, n, r) { "use strict"; var l = r(2), h = r(8), v = r(136), p = r(128); r(122)("match", 1, function (e, i, a, s) { return [function (t) { var n = e(this), r = null == t ? void 0 : t[i]; return void 0 !== r ? r.call(t, n) : new RegExp(t)[i](String(n)) }, function (t) { var n = s(a, t, this); if (n.done) return n.value; var r = l(t), e = String(this); if (!r.global) return p(r, e); for (var i, o = r.unicode, u = [], c = r.lastIndex = 0; null !== (i = p(r, e));) { var f = String(i[0]); "" === (u[c] = f) && (r.lastIndex = v(e, h(r.lastIndex), o)), c++ } return 0 === c ? null : u }] }) }, function (t, n, r) { "use strict"; var O = r(2), e = r(17), E = r(8), M = r(49), P = r(136), j = r(128), F = Math.max, A = Math.min, h = Math.floor, v = /\$([$&`']|\d\d?|<[^>]*>)/g, p = /\$([$&`']|\d\d?)/g; r(122)("replace", 2, function (i, o, S, w) { function _(o, u, c, f, a, t) { var s = c + o.length, l = f.length, n = p; return void 0 !== a && (a = e(a), n = v), S.call(t, n, function (t, n) { var r; switch (n.charAt(0)) { case "$": return "$"; case "&": return o; case "`": return u.slice(0, c); case "'": return u.slice(s); case "<": r = a[n.slice(1, -1)]; break; default: var e = +n; if (0 === e) return t; if (l < e) { var i = h(e / 10); return 0 === i ? t : i <= l ? void 0 === f[i - 1] ? n.charAt(1) : f[i - 1] + n.charAt(1) : t } r = f[e - 1] }return void 0 === r ? "" : r }) } return [function (t, n) { var r = i(this), e = null == t ? void 0 : t[o]; return void 0 !== e ? e.call(t, r, n) : S.call(String(r), t, n) }, function (t, n) { var r = w(S, t, this, n); if (r.done) return r.value; var e = O(t), i = String(this), o = "function" == typeof n; o || (n = String(n)); var u, c = e.global; if (c) { var f = e.unicode; e.lastIndex = 0 } for (var a = []; ;) { var s = j(e, i); if (null === s) break; if (a.push(s), !c) break; "" === String(s[0]) && (e.lastIndex = P(i, E(e.lastIndex), f)) } for (var l = "", h = 0, v = 0; v < a.length; v++) { s = a[v]; for (var p = String(s[0]), d = F(A(M(s.index), i.length), 0), y = [], g = 1; g < s.length; g++)y.push(void 0 === (u = s[g]) ? u : String(u)); var b = s.groups; if (o) { var x = [p].concat(y, d, i); void 0 !== b && x.push(b); var m = String(n.apply(void 0, x)) } else m = _(p, i, d, y, b, n); h <= d && (l += i.slice(h, d) + m, h = d + p.length) } return l + i.slice(h) }] }) }, function (t, n, r) { "use strict"; var f = r(2), a = r(192), s = r(128); r(122)("search", 1, function (e, i, u, c) { return [function (t) { var n = e(this), r = null == t ? void 0 : t[i]; return void 0 !== r ? r.call(t, n) : new RegExp(t)[i](String(n)) }, function (t) { var n = c(u, t, this); if (n.done) return n.value; var r = f(t), e = String(this), i = r.lastIndex; a(i, 0) || (r.lastIndex = 0); var o = s(r, e); return a(r.lastIndex, i) || (r.lastIndex = i), null === o ? -1 : o.index }] }) }, function (t, n, r) { "use strict"; var l = r(124), x = r(2), m = r(119), S = r(136), w = r(8), _ = r(128), h = r(152), e = r(4), O = Math.min, v = [].push, u = "split", p = "length", d = "lastIndex", E = 4294967295, M = !e(function () { RegExp(E, "y") }); r(122)("split", 2, function (i, o, y, g) { var b; return b = "c" == "abbc"[u](/(b)*/)[1] || 4 != "test"[u](/(?:)/, -1)[p] || 2 != "ab"[u](/(?:ab)*/)[p] || 4 != "."[u](/(.?)(.?)/)[p] || 1 < "."[u](/()()/)[p] || ""[u](/.?/)[p] ? function (t, n) { var r = String(this); if (void 0 === t && 0 === n) return []; if (!l(t)) return y.call(r, t, n); for (var e, i, o, u = [], c = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""), f = 0, a = void 0 === n ? E : n >>> 0, s = new RegExp(t.source, c + "g"); (e = h.call(s, r)) && !(f < (i = s[d]) && (u.push(r.slice(f, e.index)), 1 < e[p] && e.index < r[p] && v.apply(u, e.slice(1)), o = e[0][p], f = i, u[p] >= a));)s[d] === e.index && s[d]++; return f === r[p] ? !o && s.test("") || u.push("") : u.push(r.slice(f)), u[p] > a ? u.slice(0, a) : u } : "0"[u](void 0, 0)[p] ? function (t, n) { return void 0 === t && 0 === n ? [] : y.call(this, t, n) } : y, [function (t, n) { var r = i(this), e = null == t ? void 0 : t[o]; return void 0 !== e ? e.call(t, r, n) : b.call(String(r), t, n) }, function (t, n) { var r = g(b, t, this, n, b !== y); if (r.done) return r.value; var e = x(t), i = String(this), o = m(e, RegExp), u = e.unicode, c = (e.ignoreCase ? "i" : "") + (e.multiline ? "m" : "") + (e.unicode ? "u" : "") + (M ? "y" : "g"), f = new o(M ? e : "^(?:" + e.source + ")", c), a = void 0 === n ? E : n >>> 0; if (0 === a) return []; if (0 === i.length) return null === _(f, i) ? [i] : []; for (var s = 0, l = 0, h = []; l < i.length;) { f.lastIndex = M ? l : 0; var v, p = _(f, M ? i : i.slice(l)); if (null === p || (v = O(w(f.lastIndex + (M ? 0 : l)), i.length)) === s) l = S(i, l, u); else { if (h.push(i.slice(s, l)), h.length === a) return h; for (var d = 1; d <= p.length - 1; d++)if (h.push(p[d]), h.length === a) return h; l = s = v } } return h.push(i.slice(s)), h }] }) }, function (t, n, r) { "use strict"; r(198); var e = r(2), i = r(115), o = r(10), u = "toString", c = /./[u], f = function (t) { r(27)(RegExp.prototype, u, t, !0) }; r(4)(function () { return "/a/b" != c.call({ source: "a", flags: "b" }) }) ? f(function () { var t = e(this); return "/".concat(t.source, "/", "flags" in t ? t.flags : !o && t instanceof RegExp ? i.call(t) : void 0) }) : c.name != u && f(function () { return c.call(this) }) }, function (t, n, r) { "use strict"; r(28)("anchor", function (n) { return function (t) { return n(this, "a", "name", t) } }) }, function (t, n, r) { "use strict"; r(28)("big", function (t) { return function () { return t(this, "big", "", "") } }) }, function (t, n, r) { "use strict"; r(28)("blink", function (t) { return function () { return t(this, "blink", "", "") } }) }, function (t, n, r) { "use strict"; r(28)("bold", function (t) { return function () { return t(this, "b", "", "") } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(131)(!1); e(e.P, "String", { codePointAt: function (t) { return i(this, t) } }) }, function (t, n, r) { "use strict"; var e = r(1), u = r(8), c = r(155), f = "endsWith", a = ""[f]; e(e.P + e.F * r(142)(f), "String", { endsWith: function (t) { var n = c(this, t, f), r = 1 < arguments.length ? arguments[1] : void 0, e = u(n.length), i = void 0 === r ? e : Math.min(u(r), e), o = String(t); return a ? a.call(n, o, i) : n.slice(i - o.length, i) === o } }) }, function (t, n, r) { "use strict"; r(28)("fixed", function (t) { return function () { return t(this, "tt", "", "") } }) }, function (t, n, r) { "use strict"; r(28)("fontcolor", function (n) { return function (t) { return n(this, "font", "color", t) } }) }, function (t, n, r) { "use strict"; r(28)("fontsize", function (n) { return function (t) { return n(this, "font", "size", t) } }) }, function (t, n, r) { var e = r(1), o = r(78), u = String.fromCharCode, i = String.fromCodePoint; e(e.S + e.F * (!!i && 1 != i.length), "String", { fromCodePoint: function (t) { for (var n, r = [], e = arguments.length, i = 0; i < e;) { if (n = +arguments[i++], o(n, 1114111) !== n) throw RangeError(n + " is not a valid code point"); r.push(n < 65536 ? u(n) : u(55296 + ((n -= 65536) >> 10), n % 1024 + 56320)) } return r.join("") } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(155); e(e.P + e.F * r(142)("includes"), "String", { includes: function (t) { return !!~i(this, t, "includes").indexOf(t, 1 < arguments.length ? arguments[1] : void 0) } }) }, function (t, n, r) { "use strict"; r(28)("italics", function (t) { return function () { return t(this, "i", "", "") } }) }, function (t, n, r) { "use strict"; var e = r(131)(!0); r(147)(String, "String", function (t) { this._t = String(t), this._i = 0 }, function () { var t, n = this._t, r = this._i; return r >= n.length ? { value: void 0, done: !0 } : (t = e(n, r), this._i += t.length, { value: t, done: !1 }) }) }, function (t, n, r) { "use strict"; r(28)("link", function (n) { return function (t) { return n(this, "a", "href", t) } }) }, function (t, n, r) { var e = r(1), u = r(33), c = r(8); e(e.S, "String", { raw: function (t) { for (var n = u(t.raw), r = c(n.length), e = arguments.length, i = [], o = 0; o < r;)i.push(String(n[o++])), o < e && i.push(String(arguments[o])); return i.join("") } }) }, function (t, n, r) { var e = r(1); e(e.P, "String", { repeat: r(156) }) }, function (t, n, r) { "use strict"; r(28)("small", function (t) { return function () { return t(this, "small", "", "") } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(8), o = r(155), u = "startsWith", c = ""[u]; e(e.P + e.F * r(142)(u), "String", { startsWith: function (t) { var n = o(this, t, u), r = i(Math.min(1 < arguments.length ? arguments[1] : void 0, n.length)), e = String(t); return c ? c.call(n, e, r) : n.slice(r, r + e.length) === e } }) }, function (t, n, r) { "use strict"; r(28)("strike", function (t) { return function () { return t(this, "strike", "", "") } }) }, function (t, n, r) { "use strict"; r(28)("sub", function (t) { return function () { return t(this, "sub", "", "") } }) }, function (t, n, r) { "use strict"; r(28)("sup", function (t) { return function () { return t(this, "sup", "", "") } }) }, function (t, n, r) { "use strict"; r(84)("trim", function (t) { return function () { return t(this, 3) } }) }, function (t, n, r) { "use strict"; var e = r(3), u = r(30), i = r(10), o = r(1), c = r(27), f = r(69).KEY, a = r(4), s = r(118), l = r(83), h = r(79), v = r(7), p = r(195), d = r(160), y = r(218), g = r(123), b = r(2), x = r(5), m = r(17), S = r(33), w = r(53), _ = r(75), O = r(72), E = r(184), M = r(31), P = r(127), j = r(11), F = r(74), A = M.f, I = j.f, L = E.f, N = e.Symbol, T = e.JSON, k = T && T.stringify, R = "prototype", C = v("_hidden"), D = v("toPrimitive"), G = {}.propertyIsEnumerable, W = s("symbol-registry"), U = s("symbols"), V = s("op-symbols"), B = Object[R], q = "function" == typeof N && !!P.f, z = e.QObject, K = !z || !z[R] || !z[R].findChild, H = i && a(function () { return 7 != O(I({}, "a", { get: function () { return I(this, "a", { value: 7 }).a } })).a }) ? function (t, n, r) { var e = A(B, n); e && delete B[n], I(t, n, r), e && t !== B && I(B, n, e) } : I, J = function (t) { var n = U[t] = O(N[R]); return n._k = t, n }, $ = q && "symbol" == typeof N.iterator ? function (t) { return "symbol" == typeof t } : function (t) { return t instanceof N }, Y = function (t, n, r) { return t === B && Y(V, n, r), b(t), n = w(n, !0), b(r), u(U, n) ? (r.enumerable ? (u(t, C) && t[C][n] && (t[C][n] = !1), r = O(r, { enumerable: _(0, !1) })) : (u(t, C) || I(t, C, _(1, {})), t[C][n] = !0), H(t, n, r)) : I(t, n, r) }, X = function (t, n) { b(t); for (var r, e = y(n = S(n)), i = 0, o = e.length; i < o;)Y(t, r = e[i++], n[r]); return t }, Q = function (t) { var n = G.call(this, t = w(t, !0)); return !(this === B && u(U, t) && !u(V, t)) && (!(n || !u(this, t) || !u(U, t) || u(this, C) && this[C][t]) || n) }, Z = function (t, n) { if (t = S(t), n = w(n, !0), t !== B || !u(U, n) || u(V, n)) { var r = A(t, n); return !r || !u(U, n) || u(t, C) && t[C][n] || (r.enumerable = !0), r } }, tt = function (t) { for (var n, r = L(S(t)), e = [], i = 0; r.length > i;)u(U, n = r[i++]) || n == C || n == f || e.push(n); return e }, nt = function (t) { for (var n, r = t === B, e = L(r ? V : S(t)), i = [], o = 0; e.length > o;)!u(U, n = e[o++]) || r && !u(B, n) || i.push(U[n]); return i }; q || (c((N = function () { if (this instanceof N) throw TypeError("Symbol is not a constructor!"); var n = h(0 < arguments.length ? arguments[0] : void 0), r = function (t) { this === B && r.call(V, t), u(this, C) && u(this[C], n) && (this[C][n] = !1), H(this, n, _(1, t)) }; return i && K && H(B, n, { configurable: !0, set: r }), J(n) })[R], "toString", function () { return this._k }), M.f = Z, j.f = Y, r(73).f = E.f = tt, r(117).f = Q, P.f = nt, i && !r(68) && c(B, "propertyIsEnumerable", Q, !0), p.f = function (t) { return J(v(t)) }), o(o.G + o.W + o.F * !q, { Symbol: N }); for (var rt = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), et = 0; rt.length > et;)v(rt[et++]); for (var it = F(v.store), ot = 0; it.length > ot;)d(it[ot++]); o(o.S + o.F * !q, "Symbol", { for: function (t) { return u(W, t += "") ? W[t] : W[t] = N(t) }, keyFor: function (t) { if (!$(t)) throw TypeError(t + " is not a symbol!"); for (var n in W) if (W[n] === t) return n }, useSetter: function () { K = !0 }, useSimple: function () { K = !1 } }), o(o.S + o.F * !q, "Object", { create: function (t, n) { return void 0 === n ? O(t) : X(O(t), n) }, defineProperty: Y, defineProperties: X, getOwnPropertyDescriptor: Z, getOwnPropertyNames: tt, getOwnPropertySymbols: nt }); var ut = a(function () { P.f(1) }); o(o.S + o.F * ut, "Object", { getOwnPropertySymbols: function (t) { return P.f(m(t)) } }), T && o(o.S + o.F * (!q || a(function () { var t = N(); return "[null]" != k([t]) || "{}" != k({ a: t }) || "{}" != k(Object(t)) })), "JSON", { stringify: function (t) { for (var n, r, e = [t], i = 1; arguments.length > i;)e.push(arguments[i++]); if (r = n = e[1], (x(n) || void 0 !== t) && !$(t)) return g(n) || (n = function (t, n) { if ("function" == typeof r && (n = r.call(this, t, n)), !$(n)) return n }), e[1] = n, k.apply(T, e) } }), N[R][D] || r(26)(N[R], D, N[R].valueOf), l(N, "Symbol"), l(Math, "Math", !0), l(e.JSON, "JSON", !0) }, function (t, n, r) { "use strict"; var e = r(1), i = r(132), o = r(159), a = r(2), s = r(78), l = r(8), u = r(5), c = r(3).ArrayBuffer, h = r(119), v = o.ArrayBuffer, p = o.DataView, f = i.ABV && c.isView, d = v.prototype.slice, y = i.VIEW, g = "ArrayBuffer"; e(e.G + e.W + e.F * (c !== v), { ArrayBuffer: v }), e(e.S + e.F * !i.CONSTR, g, { isView: function (t) { return f && f(t) || u(t) && y in t } }), e(e.P + e.U + e.F * r(4)(function () { return !new v(2).slice(1, void 0).byteLength }), g, { slice: function (t, n) { if (void 0 !== d && void 0 === n) return d.call(a(this), t); for (var r = a(this).byteLength, e = s(t, r), i = s(void 0 === n ? r : n, r), o = new (h(this, v))(l(i - e)), u = new p(this), c = new p(o), f = 0; e < i;)c.setUint8(f++, u.getUint8(e++)); return o } }), r(77)(g) }, function (t, n, r) { var e = r(1); e(e.G + e.W + e.F * !r(132).ABV, { DataView: r(159).DataView }) }, function (t, n, r) { r(57)("Float32", 4, function (e) { return function (t, n, r) { return e(this, t, n, r) } }) }, function (t, n, r) { r(57)("Float64", 8, function (e) { return function (t, n, r) { return e(this, t, n, r) } }) }, function (t, n, r) { r(57)("Int16", 2, function (e) { return function (t, n, r) { return e(this, t, n, r) } }) }, function (t, n, r) { r(57)("Int32", 4, function (e) { return function (t, n, r) { return e(this, t, n, r) } }) }, function (t, n, r) { r(57)("Int8", 1, function (e) { return function (t, n, r) { return e(this, t, n, r) } }) }, function (t, n, r) { r(57)("Uint16", 2, function (e) { return function (t, n, r) { return e(this, t, n, r) } }) }, function (t, n, r) { r(57)("Uint32", 4, function (e) { return function (t, n, r) { return e(this, t, n, r) } }) }, function (t, n, r) { r(57)("Uint8", 1, function (e) { return function (t, n, r) { return e(this, t, n, r) } }) }, function (t, n, r) { r(57)("Uint8", 1, function (e) { return function (t, n, r) { return e(this, t, n, r) } }, !0) }, function (t, n, r) { "use strict"; var e = r(172), i = r(80); r(121)("WeakSet", function (t) { return function () { return t(this, 0 < arguments.length ? arguments[0] : void 0) } }, { add: function (t) { return e.def(i(this, "WeakSet"), t, !0) } }, e, !1, !0) }, function (t, n, r) { "use strict"; var e = r(1), i = r(173), o = r(17), u = r(8), c = r(21), f = r(138); e(e.P, "Array", { flatMap: function (t) { var n, r, e = o(this); return c(t), n = u(e.length), r = f(e, 0), i(r, e, e, n, 0, 1, t, arguments[1]), r } }), r(67)("flatMap") }, function (t, n, r) { "use strict"; var e = r(1), i = r(173), o = r(17), u = r(8), c = r(49), f = r(138); e(e.P, "Array", { flatten: function () { var t = arguments[0], n = o(this), r = u(n.length), e = f(n, 0); return i(e, n, n, r, 0, void 0 === t ? 1 : c(t)), e } }), r(67)("flatten") }, function (t, n, r) { "use strict"; var e = r(1), i = r(120)(!0); e(e.P, "Array", { includes: function (t) { return i(this, t, 1 < arguments.length ? arguments[1] : void 0) } }), r(67)("includes") }, function (t, n, r) { var e = r(1), i = r(150)(), o = r(3).process, u = "process" == r(45)(o); e(e.G, { asap: function (t) { var n = u && o.domain; i(n ? n.bind(t) : t) } }) }, function (t, n, r) { var e = r(1), i = r(45); e(e.S, "Error", { isError: function (t) { return "Error" === i(t) } }) }, function (t, n, r) { var e = r(1); e(e.G, { global: r(3) }) }, function (t, n, r) { r(129)("Map") }, function (t, n, r) { r(130)("Map") }, function (t, n, r) { var e = r(1); e(e.P + e.R, "Map", { toJSON: r(171)("Map") }) }, function (t, n, r) { var e = r(1); e(e.S, "Math", { clamp: function (t, n, r) { return Math.min(r, Math.max(n, t)) } }) }, function (t, n, r) { var e = r(1); e(e.S, "Math", { DEG_PER_RAD: Math.PI / 180 }) }, function (t, n, r) { var e = r(1), i = 180 / Math.PI; e(e.S, "Math", { degrees: function (t) { return t * i } }) }, function (t, n, r) { var e = r(1), o = r(181), u = r(179); e(e.S, "Math", { fscale: function (t, n, r, e, i) { return u(o(t, n, r, e, i)) } }) }, function (t, n, r) { var e = r(1); e(e.S, "Math", { iaddh: function (t, n, r, e) { var i = t >>> 0, o = r >>> 0; return (n >>> 0) + (e >>> 0) + ((i & o | (i | o) & ~(i + o >>> 0)) >>> 31) | 0 } }) }, function (t, n, r) { var e = r(1); e(e.S, "Math", { imulh: function (t, n) { var r = +t, e = +n, i = 65535 & r, o = 65535 & e, u = r >> 16, c = e >> 16, f = (u * o >>> 0) + (i * o >>> 16); return u * c + (f >> 16) + ((i * c >>> 0) + (65535 & f) >> 16) } }) }, function (t, n, r) { var e = r(1); e(e.S, "Math", { isubh: function (t, n, r, e) { var i = t >>> 0, o = r >>> 0; return (n >>> 0) - (e >>> 0) - ((~i & o | ~(i ^ o) & i - o >>> 0) >>> 31) | 0 } }) }, function (t, n, r) { var e = r(1); e(e.S, "Math", { RAD_PER_DEG: 180 / Math.PI }) }, function (t, n, r) { var e = r(1), i = Math.PI / 180; e(e.S, "Math", { radians: function (t) { return t * i } }) }, function (t, n, r) { var e = r(1); e(e.S, "Math", { scale: r(181) }) }, function (t, n, r) { var e = r(1); e(e.S, "Math", { signbit: function (t) { return (t = +t) != t ? t : 0 == t ? 1 / t == 1 / 0 : 0 < t } }) }, function (t, n, r) { var e = r(1); e(e.S, "Math", { umulh: function (t, n) { var r = +t, e = +n, i = 65535 & r, o = 65535 & e, u = r >>> 16, c = e >>> 16, f = (u * o >>> 0) + (i * o >>> 16); return u * c + (f >>> 16) + ((i * c >>> 0) + (65535 & f) >>> 16) } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(17), o = r(21), u = r(11); r(10) && e(e.P + r(126), "Object", { __defineGetter__: function (t, n) { u.f(i(this), t, { get: o(n), enumerable: !0, configurable: !0 }) } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(17), o = r(21), u = r(11); r(10) && e(e.P + r(126), "Object", { __defineSetter__: function (t, n) { u.f(i(this), t, { set: o(n), enumerable: !0, configurable: !0 }) } }) }, function (t, n, r) { var e = r(1), i = r(186)(!0); e(e.S, "Object", { entries: function (t) { return i(t) } }) }, function (t, n, r) { var e = r(1), f = r(187), a = r(33), s = r(31), l = r(139); e(e.S, "Object", { getOwnPropertyDescriptors: function (t) { for (var n, r, e = a(t), i = s.f, o = f(e), u = {}, c = 0; o.length > c;)void 0 !== (r = i(e, n = o[c++])) && l(u, n, r); return u } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(17), o = r(53), u = r(32), c = r(31).f; r(10) && e(e.P + r(126), "Object", { __lookupGetter__: function (t) { var n, r = i(this), e = o(t, !0); do { if (n = c(r, e)) return n.get } while (r = u(r)) } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(17), o = r(53), u = r(32), c = r(31).f; r(10) && e(e.P + r(126), "Object", { __lookupSetter__: function (t) { var n, r = i(this), e = o(t, !0); do { if (n = c(r, e)) return n.set } while (r = u(r)) } }) }, function (t, n, r) { var e = r(1), i = r(186)(!1); e(e.S, "Object", { values: function (t) { return i(t) } }) }, function (t, n, r) { "use strict"; var e = r(1), o = r(3), u = r(46), i = r(150)(), c = r(7)("observable"), f = r(21), a = r(2), s = r(70), l = r(76), h = r(26), v = r(71), p = v.RETURN, d = function (t) { return null == t ? void 0 : f(t) }, y = function (t) { var n = t._c; n && (t._c = void 0, n()) }, g = function (t) { return void 0 === t._o }, b = function (t) { g(t) || (t._o = void 0, y(t)) }, x = function (t, n) { a(t), this._c = void 0, this._o = t, t = new m(this); try { var r = n(t), e = r; null != r && ("function" == typeof r.unsubscribe ? r = function () { e.unsubscribe() } : f(r), this._c = r) } catch (n) { return void t.error(n) } g(this) && y(this) }; x.prototype = l({}, { unsubscribe: function () { b(this) } }); var m = function (t) { this._s = t }; m.prototype = l({}, { next: function (t) { var n = this._s; if (!g(n)) { var r = n._o; try { var e = d(r.next); if (e) return e.call(r, t) } catch (t) { try { b(n) } finally { throw t } } } }, error: function (t) { var n = this._s; if (g(n)) throw t; var r = n._o; n._o = void 0; try { var e = d(r.error); if (!e) throw t; t = e.call(r, t) } catch (t) { try { y(n) } finally { throw t } } return y(n), t }, complete: function (t) { var n = this._s; if (!g(n)) { var r = n._o; n._o = void 0; try { var e = d(r.complete); t = e ? e.call(r, t) : void 0 } catch (t) { try { y(n) } finally { throw t } } return y(n), t } } }); var S = function (t) { s(this, S, "Observable", "_f")._f = f(t) }; l(S.prototype, { subscribe: function (t) { return new x(t, this._f) }, forEach: function (e) { var i = this; return new (u.Promise || o.Promise)(function (t, n) { f(e); var r = i.subscribe({ next: function (t) { try { return e(t) } catch (t) { n(t), r.unsubscribe() } }, error: n, complete: t }) }) } }), l(S, { from: function (t) { var n = "function" == typeof this ? this : S, r = d(a(t)[c]); if (r) { var e = a(r.call(t)); return e.constructor === n ? e : new n(function (t) { return e.subscribe(t) }) } return new n(function (n) { var r = !1; return i(function () { if (!r) { try { if (v(t, !1, function (t) { if (n.next(t), r) return p }) === p) return } catch (t) { if (r) throw t; return void n.error(t) } n.complete() } }), function () { r = !0 } }) }, of: function () { for (var t = 0, n = arguments.length, e = new Array(n); t < n;)e[t] = arguments[t++]; return new ("function" == typeof this ? this : S)(function (n) { var r = !1; return i(function () { if (!r) { for (var t = 0; t < e.length; ++t)if (n.next(e[t]), r) return; n.complete() } }), function () { r = !0 } }) } }), h(S.prototype, c, function () { return this }), e(e.G, { Observable: S }), r(77)("Observable") }, function (t, n, r) { "use strict"; var e = r(1), i = r(46), o = r(3), u = r(119), c = r(191); e(e.P + e.R, "Promise", { finally: function (n) { var r = u(this, i.Promise || o.Promise), t = "function" == typeof n; return this.then(t ? function (t) { return c(r, n()).then(function () { return t }) } : n, t ? function (t) { return c(r, n()).then(function () { throw t }) } : n) } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(151), o = r(190); e(e.S, "Promise", { try: function (t) { var n = i.f(this), r = o(t); return (r.e ? n.reject : n.resolve)(r.v), n.promise } }) }, function (t, n, r) { var e = r(56), i = r(2), o = e.key, u = e.set; e.exp({ defineMetadata: function (t, n, r, e) { u(t, n, i(r), o(e)) } }) }, function (t, n, r) { var e = r(56), o = r(2), u = e.key, c = e.map, f = e.store; e.exp({ deleteMetadata: function (t, n) { var r = arguments.length < 3 ? void 0 : u(arguments[2]), e = c(o(n), r, !1); if (void 0 === e || !e.delete(t)) return !1; if (e.size) return !0; var i = f.get(n); return i.delete(r), !!i.size || f.delete(n) } }) }, function (t, n, r) { var o = r(199), u = r(167), e = r(56), i = r(2), c = r(32), f = e.keys, a = e.key, s = function (t, n) { var r = f(t, n), e = c(t); if (null === e) return r; var i = s(e, n); return i.length ? r.length ? u(new o(r.concat(i))) : i : r }; e.exp({ getMetadataKeys: function (t) { return s(i(t), arguments.length < 2 ? void 0 : a(arguments[1])) } }) }, function (t, n, r) { var e = r(56), i = r(2), o = r(32), u = e.has, c = e.get, f = e.key, a = function (t, n, r) { if (u(t, n, r)) return c(t, n, r); var e = o(n); return null !== e ? a(t, e, r) : void 0 }; e.exp({ getMetadata: function (t, n) { return a(t, i(n), arguments.length < 3 ? void 0 : f(arguments[2])) } }) }, function (t, n, r) { var e = r(56), i = r(2), o = e.keys, u = e.key; e.exp({ getOwnMetadataKeys: function (t) { return o(i(t), arguments.length < 2 ? void 0 : u(arguments[1])) } }) }, function (t, n, r) { var e = r(56), i = r(2), o = e.get, u = e.key; e.exp({ getOwnMetadata: function (t, n) { return o(t, i(n), arguments.length < 3 ? void 0 : u(arguments[2])) } }) }, function (t, n, r) { var e = r(56), i = r(2), o = r(32), u = e.has, c = e.key, f = function (t, n, r) { if (u(t, n, r)) return !0; var e = o(n); return null !== e && f(t, e, r) }; e.exp({ hasMetadata: function (t, n) { return f(t, i(n), arguments.length < 3 ? void 0 : c(arguments[2])) } }) }, function (t, n, r) { var e = r(56), i = r(2), o = e.has, u = e.key; e.exp({ hasOwnMetadata: function (t, n) { return o(t, i(n), arguments.length < 3 ? void 0 : u(arguments[2])) } }) }, function (t, n, r) { var e = r(56), i = r(2), o = r(21), u = e.key, c = e.set; e.exp({ metadata: function (r, e) { return function (t, n) { c(r, e, (void 0 !== n ? i : o)(t), u(n)) } } }) }, function (t, n, r) { r(129)("Set") }, function (t, n, r) { r(130)("Set") }, function (t, n, r) { var e = r(1); e(e.P + e.R, "Set", { toJSON: r(171)("Set") }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(131)(!0); e(e.P, "String", { at: function (t) { return i(this, t) } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(51), o = r(8), u = r(124), c = r(115), f = RegExp.prototype, a = function (t, n) { this._r = t, this._s = n }; r(146)(a, "RegExp String", function () { var t = this._r.exec(this._s); return { value: t, done: null === t } }), e(e.P, "String", { matchAll: function (t) { if (i(this), !u(t)) throw TypeError(t + " is not a regexp!"); var n = String(this), r = "flags" in f ? String(t.flags) : c.call(t), e = new RegExp(t.source, ~r.indexOf("g") ? r : "g" + r); return e.lastIndex = o(t.lastIndex), new a(e, n) } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(193), o = r(133), u = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(o); e(e.P + e.F * u, "String", { padEnd: function (t) { return i(this, t, 1 < arguments.length ? arguments[1] : void 0, !1) } }) }, function (t, n, r) { "use strict"; var e = r(1), i = r(193), o = r(133), u = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(o); e(e.P + e.F * u, "String", { padStart: function (t) { return i(this, t, 1 < arguments.length ? arguments[1] : void 0, !0) } }) }, function (t, n, r) { "use strict"; r(84)("trimLeft", function (t) { return function () { return t(this, 1) } }, "trimStart") }, function (t, n, r) { "use strict"; r(84)("trimRight", function (t) { return function () { return t(this, 2) } }, "trimEnd") }, function (t, n, r) { r(160)("asyncIterator") }, function (t, n, r) { r(160)("observable") }, function (t, n, r) { var e = r(1); e(e.S, "System", { global: r(3) }) }, function (t, n, r) { r(129)("WeakMap") }, function (t, n, r) { r(130)("WeakMap") }, function (t, n, r) { r(129)("WeakSet") }, function (t, n, r) { r(130)("WeakSet") }, function (t, n, r) { for (var e = r(162), i = r(74), o = r(27), u = r(3), c = r(26), f = r(82), a = r(7), s = a("iterator"), l = a("toStringTag"), h = f.Array, v = { CSSRuleList: !0, CSSStyleDeclaration: !1, CSSValueList: !1, ClientRectList: !1, DOMRectList: !1, DOMStringList: !1, DOMTokenList: !0, DataTransferItemList: !1, FileList: !1, HTMLAllCollection: !1, HTMLCollection: !1, HTMLFormElement: !1, HTMLSelectElement: !1, MediaList: !0, MimeTypeArray: !1, NamedNodeMap: !1, NodeList: !0, PaintRequestList: !1, Plugin: !1, PluginArray: !1, SVGLengthList: !1, SVGNumberList: !1, SVGPathSegList: !1, SVGPointList: !1, SVGStringList: !1, SVGTransformList: !1, SourceBufferList: !1, StyleSheetList: !0, TextTrackCueList: !1, TextTrackList: !1, TouchList: !1 }, p = i(v), d = 0; d < p.length; d++) { var y, g = p[d], b = v[g], x = u[g], m = x && x.prototype; if (m && (m[s] || c(m, s, h), m[l] || c(m, l, g), f[g] = h, b)) for (y in e) m[y] || o(m, y, e[y], !0) } }, function (t, n, r) { var e = r(1), i = r(158); e(e.G + e.B, { setImmediate: i.set, clearImmediate: i.clear }) }, function (t, n, r) { var e = r(3), i = r(1), o = r(133), u = [].slice, c = /MSIE .\./.test(o), f = function (i) { return function (t, n) { var r = 2 < arguments.length, e = !!r && u.call(arguments, 2); return i(r ? function () { ("function" == typeof t ? t : Function(t)).apply(this, e) } : t, n) } }; i(i.G + i.B + i.F * c, { setTimeout: f(e.setTimeout), setInterval: f(e.setInterval) }) }, function (t, n, r) { r(341), r(280), r(282), r(281), r(284), r(286), r(291), r(285), r(283), r(293), r(292), r(288), r(289), r(287), r(279), r(290), r(294), r(295), r(247), r(249), r(248), r(297), r(296), r(267), r(277), r(278), r(268), r(269), r(270), r(271), r(272), r(273), r(274), r(275), r(276), r(250), r(251), r(252), r(253), r(254), r(255), r(256), r(257), r(258), r(259), r(260), r(261), r(262), r(263), r(264), r(265), r(266), r(328), r(333), r(340), r(331), r(323), r(324), r(329), r(334), r(336), r(319), r(320), r(321), r(322), r(325), r(326), r(327), r(330), r(332), r(335), r(337), r(338), r(339), r(242), r(244), r(243), r(246), r(245), r(231), r(229), r(235), r(232), r(238), r(240), r(228), r(234), r(225), r(239), r(223), r(237), r(236), r(230), r(233), r(222), r(224), r(227), r(226), r(241), r(162), r(313), r(197), r(318), r(198), r(314), r(315), r(316), r(317), r(298), r(196), r(199), r(200), r(353), r(342), r(343), r(348), r(351), r(352), r(346), r(349), r(347), r(350), r(344), r(345), r(299), r(300), r(301), r(302), r(303), r(306), r(304), r(305), r(307), r(308), r(309), r(310), r(312), r(311), r(356), r(354), r(355), r(397), r(400), r(399), r(401), r(402), r(398), r(403), r(404), r(378), r(381), r(377), r(375), r(376), r(379), r(380), r(362), r(396), r(361), r(395), r(407), r(409), r(360), r(394), r(406), r(408), r(359), r(405), r(358), r(363), r(364), r(365), r(366), r(367), r(369), r(368), r(370), r(371), r(372), r(374), r(373), r(383), r(384), r(385), r(386), r(388), r(387), r(390), r(389), r(391), r(392), r(393), r(357), r(382), r(412), r(411), r(410), t.exports = r(46) }, function (t, n) { t.exports = function (t, n) { if ("string" == typeof n) return t.insertAdjacentHTML("afterend", n); var r = t.nextSibling; return r ? t.parentNode.insertBefore(n, r) : t.parentNode.appendChild(n) } }])</script>
<script src="/./main.a5fda8.js"></script>
<script>!function () { var e, t; e = "/slider.27463f.js", t = document.createElement("script"), document.getElementsByTagName("body")[0].appendChild(t), t.setAttribute("src", e) }()</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<!--  -->


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 50%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
        
      
      <li style="width: 50%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">book</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">C++</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">智能指针</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">shared_ptr</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">auto_ptr</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">weak_ptr</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">c++</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">朝花夕拾</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">assert</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">断言</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">浅拷贝</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">深拷贝</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">内存</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">继承</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">多态</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">虚函数</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">虚函数表</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">虚函数指针</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Linux</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">VMware</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">面向对象</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">编程技术</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">bug</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">github</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">clashverge</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">hexo</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">博客</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">git</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">node</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">npm</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">bug解决日记</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">pdf</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">linux</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">目录</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">文件</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Markdown</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">shell</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">shell工具推荐</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Ubuntu</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">top</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">vim</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">浮生六记</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">c</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">文件操作</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">指针</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">java</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">排序算法</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">c/c++</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">GCC/G++</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Make</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">QMake</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">CMake</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">CMakeLists</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">正则表达式</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">float</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">unique_ptr</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia-plus根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
        
          
  	  		<div class="aboutme-wrap" id="aboutme">僕は新世界の神となる!</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>

  
  
<script type="text/javascript" src="/plugins/activate-power-mode/activate-power-mode.js"></script>
<script>
  POWERMODE.colorful = true; // make power mode colorful
  POWERMODE.shake = false; // turn off shake
  document.body.addEventListener('input', POWERMODE);
</script>

  
  <!-- <script async type="text/javascript" size="90" alpha="0.2" zIndex="0" src="/plugins/ribbon.js/ribbon.min.js"></script> -->
  
  
    <script type="text/javascript" src="/plugins/live2d-widget.js/L2Dwidget.min.js"></script>
<script type="text/javascript">
  /**
   * 完整配置请参考：https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init
   */
  var pluginModelPath = "assets/", // 模型的文件路径，无需更改
    pluginRootPath = "/live2d_models/"; // 插件的路径，无需更改
  //特定的模型json文件名称
  var modelPathJson = {
    "epsilon2_1": "Epsilon2.1",
    "gf": "Gantzert_Felixander",
    "haru/01": "haru01",
    "haru/02": "haru02",
    "nietzsche": "nietzche"
  }

  
    var modelName = "hijiki";
  

  var modelJsonPath = "";
  if (modelPathJson[modelName]) {
    modelJsonPath = pluginRootPath + modelName + "/" + pluginModelPath + modelPathJson[modelName] +
      ".model.json";
  } else {
    modelJsonPath = pluginRootPath + modelName + "/" + pluginModelPath + modelName + ".model.json";
  }
  L2Dwidget.init({
    model: {
      jsonPath: modelJsonPath
    },
    display: {
       position: "right", 
       width: 145, 
       height: 315, 
       hOffset: 50, 
      
    },
    mobile: {
      
       scale: 0.6 
    },
    react: {
       opacity: 0.8 
    }
  })

</script>

  
  
</body>

</html>
