[{"title":"C++朝花夕拾-模板详解","date":"2025-09-26T08:19:24.000Z","path":"2025/09/26/C-朝花夕拾-模板详解/","text":"模板详解模板基础C++ 模板（Templates）是现代 C++ 中强大而灵活的特性，支持泛型编程，使得代码更具复用性和类型安全性。模板不仅包括基本的函数模板和类模板，还涵盖了模板特化（全特化与偏特化）、模板参数种类、变参模板（Variadic Templates）、模板元编程（Template Metaprogramming）、SFINAE（Substitution Failure Is Not An Error）等高级内容。 函数模板函数模板允许编写通用的函数，通过类型参数化，使其能够处理不同的数据类型。它通过模板参数定义与类型无关的函数。 语法：1234template &lt;typename T&gt;T functionName(T param) &#123; // 函数体&#125; 示例：最大值函数12345678910111213#include &lt;iostream&gt;template &lt;typename T&gt;T maxValue(T a, T b) &#123; return (a &gt; b) ? a : b;&#125;int main() &#123; std::cout &lt;&lt; maxValue(3, 7) &lt;&lt; std::endl; // int 类型 std::cout &lt;&lt; maxValue(3.14, 2.72) &lt;&lt; std::endl; // double 类型 std::cout &lt;&lt; maxValue(&#x27;a&#x27;, &#x27;z&#x27;) &lt;&lt; std::endl; // char 类型 return 0;&#125; 输出： 12373.14z 要点： 模板参数列表以 template &lt;typename T&gt; 或 template &lt;class T&gt; 开头，两者等价。 类型推导：编译器根据函数参数自动推导模板参数类型。 类模板类模板允许定义通用的类，通过类型参数化，实现不同类型的对象。 语法：123456template &lt;typename T&gt;class ClassName &#123;public: T memberVariable; // 构造函数、成员函数等&#125;; 示例：简单的 Pair 类12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;template &lt;typename T, typename U&gt;class Pair &#123;public: T first; U second; Pair(T a, U b) : first(a), second(b) &#123;&#125; void print() const &#123; std::cout &lt;&lt; &quot;Pair: &quot; &lt;&lt; first &lt;&lt; &quot;, &quot; &lt;&lt; second &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Pair&lt;int, double&gt; p1(1, 2.5); p1.print(); // 输出：Pair: 1, 2.5 Pair&lt;std::string, std::string&gt; p2(&quot;Hello&quot;, &quot;World&quot;); p2.print(); // 输出：Pair: Hello, World Pair&lt;std::string, int&gt; p3(&quot;Age&quot;, 30); p3.print(); // 输出：Pair: Age, 30 return 0;&#125; 输出：123Pair: 1, 2.5Pair: Hello, WorldPair: Age, 30 要点： 类模板可以有多个类型参数。 模板参数可以被用于成员变量和成员函数中。 类模板实例化时指定具体类型，如 Pair&lt;int, double&gt;。 模板参数模板参数决定了模板的泛用性与灵活性。C++ 模板参数种类主要包括类型参数、非类型参数和模板模板参数。 类型参数（Type Parameters）类型参数用于表示任意类型，在模板实例化时被具体的类型替代。 非类型参数（Non-Type Parameters）非类型参数允许模板接受非类型的值，如整数、指针或引用。C++17 支持更多非类型参数类型，如 auto。 语法：1234template &lt;typename T, int Size&gt;class Array &#123; // ...&#125;; 示例：固定大小的数组类123456789101112131415161718192021222324252627#include &lt;iostream&gt;template &lt;typename T, int N&gt;class Array &#123;private: T data[N];public: T&amp; operator[](int index) &#123; return data[index]; &#125; const T&amp; operator[](int index) const &#123; return data[index]; &#125; void fill(const T&amp; value) &#123; for (int i = 0; i &lt; N; ++i) &#123; data[i] = value; &#125; &#125;&#125;;int main() &#123; Array&lt;int, 5&gt; arr; for (int i = 0; i &lt; 5; ++i) &#123; arr[i] = i * 10; &#125; for (int i = 0; i &lt; 5; ++i) &#123; std::cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 输出： 10 10 20 30 40 注意事项： 非类型参数必须是编译期常量。 允许的类型包括整型、枚举、指针、引用等，但不包括浮点数和类类型。 模板模板参数（Template Template Parameters）模板模板参数允许模板接受另一个模板作为参数。这对于抽象容器和策略模式等场景非常有用。 语法：1234template &lt;template &lt;typename&gt; class Container&gt;class Adapter &#123; // ...&#125;; 示例：容器适配器123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;deque&gt;template &lt;template &lt;typename&gt; class Container&gt;class Stack &#123;private: Container&lt;int&gt; elements;public: void push(int value) &#123; elements.push_back(value); &#125; void pop() &#123; elements.pop_back(); &#125; int top() const &#123; return elements.back(); &#125;&#125;;int main() &#123; Stack&lt;std::vector&gt; stack1; Stack&lt;std::deque&gt; stack2; stack1.push(1); stack1.push(2); stack2.push(3); stack2.push(4); std::cout &lt;&lt; stack1.top() &lt;&lt; &quot; &quot; &lt;&lt; stack2.top() &lt;&lt; std::endl; return 0;&#125; 输出： 12 4 要点： 模板模板参数需要完全匹配被接受模板的参数列表。 可通过默认模板参数增强灵活性。 模板特化（Template Specialization）模板特化允许开发者为特定类型或类型组合提供专门的实现。当通用模板无法满足特定需求时，特化模板可以调整行为以处理特定的情况。C++ 支持全特化（Full Specialization）和偏特化（Partial Specialization），但需要注意的是，函数模板不支持偏特化，只能进行全特化。 全特化（Full Specialization）全特化是针对模板参数的完全特定类型组合。它提供了模板的一个特定版本，当模板参数完全匹配特化类型时，编译器将优先使用该特化版本。 语法1234template &lt;&gt;class ClassName&lt;SpecificType&gt; &#123; // 特化实现&#125;; 示例：类模板全特化1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;template &lt;typename T&gt;class Printer &#123;public: void print(const T&amp; value) &#123; std::cout &lt;&lt; &quot;General Printer: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;&#125;;// 全特化版本template &lt;&gt;class Printer&lt;std::string&gt; &#123;public: void print(const std::string&amp; value) &#123; std::cout &lt;&lt; &quot;String Printer: \\&quot;&quot; &lt;&lt; value &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Printer&lt;int&gt; intPrinter; Printer&lt;std::string&gt; stringPrinter; intPrinter.print(42); stringPrinter.print(&quot;Hello World&quot;); return 0;&#125; 输出： 12General Printer: 42String Printer: &quot;Hello World&quot; 解析 通用模板适用于所有类型，在print函数中以通用方式输出值。 全特化模板针对std::string类型进行了专门化，实现了不同的print函数。 当实例化Printer&lt;std::string&gt;时，编译器选择全特化版本而非通用模板。 偏特化（Partial Specialization）偏特化允许模板对部分参数进行特定类型的处理，同时保持其他参数的通用性。对于类模板而言，可以针对模板参数的某些特性进行偏特化；对于函数模板，则仅支持全特化，不支持偏特化。 语法1234template &lt;typename T, typename U&gt;class ClassName&lt;T, U*&gt; &#123; // 偏特化：当U是指针类型时 // 特化实现&#125;; 示例：类模板偏特化123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;template &lt;typename T, typename U&gt;class Pair &#123;public: T first; U second; void print() const &#123; std::cout &lt;&lt; &quot;General Pair: &quot; &lt;&lt; first &lt;&lt; &quot;, &quot; &lt;&lt; second &lt;&lt; std::endl; &#125;&#125;;// 偏特化版本：当第二个类型是指针时template &lt;typename T, typename U&gt;class Pair&lt;T, U*&gt; &#123;public: T first; U* second; void print() const &#123; std::cout &lt;&lt; &quot;Pointer Pair: &quot; &lt;&lt; first &lt;&lt; &quot;, &quot;; if (second) &#123; std::cout &lt;&lt; *second; &#125; else &#123; std::cout &lt;&lt; &quot;nullptr&quot;; &#125; std::cout &lt;&lt; std::endl; &#125;&#125;;int main() &#123; int value = 100; Pair&lt;int, double&gt; p1(10, 3.14); Pair&lt;int, int*&gt; p2(20, &amp;value); p1.print(); p2.print(); return 0;&#125; 输出： 12General Pair: 10, 3.14Pointer Pair: 20, 100 解析 通用模板处理非指针类型对。 偏特化模板处理第二个类型为指针的情况，打印指针指向的值。 使用偏特化提升了模板的灵活性，使其能够根据部分参数类型进行不同处理。 函数模板的特化与类模板不同，函数模板不支持偏特化，只能进行全特化。当对函数模板进行全特化时，需要显式指定类型。 示例：函数模板全特化123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;template &lt;typename T&gt;void printValue(const T&amp; value) &#123; std::cout &lt;&lt; &quot;General value: &quot; &lt;&lt; value &lt;&lt; std::endl;&#125;// 全特化版本template &lt;&gt;void printValue&lt;std::string&gt;(const std::string&amp; value) &#123; std::cout &lt;&lt; &quot;String value: \\&quot;&quot; &lt;&lt; value &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl;&#125;int main() &#123; printValue(42); printValue(3.14); printValue(std::string(&quot;Hello&quot;)); return 0;&#125; 输出： 123General value: 42General value: 3.14String value: &quot;Hello&quot; 解析 通用函数模板适用于所有类型，提供通用的printValue实现。 全特化函数模板专门处理std::string类型，提供不同的输出格式。 调用printValue时，编译器根据实参类型选择适当的模板版本。 注意事项 优先级：全特化版本的优先级高于通用模板，因此当特化条件满足时，总是选择特化版本。 显式指定类型：函数模板特化需要在调用时显式指定类型，或者确保类型推导可以正确匹配特化版本。 不支持偏特化：无法通过偏特化对函数模板进行部分特化，需要通过其他方法（如重载）实现类似功能。 总结 全特化适用于为具体类型或类型组合提供专门实现，适用于类模板和函数模板。 偏特化仅适用于类模板，允许针对部分参数进行特定处理，同时保持其他参数的通用性。 函数模板仅支持全特化，不支持偏特化；类模板支持全特化和偏特化。 特化模板提升了模板的灵活性和适应性，使其能够根据不同类型需求调整行为。 变参模板（Variadic Templates）变参模板允许模板接受可变数量的参数，提供极高的灵活性，是实现诸如 std::tuple、std::variant 等模板库组件的基础。 定义与语法变参模板使用 参数包（Parameter Pack），通过 ... 语法来表示。 语法：1234template &lt;typename... Args&gt;void functionName(Args... args) &#123; // 函数体&#125; 递归与展开（Recursion and Expansion）变参模板通常与递归相结合，通过递归地处理参数包，或者使用 折叠表达式（Fold Expressions） 来展开发参数包。 递归示例：打印所有参数123456789101112131415161718#include &lt;iostream&gt;// 终止函数void print() &#123; std::cout &lt;&lt; std::endl;&#125;// 递归函数模板template &lt;typename T, typename... Args&gt;void print(T first, Args... args) &#123; std::cout &lt;&lt; first &lt;&lt; &quot; &quot;; print(args...);&#125;int main() &#123; print(1, 2.5, &quot;Hello&quot;, &#x27;A&#x27;); return 0;&#125; 输出： 11 2.5 Hello A 折叠表达式版本1234567891011#include &lt;iostream&gt;template &lt;typename... Args&gt;void print(Args... args) &#123; (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; // C++17 折叠表达式&#125;int main() &#123; print(1, 2.5, &quot;Hello&quot;, &#x27;A&#x27;); return 0;&#125; 折叠表达式示例：计算总和C++17 引入了折叠表达式，简化了参数包的处理。 1234567891011#include &lt;iostream&gt;template &lt;typename... Args&gt;auto sum(Args... args) &#123; return (args + ...); // 二元右折叠&#125;int main() &#123; std::cout &lt;&lt; sum(1, 2, 3, 4, 5) &lt;&lt; std::endl; return 0;&#125; 输出： 115 应用示例示例：日志记录器1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;template &lt;typename... Args&gt;void log(const Args&amp;... args) &#123; std::cout &lt;&lt; &quot;[LOG] &quot;; (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;&#125;int main() &#123; log(&quot;User&quot;, &quot; logged in at &quot;, 14, &quot;:30&quot;); log(&quot;Error code: &quot;, 404, &quot;, Message: &quot;, &quot;Not Found&quot;); return 0;&#125; 输出： 12[LOG] User logged in at 14:30[LOG] Error code: 404, Message: Not Found 要点： 变参模板极大地提升了模板的灵活性。 使用递归或折叠表达式处理参数包。 常用于实现通用函数、容器类和元编程工具。 模板折叠（Fold Expressions）1. 折叠表达式的概念与背景在C++中，可变参数模板允许函数或类模板接受任意数量的模板参数。这在编写灵活且通用的代码时非常有用。然而，处理参数包中的每个参数往往需要递归模板技巧，这样的代码通常复杂且难以维护。 折叠表达式的引入显著简化了这一过程。它们允许开发者直接对参数包应用操作符，而无需手动展开或递归处理参数。这不仅使代码更加简洁，还提高了可读性和可维护性。 折叠表达式可分为： 一元折叠表达式（Unary Fold）：对参数包中的每个参数应用一个一元操作符。 二元折叠表达式（Binary Fold）：对参数包中的每个参数应用一个二元操作符。 此外，二元折叠表达式可进一步细分为左折叠（Left Fold）和右折叠（Right Fold），取决于操作符的结合方向。 2. 一元折叠表达式（Unary Fold）一元折叠表达式用于在参数包的每个参数前或后应用一元操作符。语法形式如下： 前置一元折叠（Unary Prefix Fold）1(op ... pack) 后置一元折叠（Unary Postfix Fold）1(pack ... op) 其中，op 是一元操作符，如!（逻辑非）、~（按位取反）等。 示例1：逻辑非操作12345678910111213#include &lt;iostream&gt;template &lt;typename... Args&gt;bool allFalse(Args... args) &#123; return (!args &amp;&amp; ...); // 一元左折叠&#125;int main() &#123; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; allFalse(false, false, false) &lt;&lt; std::endl; // true std::cout &lt;&lt; allFalse(false, true, false) &lt;&lt; std::endl; // false return 0;&#125; 3. 二元折叠表达式（Binary Fold）二元折叠表达式用于在参数包的每个参数之间应用一个二元操作符。它们可以分为二元左折叠（Binary Left Fold）和二元右折叠（Binary Right Fold），取决于操作符的结合方向。 二元折叠表达式语法二元左折叠（Left Fold）： (init op ... op pack) 或者简化为：(pack1 op ... op packN) 二元右折叠（Right Fold）： (pack1 op ... op init op ...) 或者简化为：(pack1 op ... op packN) 其中，op 是二元操作符，如+、*、&amp;&amp;、||、&lt;&lt; 等。 左折叠与右折叠的区别 二元左折叠（Binary Left Fold）：操作符从左至右结合，等价于 (((a op b) op c) op d)。 二元右折叠（Binary Right Fold）：操作符从右至左结合，等价于 (a op (b op (c op d)))。 示例1：求和（Binary Left Fold）1234567891011#include &lt;iostream&gt;template &lt;typename... Args&gt;auto sum(Args... args) &#123; return (args + ...); // 二元左折叠&#125;int main() &#123; std::cout &lt;&lt; sum(1, 2, 3, 4) &lt;&lt; std::endl; // 输出：10 return 0;&#125; 解释： (args + ...) 是一个二元左折叠表达式。 它将+操作符逐个应用于参数，按照左折叠顺序。 即，((1 + 2) + 3) + 4 = 10。 示例2：乘积（Binary Right Fold）1234567891011#include &lt;iostream&gt;template &lt;typename... Args&gt;auto product(Args... args) &#123; return (... * args); // 二元右折叠&#125;int main() &#123; std::cout &lt;&lt; product(2, 3, 4) &lt;&lt; std::endl; // 输出：24 return 0;&#125; 解释： (... * args) 是一个二元右折叠表达式。 它将*操作符逐个应用于参数，按照右折叠顺序。 即，2 * (3 * 4) = 2 * 12 = 24。 示例3：逻辑与（Binary Left Fold）12345678910111213#include &lt;iostream&gt;template &lt;typename... Args&gt;bool allTrue(Args... args) &#123; return (args &amp;&amp; ...); // 二元左折叠&#125;int main() &#123; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; allTrue(true, true, true) &lt;&lt; std::endl; // true std::cout &lt;&lt; allTrue(true, false, true) &lt;&lt; std::endl; // false return 0;&#125; 解释： (args &amp;&amp; ...) 是一个二元左折叠表达式。 用于检查所有参数是否为true。 类似于链式的逻辑与运算。 4. 左折叠与右折叠（Left and Right Folds）了解左折叠和右折叠的区别，对于正确选择折叠表达式的形式至关重要。 二元左折叠（Binary Left Fold）语法： (args op ...) 展开方式： ((arg1 op arg2) op arg3) op ... op argN 适用场景： 当操作符是结合性的且从左侧开始累积操作时（如+、*）。 需要严格的顺序执行时，确保从左到右依次处理参数。 示例： (args + ...) &#x2F;&#x2F; 左折叠求和 二元右折叠（Binary Right Fold）语法： (... op args) 展开方式： arg1 op (arg2 op (arg3 op ... op argN)) 适用场景： 当操作符是右结合的，或当需要从右侧开始累积操作时。 某些特定的逻辑和数据结构可能需要右侧先处理。 示例： (... + args) &#x2F;&#x2F; 右折叠求和 5. op 在折叠表达式中的作用在折叠表达式中，op 代表二元操作符，用于定义如何将参数包中的各个参数相互结合。op 可以是任何合法的二元操作符，包括但不限于： 算术操作符：+、-、*、/、% 等。 逻辑操作符：&amp;&amp;、|| 等。 按位操作符：&amp;、|、^、&lt;&lt;、&gt;&gt; 等。 比较操作符：==、!=、&lt;、&gt;、&lt;=、&gt;= 等。 自定义操作符：如果定义了自定义类型并重载了特定的操作符，也可以使用这些操作符。 op 的选择直接影响折叠表达式的行为和结果。选择适当的操作符是实现特定功能的关键。 示例1：使用加法操作符1234template &lt;typename... Args&gt;auto sum(Args... args) &#123; return (args + ...);&#125; 示例2：使用逻辑与操作符1234template &lt;typename... Args&gt;bool all(Args... args) &#123; return (args &amp;&amp; ...);&#125; 示例3：使用左移操作符（流插入）1234template &lt;typename... Args&gt;void print(Args... args) &#123; (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;&#125; 解释： 在上述示例中，op 分别为 +、&amp;&amp;、&lt;&lt;。 每个操作符定义了如何将参数包中的元素相互结合。 示例4：使用自定义操作符假设有一个自定义类型Point，并重载了+操作符以支持点的相加。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;struct Point &#123; int x, y; Point(int x, int y) : x(x), y(y) &#123;&#125; Point operator+(const Point&amp; other) const &#123; return Point(x + other.x, y + other.y); &#125;&#125;;std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Point&amp; p) &#123; return os &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;&#125;template &lt;typename... Args&gt;auto sumPoints(Args... args) &#123; return (args + ...);&#125;int main() &#123; Point p1(1, 2), p2(3, 4), p3(5, 6); Point result = sumPoints(p1, p2, p3); std::cout &lt;&lt; result &lt;&lt; std::endl; // 输出：(9, 12) return 0;&#125; 解释： 通过重载+操作符，sumPoints函数能够将多个Point对象相加，得到累积的结果。 6. 示例代码与应用为了全面理解折叠表达式的应用，以下提供多个具体示例，涵盖不同类型的折叠表达式。 示例1：字符串拼接12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;template &lt;typename... Args&gt;std::string concatenate(Args... args) &#123; return (std::string&#123;&#125; + ... + args); // 二元左折叠&#125;int main() &#123; std::string result = concatenate(&quot;Hello&quot;, &quot; &quot;, &quot;World&quot;, &quot;!&quot;); std::cout &lt;&lt; result &lt;&lt; std::endl; // 输出：Hello World! return 0;&#125; 示例2：计算逻辑与12345678910111213#include &lt;iostream&gt;template &lt;typename... Args&gt;bool all(Args... args) &#123; return (args &amp;&amp; ...);&#125;int main() &#123; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; all(true, true, true) &lt;&lt; std::endl; // true std::cout &lt;&lt; all(true, false, true) &lt;&lt; std::endl; // false return 0;&#125; 示例3：计算最大值1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;template &lt;typename T, typename... Args&gt;T maxValue(T first, Args... args) &#123; if constexpr (sizeof...(args) == 0) &#123; return first; &#125; else &#123; T restMax = maxValue(args...); return (first &gt; restMax) ? first : restMax; &#125;&#125;int main() &#123; std::cout &lt;&lt; maxValue(1, 5, 3, 9, 2) &lt;&lt; std::endl; // 输出：9 return 0;&#125; 注意： 上述示例中的(std::max)(first, ... , args)是一个非标准用法，需要根据具体情况调整。通常，std::max不支持直接的折叠表达式，因此此例更适合作为概念性说明。在实际应用中，可以使用std::initializer_list或其他方法实现多参数的最大值计算。 示例4：筛选逻辑假设需要检查多个条件是否满足，且每个条件之间使用逻辑或操作： 12345678910111213#include &lt;iostream&gt;template &lt;typename... Conditions&gt;bool anyCondition(Conditions... conds) &#123; return (conds || ...); // 二元左折叠&#125;int main() &#123; bool a = false, b = true, c = false; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; anyCondition(a, b, c) &lt;&lt; std::endl; // true return 0;&#125; 7. 注意事项与最佳实践 操作符的选择选择合适的操作符（op）对于实现正确的折叠行为至关重要。确保所选的操作符符合所需的逻辑和计算需求。 操作符的结合性不同的操作符具有不同的结合性（左结合、右结合）。了解操作符的结合性有助于选择正确的折叠方向（左折叠或右折叠）。 参数包的初始化在二元折叠表达式中，有时需要一个初始值（init）。这主要用于确保折叠的正确性，尤其在参数包可能为空的情况下。 示例： 1234template &lt;typename... Args&gt;auto sumWithInit(int init, Args... args) &#123; return (init + ... + args); // 带初始值的左折叠&#125; 参数包为空的情况如果参数包为空，折叠表达式的结果取决于折叠的类型和初始值。合理设置初始值可以避免潜在的错误。 示例： 1234template &lt;typename... Args&gt;auto safeSum(Args... args) &#123; return (0 + ... + args); // 空包时返回0&#125; 与递归模板的比较折叠表达式在处理可变参数模板时，比传统的递归模板方法更简洁、易读且易于维护。然而，理解折叠表达式的基本原理和语法对于充分利用其优势至关重要。 编译器支持确保所使用的编译器支持C++17或更高标准，因为折叠表达式是在C++17中引入的。常见的支持C++17的编译器包括： GCC：从版本7开始支持C++17，其中完整支持在后续版本中得到增强。 Clang：从版本5开始支持C++17。 MSVC（Visual Studio）：从Visual Studio 2017版本15.7开始提供较全面的C++17支持。 性能考虑折叠表达式本身并不引入额外的性能开销。它们是在编译时展开的，生成的代码与手动展开参数包时的代码几乎相同。然而，编写高效的折叠表达式仍然需要理解所应用操作符的性能特性。 SFINAE（Substitution Failure Is Not An Error）一、什么是SFINAE？SFINAE 是 “Substitution Failure Is Not An Error”（替换失败不是错误）的缩写，是C++模板编程中的一个重要概念。它允许编译器在模板实例化过程中，如果在替换模板参数时失败（即不满足某些条件），不会将其视为编译错误，而是继续寻找其他可能的模板或重载。这一机制为条件编译、类型特性检测、函数重载等提供了强大的支持。 二、SFINAE的工作原理在模板实例化过程中，编译器会尝试将模板参数替换为具体类型。如果在替换过程中出现不合法的表达式或类型，编译器不会报错，而是将该模板视为不可行的，继续尝试其他模板或重载。这一特性允许开发者根据类型特性选择不同的模板实现。 三、SFINAE的应用场景 函数重载选择：根据参数类型的不同选择不同的函数实现。 类型特性检测：检测类型是否具有某些成员或特性，从而决定是否启用某些功能。 条件编译：根据模板参数的特性决定是否编译某些代码段。 四、SFINAE的基本用法SFINAE通常与std::enable_if、模板特化、以及类型萃取等技术结合使用。以下通过几个例子来说明SFINAE的应用。 示例一：通过std::enable_if实现函数重载1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;type_traits&gt;template &lt;typename T&gt;typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::typeprocess(T value) &#123; std::cout &lt;&lt; &quot;Processing integral: &quot; &lt;&lt; value &lt;&lt; std::endl; return value;&#125;template &lt;typename T&gt;typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, T&gt;::typeprocess(T value) &#123; std::cout &lt;&lt; &quot;Processing floating point: &quot; &lt;&lt; value &lt;&lt; std::endl; return value;&#125;int main() &#123; process(42); // 调用整数版本 process(3.14); // 调用浮点数版本 // process(&quot;hello&quot;); // 编译错误：没有匹配的函数 return 0;&#125; 解释： std::enable_if 根据条件 std::is_integral&lt;T&gt;::value 或 std::is_floating_point&lt;T&gt;::value 决定是否启用对应的函数模板。 当条件不满足时，该模板实例化失败，但由于SFINAE规则，编译器不会报错，而是忽略该模板，从而实现函数重载选择。 示例二：检测类型是否具有特定成员假设我们需要实现一个函数，仅当类型 T 具有成员函数 foo 时才启用该函数。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;type_traits&gt;// 检测类型T是否有foo成员函数template &lt;typename T&gt;class has_foo &#123;private: template &lt;typename U&gt; static auto test(int) -&gt; decltype(std::declval&lt;U&gt;().foo(), std::true_type&#123;&#125;); template &lt;typename U&gt; static std::false_type test(...); public: static constexpr bool value = decltype(test&lt;T&gt;(0))::value;&#125;;// 仅当T有foo成员时才启用的函数template &lt;typename T&gt;typename std::enable_if&lt;has_foo&lt;T&gt;::value&gt;::typecall_foo(T&amp; obj) &#123; obj.foo();&#125;// 测试类struct WithFoo &#123; void foo() &#123; std::cout &lt;&lt; &quot;WithFoo::foo() called&quot; &lt;&lt; std::endl; &#125;&#125;;struct WithoutFoo &#123; // 没有foo成员函数&#125;;int main() &#123; WithFoo wf; WithoutFoo wof; call_foo(wf); // 正常调用 // call_foo(wof); // 编译错误：没有匹配的函数 return 0;&#125; 解释： has_foo 是一个类型萃取类，用于检测类型 T 是否具有成员函数 foo。 call_foo 函数模板仅在 T 具有 foo 成员时启用。 对于不具有 foo 成员的类型，编译器会忽略 call_foo，从而避免编译错误。 示例三：通过模板特化实现不同的行为以下是完整的、正确实现 TypePrinter 的代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;type_traits&gt;// 检测类型T是否有非void的value_typetemplate &lt;typename T, typename = void&gt;struct has_non_void_value_type : std::false_type &#123;&#125;;template &lt;typename T&gt;struct has_non_void_value_type&lt;T, std::void_t&lt;typename T::value_type&gt;&gt; : std::negation&lt;std::is_void&lt;typename T::value_type&gt;&gt; &#123;&#125;;// 主模板template &lt;typename T, bool HasValueType = has_non_void_value_type&lt;T&gt;::value&gt;struct TypePrinter &#123; static void print() &#123; std::cout &lt;&lt; &quot;Type without value_type or value_type is void&quot; &lt;&lt; std::endl; &#125;&#125;;// 特化版本：当T有非void的value_type时template &lt;typename T&gt;struct TypePrinter&lt;T, true&gt; &#123; static void print() &#123; std::cout &lt;&lt; &quot;Type with value_type: &quot; &lt;&lt; typeid(typename T::value_type).name() &lt;&lt; std::endl; &#125;&#125;;// 测试结构体struct WithValueType &#123; using value_type = int;&#125;;struct WithoutValueType &#123; // 没有value_type&#125;;struct WithVoidValueType &#123; using value_type = void;&#125;;int main() &#123; TypePrinter&lt;WithValueType&gt;::print(); // 有value_type TypePrinter&lt;WithoutValueType&gt;::print(); // 没有value_type TypePrinter&lt;WithVoidValueType&gt;::print(); // value_type是void return 0;&#125; 代码解释 Trait has_non_void_value_type: 主模板：默认情况下，has_non_void_value_type&lt;T&gt; 继承自 std::false_type，表示 T 没有 value_type 或 value_type 是 void。 特化模板：仅当 T 有 value_type 且 value_type 不是 void 时，has_non_void_value_type&lt;T&gt; 继承自 std::true_type。 TypePrinter 模板: 主模板：接受一个类型 T 和一个布尔模板参数 HasValueType，默认为 has_non_void_value_type&lt;T&gt;::value。 特化版本 TypePrinter&lt;T, true&gt;：当 HasValueType 为 true 时，表示 T 有非 void 的 value_type，提供相应的 print 实现。 特化版本 TypePrinter&lt;T, false&gt;：当 HasValueType 为 false 时，表示 T 没有 value_type 或 value_type 是 void，提供默认的 print 实现。 测试结构体： WithValueType：有一个非 void 的 value_type。 WithoutValueType：没有 value_type。 WithVoidValueType：有一个 value_type，但它是 void。 main 函数： 分别测试了三种情况，验证 TypePrinter 的行为是否符合预期。 五、SFINAE的优缺点优点： 灵活性高：能够根据类型特性选择不同的实现，提升代码的泛化能力。 类型安全：通过编译期检测，避免了运行时错误。 无需额外的运行时开销：所有的类型筛选都在编译期完成。 缺点： 复杂性高：SFINAE相关的代码往往较为复杂，阅读和维护难度较大。 编译器错误信息难以理解：SFINAE失败时，编译器可能给出晦涩的错误信息，调试困难。 模板实例化深度限制：过度使用SFINAE可能导致编译时间增加和模板实例化深度限制问题。 六、现代C++中的替代方案随着C++11及后续标准的发展，引入了诸如decltype、constexpr、if constexpr、概念（C++20）等新的特性，部分情况下可以替代传统的SFINAE，提高代码的可读性和可维护性。例如，C++20引入的概念（Concepts）提供了更为简洁和直观的方式来约束模板参数，减少了SFINAE的复杂性。 示例：使用概念替代SFINAE1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;concepts&gt;template &lt;typename T&gt;concept Integral = std::is_integral_v&lt;T&gt;;template &lt;Integral T&gt;void process(T value) &#123; std::cout &lt;&lt; &quot;Processing integral: &quot; &lt;&lt; value &lt;&lt; std::endl;&#125;template &lt;typename T&gt;requires std::floating_point&lt;T&gt;void process(T value) &#123; std::cout &lt;&lt; &quot;Processing floating point: &quot; &lt;&lt; value &lt;&lt; std::endl;&#125;int main() &#123; process(42); // 调用整数版本 process(3.14); // 调用浮点数版本 // process(&quot;hello&quot;); // 编译错误：没有匹配的函数 return 0;&#125; 解释： 使用概念Integral代替std::enable_if，语法更简洁，代码更易读。 当类型不满足概念时，编译器会给出明确的错误信息，便于调试。 虽然上述方法经典且有效，但在C++11及以后版本，存在更简洁和易读的方式来实现相同的功能。例如，使用std::void_t和更现代的检测技巧，或者直接使用C++20的概念（Concepts），使代码更加清晰。 示例：使用std::void_t简化has_foo1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;type_traits&gt;template &lt;typename T, typename = void&gt;struct has_foo : std::false_type &#123;&#125;;template &lt;typename T&gt;struct has_foo&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;().foo())&gt;&gt; : std::true_type &#123;&#125;;template &lt;typename T&gt;std::enable_if_t&lt;has_foo&lt;T&gt;::value&gt; call_foo(T&amp; obj) &#123; obj.foo();&#125;struct WithFoo &#123; void foo() &#123; std::cout &lt;&lt; &quot;WithFoo::foo() called&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; WithFoo wf; call_foo(wf); // 正常调用 return 0;&#125; 解释： 利用std::void_t，has_foo结构更为简洁。 decltype(std::declval&lt;T&gt;().foo())尝试在不实例化T对象的情况下检测foo()成员函数。 如果foo()存在，has_foo&lt;T&gt;继承自std::true_type，否则继承自std::false_type。 使用C++20概念如果你使用的是支持C++20的编译器，可以利用概念（Concepts）进一步简化和增强可读性。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;concepts&gt;template &lt;typename T&gt;concept HasFoo = requires(T t) &#123; t.foo();&#125;;template &lt;HasFoo T&gt;void call_foo(T&amp; obj) &#123; obj.foo();&#125;struct WithFoo &#123; void foo() &#123; std::cout &lt;&lt; &quot;WithFoo::foo() called&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; WithFoo wf; call_foo(wf); // 正常调用 return 0;&#125; 解释： HasFoo概念：使用requires表达式检测类型T是否具有void foo()成员函数。 call_foo函数模板：仅当T满足HasFoo概念时，模板被启用。 这种方式更直观，易于理解和维护。 七、总结SFINAE作为C++模板编程中的一项强大功能，通过在模板实例化过程中允许替换失败而不报错，实现了基于类型特性的编程。然而，SFINAE的语法复杂且难以维护，现代C++引入的新特性如概念等在某些情况下已经能够更简洁地实现类似的功能。尽管如此，理解SFINAE的工作机制依然对于掌握高级模板技术和阅读老旧代码具有重要意义。 综合案例：结合模板特化与折叠表达式为了进一步巩固对模板特化和折叠表达式的理解，本节将通过一个综合案例展示如何将两者结合使用。 案例描述实现一个通用的日志记录器Logger，能够处理任意数量和类型的参数，并根据不同的类型组合调整输出格式。具体需求包括： 对于普通类型，使用通用的打印格式。 对于指针类型，打印指针地址或指向的值。 对于std::string类型，使用专门的格式。 支持可变数量的参数，通过折叠表达式实现参数的逐一打印。 实现步骤 定义通用类模板Logger，使用模板特化和偏特化处理不同类型。 实现log函数，使用模板折叠表达式逐一打印参数。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;type_traits&gt;// 通用模板template &lt;typename T, typename Enable = void&gt;class Logger &#123;public: static void log(const T&amp; value) &#123; std::cout &lt;&lt; &quot;General Logger: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;&#125;;// 指针类型的偏特化template &lt;typename T&gt;class Logger&lt;T*, void&gt; &#123;public: static void log(T* value) &#123; if (value) &#123; std::cout &lt;&lt; &quot;Pointer Logger: &quot; &lt;&lt; *value &lt;&lt; &quot; (address: &quot; &lt;&lt; value &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Pointer Logger: nullptr&quot; &lt;&lt; std::endl; &#125; &#125;&#125;;// std::string类型的全特化template &lt;&gt;class Logger&lt;std::string, void&gt; &#123;public: static void log(const std::string&amp; value) &#123; std::cout &lt;&lt; &quot;String Logger: \\&quot;&quot; &lt;&lt; value &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; &#125;&#125;;// 辅助函数：记录单个值template &lt;typename T&gt;void logOne(const T&amp; value) &#123; Logger&lt;T&gt;::log(value);&#125;// 使用折叠表达式记录所有参数template &lt;typename... Args&gt;void logAll(const Args&amp;... args) &#123; (logOne(args), ...); // C++17 折叠表达式&#125;int main() &#123; int x = 42; double y = 3.14; std::string str = &quot;Hello World&quot;; int* ptr = &amp;x; int* nullPtr = nullptr; logAll(x, y, str, ptr, nullPtr); return 0;&#125; 输出： 12345General Logger: 42General Logger: 3.14String Logger: &quot;Hello World&quot;Pointer Logger: 42 (address: 0x7ffd...)Pointer Logger: nullptr 解析 **通用模板Logger&lt;T, Enable&gt;**： 使用第二个模板参数Enable与SFINAE（Substitution Failure Is Not An Error）结合，控制模板特化。 对于非指针类型和非std::string类型，使用通用实现，打印”General Logger: value”。 **类模板偏特化Logger&lt;T, Enable&gt;**： 使用std::enable_if和std::is_pointer，当T是指针类型时，特化模板。 实现指针类型的特殊日志处理，打印指针指向的值或nullptr。 **类模板全特化Logger&lt;std::string&gt;**： 为std::string类型提供全特化版本，使用不同的输出格式。 logOne函数模板： 简化调用过程，调用相应的Logger&lt;T&gt;::log方法。 logAll函数模板： 使用模板折叠表达式(logOne(args), ...)，实现对所有参数的逐一日志记录。 通过左折叠的逗号表达式，确保每个logOne调用依次执行。 main函数： 测试不同类型的日志记录，包括普通类型、指针类型和std::string类型。 调用logAll函数，实现多参数的综合日志记录。 模板元编程（Template Metaprogramming）什么是模板元编程模板元编程（Template Metaprogramming）是一种在编译期通过模板机制进行代码生成和计算的编程技术。它利用编译器的模板实例化机制，在编译期间执行代码逻辑，以提高程序的性能和灵活性。 模板元编程的优势 提高代码的可重用性和泛化能力。 在编译期进行复杂计算，减少运行时开销。 实现类型安全的高级抽象。 模板元编程基础 模板特化（Template Specialization）： 全特化（Full Specialization）：为特定类型提供特定实现。 偏特化（Partial Specialization）：为部分模板参数特定的情况提供实现。 递归模板（Recursive Templates）：利用模板的递归实例化机制，实现编译期计算。 编译期计算模板元编程允许在编译时执行计算，如计算阶乘、斐波那契数列等。 示例：编译期阶乘123456789101112131415161718#include &lt;iostream&gt;// 基本模板template &lt;int N&gt;struct Factorial &#123; static const int value = N * Factorial&lt;N - 1&gt;::value;&#125;;// 特化模板：递归终止条件template &lt;&gt;struct Factorial&lt;0&gt; &#123; static const int value = 1;&#125;;int main() &#123; std::cout &lt;&lt; &quot;Factorial of 5: &quot; &lt;&lt; Factorial&lt;5&gt;::value &lt;&lt; std::endl; return 0;&#125; 输出： 1Factorial of 5: 120 讲解： 基本模板Factorial定义了一个静态常量value，其值为N * Factorial&lt;N - 1&gt;::value，实现递归计算。 特化模板Factorial&lt;0&gt;定义递归终止条件，当N&#x3D;0时，value为1。 在main函数中，通过Factorial&lt;5&gt;::value获取5的阶乘结果，编译期即生成其值。 静态成员变量的基本规则在 C++ 中，静态成员变量的声明与定义有以下基本规则： 声明（Declaration）：在类内部声明静态成员变量，告诉编译器该类包含这个静态成员。 定义（Definition）：在类外部对静态成员变量进行定义，分配存储空间。 通常，对于非 constexpr 或非 inline 的静态成员变量，必须 在类外进行定义，否则会导致链接器错误（undefined reference）。 特殊情况：static const 整数成员对于 static const整数类型 的静态成员变量，C++ 标准做了一些特殊的处理： 类内初始化：你可以在类内部初始化 static const 整数成员变量，例如 static const int value = 42;。 使用场景： 不需要类外定义：在某些情况下，编译器在编译阶段可以直接使用类内的初始化值，无需类外定义。 需要类外定义：如果你在程序中对该静态成员变量进行取址（例如，&amp;Factorial&lt;5&gt;::value），或者在其他需要该变量的存储位置时，就需要在类外进行定义。 C++11 及之前的标准在 C++11 及更早的标准中，对于 static const 整数成员变量： 不需要类外定义的情况： 仅在作为编译期常量使用时，不需要类外定义。例如，用于数组大小、模板参数等。 需要类外定义的情况： 当你需要对变量进行取址，或者在需要其存储位置时，必须在类外定义。例如： 12345// 类内声明static const int value = 42;// 类外定义（如果需要进行取址操作）const int ClassName::value; C++17 及更新标准从 C++17 开始，引入了 内联变量（inline variables），使得在类内定义静态成员变量变得更加灵活： 内联静态成员变量： 使用 inline 关键字，可以在类内对静态成员变量进行定义，无需在类外进行单独定义。 这适用于 C++17 及更高版本。 例如，你可以这样编写： 123456789template &lt;int N&gt;struct Factorial &#123; static inline const int value = N * Factorial&lt;N - 1&gt;::value;&#125;;template &lt;&gt;struct Factorial&lt;0&gt; &#123; static inline const int value = 1;&#125;; 在这种情况下，无需在类外进行定义，因为 inline 确保了该变量在每个翻译单元中都只有一个实例。 在 C++11 及之前的标准代码： 123456789101112template &lt;int N&gt;struct Factorial &#123; static const int value = N * Factorial&lt;N - 1&gt;::value;&#125;;template &lt;&gt;struct Factorial&lt;0&gt; &#123; static const int value = 1;&#125;;// 如果需要取址，需要在类外定义// const int Factorial&lt;5&gt;::value; 作为编译期常量使用： 例如，用于其他模板参数或编译期常量计算时，不需要类外定义。 取址或需要存储位置时： 需要在类外进行定义。例如： 12345int main() &#123; std::cout &lt;&lt; Factorial&lt;5&gt;::value &lt;&lt; std::endl; // 不需要定义 const int* ptr = &amp;Factorial&lt;5&gt;::value; // 需要定义 return 0;&#125; 在 C++17 及更高标准如果你使用 C++17 及更高版本，可以使用 inline 关键字： 123456789template &lt;int N&gt;struct Factorial &#123; static inline const int value = N * Factorial&lt;N - 1&gt;::value;&#125;;template &lt;&gt;struct Factorial&lt;0&gt; &#123; static inline const int value = 1;&#125;; 无需类外定义： inline 使得在类内的定义成为唯一的定义，即使在多个翻译单元中使用，也不会导致重复定义错误。 实际示例与测试示例 1：仅作为编译期常量使用 C++11 及之前：无需类外定义。 C++17 及更新：同样无需类外定义，且可以使用 inline 进一步优化。 示例 2：取址 C++11 及之前：必须提供类外定义，否则会在链接时出现错误。 C++17 及更新：若未使用 inline，仍需提供类外定义；使用 inline 则无需。 示例 3：使用 inline（C++17 及更高） C++17 及以上： 无需类外定义。 inline 保证了多重定义的合法性。 详细解析为什么有这样的特殊处理？ 优化与性能： 在编译期常量的情况下，不需要在运行时分配存储空间，编译器可以优化掉相关代码。 兼容性： 早期 C++ 标准遵循这种规则，允许在类内初始化静态常量成员变量，便于模板元编程和常量表达式的使用。 inline 变量： C++17 引入 inline 关键字用于变量，解决了静态成员变量在多个翻译单元中的定义问题，使得代码更简洁。 是否总是需要定义？并非总是需要。关键在于 如何使用 这个静态成员变量： 仅作为编译期常量使用：无需类外定义。 需要存储位置或取址：需要类外定义，除非使用 inline（C++17 及以上）。 编译器与链接器的行为 编译阶段： 类内的初始化用于编译期常量计算，不涉及存储分配。 链接阶段： 如果没有类外定义，且静态成员被 odr-used（可能需要存储位置），链接器会报错，提示找不到符号定义。 使用 inline 关键字后，编译器处理为内联变量，避免了多重定义问题。 示例：编译期斐波那契数列123456789101112131415161718192021#include &lt;iostream&gt;template &lt;int N&gt;struct Fibonacci &#123; static const int value = Fibonacci&lt;N - 1&gt;::value + Fibonacci&lt;N - 2&gt;::value;&#125;;template &lt;&gt;struct Fibonacci&lt;0&gt; &#123; static const int value = 0;&#125;;template &lt;&gt;struct Fibonacci&lt;1&gt; &#123; static const int value = 1;&#125;;int main() &#123; std::cout &lt;&lt; &quot;Fibonacci(10): &quot; &lt;&lt; Fibonacci&lt;10&gt;::value &lt;&lt; std::endl; return 0;&#125; 输出： 1Fibonacci(10): 55 要点： 模板元编程利用编译期计算提升程序性能。 需要理解模板递归与终止条件。 常与类型特性和模板特化结合使用。 类型计算与SFINAE 类型计算：在编译期进行类型的推导和转换。 SFINAE（Substitution Failure Is Not An Error）：模板实例化过程中，如果某个替换失败，编译器不会报错，而是忽略该模板，并尝试其他匹配。 示例：检测类型是否可加12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;type_traits&gt;template &lt;typename T, typename = void&gt;struct is_addable : std::false_type &#123;&#125;;template &lt;typename T&gt;struct is_addable&lt;T, decltype(void(std::declval&lt;T&gt;() + std::declval&lt;T&gt;()))&gt; : std::true_type &#123;&#125;;template &lt;typename T&gt;typename std::enable_if&lt;is_addable&lt;T&gt;::value, T&gt;::typeadd(const T&amp; a, const T&amp; b) &#123; return a + b;&#125;int main() &#123; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;int is addable: &quot; &lt;&lt; is_addable&lt;int&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;std::string is addable: &quot; &lt;&lt; is_addable&lt;std::string&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; add(3, 4) &lt;&lt; std::endl; std::cout &lt;&lt; add(std::string(&quot;Hello&quot;), std::string(&quot; World&quot;)) &lt;&lt; std::endl; return 0;&#125; 讲解： struct is_addable&lt;...&gt; : std::true_type &#123;&#125; 目的：定义一个名为 is_addable 的结构体模板，它继承自 std::true_type。 作用：当特定的模板参数满足条件时，这个特化版本将被选中，表示 T 类型是可加的，即支持 + 操作符。 模板参数解释：&lt;T, decltype(void(std::declval&lt;T&gt;() + std::declval&lt;T&gt;()))&gt; T：这是要检查的类型。 std::declval&lt;T&gt;()： 用途：std::declval&lt;T&gt;() 是一个用于在不实际创建 T 类型对象的情况下，生成一个 T 类型的右值引用。 作用：它允许我们在编译时模拟 T 类型的对象，以便用于表达式的检测。 std::declval&lt;T&gt;() + std::declval&lt;T&gt;()： 表达式：尝试对两个 T 类型的右值引用进行加法运算。 目的：检查 T 类型是否支持 + 操作符。 void(...)： 将加法表达式的结果转换为 void 类型。这是为了在 decltype 中仅关心表达式是否有效，而不关心其具体类型。 decltype(void(std::declval&lt;T&gt;() + std::declval&lt;T&gt;()))： 作用：如果 T 类型支持加法运算，则该 decltype 表达式的类型为 void，否则会导致替换失败。 高级模板元编程技巧 变参模板（Variadic Templates）：支持模板参数包，实现更加灵活的模板定义。 示例：求和模板12345678910111213141516171819#include &lt;iostream&gt;template &lt;int... Ns&gt;struct Sum;template &lt;&gt;struct Sum&lt;&gt; &#123; static const int value = 0;&#125;;template &lt;int N, int... Ns&gt;struct Sum&lt;N, Ns...&gt; &#123; static const int value = N + Sum&lt;Ns...&gt;::value;&#125;;int main() &#123; std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; Sum&lt;1, 2, 3, 4, 5&gt;::value &lt;&lt; std::endl; return 0;&#125; 讲解： 基本模板Sum接受一个整数参数包Ns...。 特化模板Sum&lt;&gt;定义递归终止条件，value为0。 递归定义Sum&lt;N, Ns...&gt;将第一个参数N与剩余参数的和相加。 在main函数中，通过Sum&lt;1, 2, 3, 4, 5&gt;::value计算1+2+3+4+5&#x3D;15。 类型列表（Type Lists）：通过模板参数包管理类型的集合。 示例：类型列表和元素访问1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;typeinfo&gt;template &lt;typename... Types&gt;struct TypeList &#123;&#125;;template &lt;typename List, unsigned N&gt;struct TypeAt;template &lt;typename Head, typename... Tail&gt;struct TypeAt&lt;TypeList&lt;Head, Tail...&gt;, 0&gt; &#123; using type = Head;&#125;;template &lt;typename Head, typename... Tail, unsigned N&gt;struct TypeAt&lt;TypeList&lt;Head, Tail...&gt;, N&gt; &#123; using type = typename TypeAt&lt;TypeList&lt;Tail...&gt;, N - 1&gt;::type;&#125;;int main() &#123; using list = TypeList&lt;int, double, char&gt;; using third_type = TypeAt&lt;list, 2&gt;::type; std::cout &lt;&lt; &quot;Third type: &quot; &lt;&lt; typeid(third_type).name() &lt;&lt; std::endl; return 0;&#125; 讲解： TypeList：定义一个包含多个类型的类型列表。 TypeAt：通过递归模板，从TypeList中获取第N个类型。 当N为0时，类型为Head。 否则，递归获取Tail...中第N-1个类型。 使用：定义list为TypeList&lt;int, double, char&gt;，third_type为第2个类型，即char。 实际应用案例案例1：静态断言与类型检查1234567891011121314#include &lt;type_traits&gt;template &lt;typename T&gt;void process(T value) &#123; static_assert(std::is_arithmetic&lt;T&gt;::value, &quot;T must be arithmetic type&quot;); // 处理逻辑&#125;int main() &#123; process(42); // OK process(3.14); // OK // process(&quot;hello&quot;); // 编译错误：静态断言失败 return 0;&#125; 案例2：编译期字符串123456789101112131415#include &lt;iostream&gt;template &lt;char... Cs&gt;struct String &#123; static const char value[sizeof...(Cs) + 1];&#125;;template &lt;char... Cs&gt;const char String&lt;Cs...&gt;::value[sizeof...(Cs) + 1] = &#123;Cs..., &#x27;\\0&#x27;&#125;;int main() &#123; using Hello = String&lt;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&gt;; std::cout &lt;&lt; Hello::value &lt;&lt; std::endl; // 输出：Hello return 0;&#125; 为什么需要外部定义 value在 C++ 中，静态成员变量与类的实例无关，它们存在于全局命名空间中。然而，静态成员变量的声明和定义是不同的： 声明：告诉编译器类中存在这个变量。 定义：为这个变量分配存储空间。 对于非 inline 的静态成员变量，即使是 constexpr，都需要在类外部进行定义。否则，链接器在处理多个翻译单元时会因为找不到变量的定义而报错。 具体原因 模板类的静态成员变量： 每当模板实例化时，都会产生一个新的类类型，每个类类型都有自己的一组静态成员变量。 因此，编译器需要知道这些静态成员变量在所有翻译单元中都唯一对应一个定义。 constexpr 静态成员变量： 从 C++17 开始，inline 关键字引入，使得 constexpr 静态成员变量可以在类内定义，并且隐式地具有 inline 属性。这意味着不需要在类外定义它们，因为 inline 确保了在多个翻译单元中有同一份定义。 但在 C++17 之前或不使用 inline 的情况下，即使是 constexpr，仍需在类外定义。 类内声明：static constexpr char value[...] 声明了 value 并给予了初始值。 类外定义：constexpr char String&lt;Cs...&gt;::value[...] 为 value 分配了存储空间。 如果省略类外定义，编译器会在链接阶段找不到 value 的定义，导致链接错误。这尤其适用于 C++14 及更早版本，以及 C++17 中未使用 inline 的情形。 如何避免外部定义如果你使用的是 C++17 或更高版本，可以通过 inline 关键字将静态成员变量声明为 inline，从而在类内完成定义，无需再在外部定义。例如： 1234template &lt;char... Cs&gt;struct String &#123; static inline const char value[sizeof...(Cs) + 1] = &#123;Cs..., &#x27;\\0&#x27;&#125;;&#125;; 在这个版本中，inline 关键字告诉编译器这是一个内联变量，允许在多个翻译单元中存在同一份定义，而不会导致重复定义错误。因此，无需在类外再次定义 value。 完整示例对比不使用 inline（需要类外定义）12345678// C++14 及更早版本template &lt;char... Cs&gt;struct String &#123; static const char value[sizeof...(Cs) + 1];&#125;;template &lt;char... Cs&gt;const char String&lt;Cs...&gt;::value[sizeof...(Cs) + 1] = &#123;Cs..., &#x27;\\0&#x27;&#125;; 使用 inline（无需类外定义，C++17 起）12345// C++17 及更高版本template &lt;char... Cs&gt;struct String &#123; static inline const char value[sizeof...(Cs) + 1] = &#123;Cs..., &#x27;\\0&#x27;&#125;;&#125;; C++20 ConceptsC++20 引入了 Concepts，它们为模板参数提供了更强的约束和表达能力，使模板的使用更简洁、错误信息更友好。 定义与使用定义一个 ConceptConcepts 使用 concept 关键字定义，并作为函数或类模板的约束。 1234#include &lt;concepts&gt;template &lt;typename T&gt;concept Arithmetic = std::integral&lt;T&gt; || std::floating_point&lt;T&gt;; 使用 Concept 约束模板1234567891011template &lt;Arithmetic T&gt;T add(T a, T b) &#123; return a + b;&#125;// 或者使用 requires 子句template &lt;typename T&gt;requires Arithmetic&lt;T&gt;T multiply(T a, T b) &#123; return a * b;&#125; 限制与约束Concepts 允许为模板参数定义复杂的约束，使得模板更具表达性，同时提升编译器错误信息的可理解性。 示例：排序函数中的 Concepts12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;concepts&gt;template &lt;typename T&gt;concept Sortable = requires(T a, T b) &#123; &#123; a &lt; b &#125; -&gt; std::convertible_to&lt;bool&gt;;&#125;;template &lt;Sortable T&gt;void sortAndPrint(std::vector&lt;T&gt;&amp; vec) &#123; std::sort(vec.begin(), vec.end()); for (const auto&amp; item : vec) &#123; std::cout &lt;&lt; item &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125;int main() &#123; std::vector&lt;int&gt; numbers = &#123;3, 1, 4, 1, 5&#125;; sortAndPrint(numbers); // std::vector&lt;std::vector&lt;int&gt;&gt; nested; // 不会满足 Sortable 概念 // sortAndPrint(nested); // 编译错误 return 0;&#125; 输出： 11 1 3 4 5 要点： Concepts 提供了模板参数的语义约束。 使用 Concepts 提高模板的可读性和可维护性。 生成更友好的编译错误信息，易于调试。 模板实例化与编译器行为理解模板实例化的过程有助于进行有效的模板设计与优化，尤其是在涉及链接和编译时间时。 显式实例化（Explicit Instantiation）显式实例化告诉编译器生成特定类型下的模板代码，主要用于分离模板的声明与定义，减少编译时间。 语法：12template class ClassName&lt;Type&gt;; // 类模板显式实例化template returnType functionName&lt;Type&gt;(parameters); // 函数模板显式实例化 示例：分离类模板的声明与定义MyClass.h 12345678template &lt;typename T&gt;class MyClass &#123;private: T value;public: MyClass(T v); void print();&#125;; MyClass.cpp 1234567891011121314#include &quot;MyClass.h&quot;#include &lt;iostream&gt;template &lt;typename T&gt;MyClass&lt;T&gt;::MyClass(T v) : value(v) &#123;&#125;template &lt;typename T&gt;void MyClass&lt;T&gt;::print() &#123; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl;&#125;// 显式实例化template class MyClass&lt;int&gt;;template class MyClass&lt;double&gt;; main.cpp 1234567891011#include &quot;MyClass.h&quot;int main() &#123; MyClass&lt;int&gt; obj1(42); MyClass&lt;double&gt; obj2(3.14); obj1.print(); obj2.print(); return 0;&#125; 输出： 12Value: 42Value: 3.14 注意事项： 显式实例化需要在模板定义后进行。 只有显式实例化的类型在未实例化时可用于模板分离。 未显式实例化的类型可能导致链接错误。 隐式实例化（Implicit Instantiation）隐式实例化是编译器在模板被实际使用时自动生成对应实例代码的过程。通常，模板定义与使用都在头文件中完成。 示例：MyClass.h 1234567891011template &lt;typename T&gt;class MyClass &#123;private: T value;public: MyClass(T v) : value(v) &#123;&#125; void print() &#123; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;&#125;; main.cpp 1234567891011#include &quot;MyClass.h&quot;int main() &#123; MyClass&lt;int&gt; obj1(42); MyClass&lt;double&gt; obj2(3.14); obj1.print(); obj2.print(); return 0;&#125; 输出： 12Value: 42Value: 3.14 要点： 隐式实例化不需要显式声明或定义。 模板定义必须在使用前可见，通常通过头文件实现。 容易导致编译时间增加，尤其是大型模板库。 链接时问题与解决方案由于模板是在使用时被实例化，跨源文件使用模板可能导致链接时问题，如重复定义或未定义引用。 解决方案： 内联实现：将模板的定义与声明一起放在头文件中，避免链接时重复定义。 显式实例化：将常用的模板实例化放在源文件中，其他源文件通过 extern 或头文件引用已有实例。 使用 extern template：告知编译器某些模板实例已在其他源文件中显式实例化。 示例：使用 extern templateMyClass.h 12345678template &lt;typename T&gt;class MyClass &#123; // ... 声明&#125;;// 声明外部实例化extern template class MyClass&lt;int&gt;;extern template class MyClass&lt;double&gt;; MyClass.cpp 12345#include &quot;MyClass.h&quot;// 定义（实例化）template class MyClass&lt;int&gt;;template class MyClass&lt;double&gt;; main.cpp 12345678#include &quot;MyClass.h&quot;int main() &#123; MyClass&lt;int&gt; obj1(42); // 使用外部实例化 MyClass&lt;double&gt; obj2(3.14); // 使用外部实例化 return 0;&#125; 要点： 使用 extern template 声明已在其他源文件中实例化的模板。 减少编译时间和链接大小，防止重复定义。 最佳实践与注意事项掌握模板的最佳实践有助于编写高效、可维护的代码，同时避免常见的陷阱和问题。 模板定义与实现分离对于类模板，通常将模板的声明和定义放在同一头文件中，以确保编译器在实例化模板时能够看到完整的定义。尽管可以尝试将模板定义分离到源文件，但需要结合显式实例化，这会增加复杂性，且不适用于广泛使用的模板。 推荐做法： 类模板：将声明和实现统一在头文件中。 函数模板：同样将声明和实现统一在头文件中，或使用显式实例化。 避免过度模板化虽然模板提供了极大的灵活性，但过度复杂的模板会导致代码难以理解、维护和编译时间增加。 建议： 只在必要时使用模板。 保持模板的简单性和可读性，避免过度嵌套和复杂的特化。 合理使用类型特性和 Concepts 进行约束。 提高编译速度的方法模板的广泛使用可能导致编译时间显著增加。以下方法有助于优化编译速度： 预编译头文件（Precompiled Headers）：将频繁使用的模板库放入预编译头中，加速编译。 显式实例化：通过显式实例化减少模板的重复编译。 模块化编程（C++20 Modules）：利用模块化将模板库进行编译和链接，减少编译时间。 合理分割头文件：避免头文件中的模板定义过大，分割成较小的模块。 代码复用与库设计模板是实现高度复用库组件的有效手段，如标准库（std::vector、std::map 等）广泛使用模板。设计模板库时，需考虑以下因素： 接口的一致性：保持模板库的接口简洁、一致，便于使用者理解和使用。 文档与示例：提供详细的文档和示例代码，帮助使用者理解模板库的用法。 错误信息友好：通过 Concepts、SFINAE 等机制提供清晰的错误信息，降低使用门槛。 性能优化：利用模板的编译期计算和内联等特性，提高库组件的性能。 避免模板错误的困惑模板错误通常复杂且难以理解，以下方法有助于减少模板错误的困惑： 逐步调试：从简单的模板开始，逐步增加复杂性，便于定位错误。 使用编译器警告与工具：开启编译器的警告选项，使用静态分析工具检测模板代码中的问题。 代码注释与文档：详细注释复杂的模板代码，提供文档说明其设计和用途。 总结C++ 模板机制是实现泛型编程的核心工具，通过类型参数化和编译期计算，极大地提升了代码的复用性、灵活性和性能。从基础的函数模板和类模板，到高级的模板特化、变参模板、模板元编程、SFINAE 和 Concepts，掌握模板的各个方面能够帮助开发者编写更高效、更加通用的 C++ 代码。 在实际应用中，合理运用模板不仅可以简化代码结构，还可以提高代码的可维护性和可扩展性。然而，模板的复杂性也要求开发者具备扎实的 C++ 基础和良好的编程习惯，以避免过度复杂化和难以调试的问题。 通过本教案的系统学习，相信您已经具备了全面理解和运用 C++ 模板的能力，能够在实际项目中高效地利用模板特性，编写出更为优秀的代码。 练习与习题练习 1：实现一个通用的 Swap 函数模板要求： 编写一个函数模板 swapValues，可以交换任意类型的两个变量。 在 main 函数中测试 int、double、std::string 类型的交换。 提示： 1234template &lt;typename T&gt;void swapValues(T&amp; a, T&amp; b) &#123; // 实现交换逻辑&#125; 练习 2：实现一个模板类 Triple，存储三个相同类型的值，并提供获取各个成员的函数。要求： 模板参数为类型 T。 提供构造函数、成员变量及访问函数。 在 main 中实例化 Triple&lt;int&gt; 和 Triple&lt;std::string&gt;，进行测试。 练习 3：使用模板特化，为类模板 Printer 提供针对 bool 类型的全特化，实现专门的输出格式。要求： 通用模板类 Printer，具有 print 函数，输出 “General Printer: value”。 全特化 Printer&lt;bool&gt;，输出 “Boolean Printer: true” 或 “Boolean Printer: false”。 练习 4：实现一个变参模板函数 logMessages，可以接受任意数量和类型的参数，并依次打印它们。要求： 使用递归方法实现。 在 main 中测试不同参数组合的调用。 练习 5：编写模板元编程结构 IsPointer, 用于在编译期判断一个类型是否为指针类型。要求： 定义 IsPointer&lt;T&gt;，包含 value 静态常量成员，值为 true 或 false。 使用特化进行实现。 在 main 中使用 static_assert 进行测试。 示例： 12static_assert(IsPointer&lt;int*&gt;::value, &quot;int* should be a pointer&quot;);static_assert(!IsPointer&lt;int&gt;::value, &quot;int should not be a pointer&quot;); 练习 6：使用 SFINAE，编写一个函数模板 enableIfExample，只有当类型 T 具有 size() 成员函数时才启用。要求： 使用 std::enable_if 和类型特性检测 size() 成员。 在 main 中测试 std::vector（应启用）和 int（不应启用）。 提示： 12345template &lt;typename T&gt;typename std::enable_if&lt;has_size&lt;T&gt;::value&gt;::typeenableIfExample(const T&amp; container) &#123; std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; container.size() &lt;&lt; std::endl;&#125; 练习 7：使用 C++20 Concepts，定义一个 Concept Integral，要求类型必须是整型，并使用该 Concept 约束一个函数模板 isEven，判断传入的整数是否为偶数。要求： 定义 Integral Concept。 编写函数模板 isEven(u)，仅接受满足 Integral 的类型。 在 main 中测试不同类型的调用。 示例： 1234template &lt;Integral T&gt;bool isEven(T value) &#123; return value % 2 == 0;&#125; 练习 8：实现一个固定大小的栈（FixedStack）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。要求： 模板参数为类型 T 和 std::size_t N。 提供 push, pop, top 等成员函数。 在 main 中测试 FixedStack&lt;int, 5&gt; 和 FixedStack&lt;std::string, 3&gt;。 练习 9：实现一个模板类 TypeIdentity，其成员类型 type 等同于模板参数 T。并使用 static_assert 检查类型关系。要求： 定义 TypeIdentity&lt;T&gt;，包含类型成员 type。 使用 std::is_same 与 static_assert 验证。 示例： 1static_assert(std::is_same&lt;TypeIdentity&lt;int&gt;::type, int&gt;::value, &quot;TypeIdentity&lt;int&gt; should be int&quot;); 练习 10：编写一个模板元编程结构 LengthOf, 用于在编译期计算类型列表的长度。要求： 使用 TypeList 模板定义类型列表。 定义 LengthOf&lt;TypeList&lt;...&gt;&gt;::value 表示类型列表的长度。 在 main 中使用 static_assert 进行测试。 提示： 12345678910template &lt;typename... Types&gt;struct TypeList &#123;&#125;;template &lt;typename List&gt;struct LengthOf;template &lt;typename... Types&gt;struct LengthOf&lt;TypeList&lt;Types...&gt;&gt; &#123; static constexpr std::size_t value = sizeof...(Types);&#125;; 通过上述内容及练习，相信您已全面掌握了 C++ 模板的各个方面。从基础概念到高级技术，模板为 C++ 编程提供了强大的工具。持续练习与应用，将进一步巩固您的模板编程能力。","link":"","tags":[]},{"title":"C++ 智能指针详解：shared_ptr, auto_ptr 和 weak_ptr","date":"2025-09-23T02:44:23.000Z","path":"2025/09/23/C-智能指针详解：shared-ptr-auto-ptr-和-weak-ptr/","text":"C++ 智能指针详解：shared_ptr, auto_ptr 和 weak_ptr1. shared_ptr：共享所有权智能指针1.1 核心概念与定义1.1.1 什么是 shared_ptrstd::shared_ptr 是 C++11 引入的共享所有权智能指针，它通过引用计数（Reference Counting） 机制实现多个智能指针共享同一个对象的所有权。与 unique_ptr 的独占所有权不同，shared_ptr 允许多个指针实例共同管理同一个动态分配的对象。 &#x3D;、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、当最后一个指向对象的 shared_ptr 被销毁或重置时，对象才会被自动删除。这种机制使得 shared_ptr 在需要共享资源的场景下非常有用。 1.1.2 共享所有权语义shared_ptr 的核心是共享所有权模型。多个 shared_ptr 实例可以指向同一个对象，它们通过内部的引用计数器来跟踪有多少个 shared_ptr 正在共享该对象。 1234std::shared_ptr&lt;int&gt; ptr1(new int(42));std::shared_ptr&lt;int&gt; ptr2 = ptr1; // 引用计数变为 2std::shared_ptr&lt;int&gt; ptr3 = ptr2; // 引用计数变为 3// 当 ptr1, ptr2, ptr3 都被销毁时，对象才会被删除 1.1.3 引用计数机制引用计数是 shared_ptr 的核心实现机制： 当新的 shared_ptr 指向现有对象时，引用计数增加 当 shared_ptr 被销毁或指向新对象时，引用计数减少 当引用计数降为 0 时，对象被自动删除 1.2 内部实现与控制块1.2.1 控制块（Control Block）结构shared_ptr 的内部实现比 unique_ptr 复杂，它包含两个指针： 指向管理对象的指针 指向控制块的指针 控制块包含： 引用计数器（use count） 弱引用计数器（weak count） 删除器（deleter） 分配器（allocator） 1234567template&lt;typename T&gt;struct control_block &#123; std::atomic&lt;long&gt; use_count; std::atomic&lt;long&gt; weak_count; void(*deleter)(T*); T* managed_object;&#125;; 1.2.2 引用计数的原子操作为了保证线程安全，shared_ptr 的引用计数操作必须是原子的： 123456789101112131415// 近似实现void increment_ref_count() &#123; use_count.fetch_add(1, std::memory_order_relaxed);&#125;void decrement_ref_count() &#123; if (use_count.fetch_sub(1, std::memory_order_acq_rel) == 1) &#123; // 最后一个 shared_ptr，删除对象 deleter(managed_object); // 如果 weak_count 也为 0，删除控制块 if (weak_count.load() == 0) &#123; delete this; &#125; &#125;&#125; 1.3 常用接口与用法1.3.1 构造与析构1234567891011// 多种构造方式std::shared_ptr&lt;int&gt; p1(new int(42));std::shared_ptr&lt;int&gt; p2 = std::make_shared&lt;int&gt;(42); // 推荐方式std::shared_ptr&lt;int&gt; p3 = p1; // 拷贝构造，引用计数+1// 自定义删除器auto deleter = [](int* p) &#123; std::cout &lt;&lt; &quot;Deleting int\\n&quot;; delete p; &#125;;std::shared_ptr&lt;int&gt; p4(new int(42), deleter); 1.3.2 所有权管理接口123456789101112131415std::shared_ptr&lt;MyClass&gt; ptr = std::make_shared&lt;MyClass&gt;();// 获取原始指针（不增加引用计数）MyClass* raw_ptr = ptr.get();// 重置指针ptr.reset(new MyClass()); // 原对象引用计数-1，管理新对象ptr.reset(); // 变为空指针// 交换两个 shared_ptrstd::shared_ptr&lt;MyClass&gt; ptr2 = std::make_shared&lt;MyClass&gt;();ptr.swap(ptr2);// 获取引用计数long count = ptr.use_count(); // 注意：多线程环境下仅供参考 1.3.3 操作符重载123456789101112131415std::shared_ptr&lt;MyClass&gt; ptr = std::make_shared&lt;MyClass&gt;();// 解引用操作(*ptr).member_function();ptr-&gt;member_function();// 布尔转换if (ptr) &#123; // ptr 不为空&#125;// 比较操作if (ptr == ptr2) &#123; // 指向同一对象&#125; 1.4 性能特点与开销1.4.1 内存开销 控制块开销：每个被管理的对象都有一个控制块 指针开销：shared_ptr 本身包含两个指针（对象指针和控制块指针） 总大小：通常是原始指针的两倍大小 1.4.2 运行时开销 原子操作：引用计数的增减需要原子操作，有性能开销 控制块分配：需要额外的内存分配（除非使用 make_shared） 1.4.3 make_shared 的优势12345// 传统方式：两次内存分配（对象 + 控制块）std::shared_ptr&lt;MyClass&gt; p1(new MyClass());// make_shared：一次内存分配（对象和控制块在一起）std::shared_ptr&lt;MyClass&gt; p2 = std::make_shared&lt;MyClass&gt;(); make_shared 将对象和控制块分配在连续内存中，提高了缓存局部性并减少了一次内存分配。 1.5 实际应用场景1.5.1 共享资源管理1234567891011121314151617class Resource &#123;public: void use() &#123; std::cout &lt;&lt; &quot;Using resource\\n&quot;; &#125;&#125;;class User &#123;private: std::shared_ptr&lt;Resource&gt; resource_;public: User(std::shared_ptr&lt;Resource&gt; res) : resource_(res) &#123;&#125; void doWork() &#123; resource_-&gt;use(); &#125;&#125;;// 多个用户共享同一资源auto resource = std::make_shared&lt;Resource&gt;();User user1(resource);User user2(resource); // 共享同一资源 1.5.2 缓存系统12345678910111213141516class Cache &#123;private: std::unordered_map&lt;std::string, std::shared_ptr&lt;Data&gt;&gt; cache_;public: std::shared_ptr&lt;Data&gt; get(const std::string&amp; key) &#123; auto it = cache_.find(key); if (it != cache_.end()) &#123; return it-&gt;second; // 返回共享指针，延长生命周期 &#125; return nullptr; &#125; void put(const std::string&amp; key, std::shared_ptr&lt;Data&gt; data) &#123; cache_[key] = data; &#125;&#125;; 2. weak_ptr：弱引用智能指针2.1 核心概念与定义2.1.1 什么是 weak_ptrstd::weak_ptr 是一种不控制对象生命周期的智能指针，它是对由 shared_ptr 管理的对象的弱引用。weak_ptr 不会增加对象的引用计数，因此不会阻止对象的销毁。 2.1.2 弱引用语义weak_ptr 的主要用途是打破 shared_ptr 的循环引用问题。它允许观察一个对象而不影响其生命周期。 12345678std::shared_ptr&lt;MyClass&gt; shared = std::make_shared&lt;MyClass&gt;();std::weak_ptr&lt;MyClass&gt; weak = shared; // 不增加引用计数// 对象可能已被销毁，需要检查if (auto locked = weak.lock()) &#123; // 对象还存在，可以安全使用 locked-&gt;doSomething();&#125; 2.2 内部实现机制2.2.1 与控制块的交互weak_ptr 内部也包含指向控制块的指针，但它只操作弱引用计数： 123456789101112131415161718192021222324template&lt;typename T&gt;class weak_ptr &#123;private: T* ptr_; control_block* cb_; public: // 构造时增加弱引用计数 weak_ptr(const shared_ptr&lt;T&gt;&amp; other) : ptr_(other.ptr_), cb_(other.cb_) &#123; if (cb_) cb_-&gt;weak_count.fetch_add(1); &#125; // 析构时减少弱引用计数 ~weak_ptr() &#123; if (cb_) &#123; if (cb_-&gt;weak_count.fetch_sub(1) == 1) &#123; // 弱引用计数为0，但强引用计数可能不为0 if (cb_-&gt;use_count.load() == 0) &#123; delete cb_; // 强引用和弱引用都为0，删除控制块 &#125; &#125; &#125; &#125;&#125;; 2.3 常用接口与用法2.3.1 基本操作12345678910111213141516std::shared_ptr&lt;MyClass&gt; shared = std::make_shared&lt;MyClass&gt;();std::weak_ptr&lt;MyClass&gt; weak = shared;// 检查对象是否还存在if (!weak.expired()) &#123; // 尝试获取 shared_ptr if (auto locked = weak.lock()) &#123; locked-&gt;doSomething(); &#125;&#125;// 直接获取 shared_ptr（如果对象已销毁则返回空）std::shared_ptr&lt;MyClass&gt; locked = weak.lock();if (locked) &#123; // 安全使用&#125; 2.3.2 解决循环引用问题123456789101112131415161718class Node &#123;public: std::string name; // 使用 weak_ptr 避免循环引用 std::weak_ptr&lt;Node&gt; parent; std::vector&lt;std::shared_ptr&lt;Node&gt;&gt; children; Node(const std::string&amp; n) : name(n) &#123;&#125; void addChild(std::shared_ptr&lt;Node&gt; child) &#123; children.push_back(child); child-&gt;parent = weak_from_this(); // C++17 新增 &#125;&#125;;auto node1 = std::make_shared&lt;Node&gt;(&quot;parent&quot;);auto node2 = std::make_shared&lt;Node&gt;(&quot;child&quot;);node1-&gt;addChild(node2); // 不会造成循环引用 2.4 实际应用场景2.4.1 观察者模式12345678910111213141516171819202122232425262728class Subject;class Observer &#123;public: virtual void update(std::weak_ptr&lt;Subject&gt; subject) = 0; virtual ~Observer() = default;&#125;;class Subject &#123;private: std::vector&lt;std::weak_ptr&lt;Observer&gt;&gt; observers_;public: void attach(std::weak_ptr&lt;Observer&gt; observer) &#123; observers_.push_back(observer); &#125; void notify() &#123; for (auto it = observers_.begin(); it != observers_.end();) &#123; if (auto observer = it-&gt;lock()) &#123; observer-&gt;update(weak_from_this()); ++it; &#125; else &#123; // 观察者已被销毁，移除 it = observers_.erase(it); &#125; &#125; &#125;&#125;; 2.4.2 缓存系统优化12345678910111213141516171819class CacheWithWeakPtr &#123;private: std::unordered_map&lt;std::string, std::weak_ptr&lt;Data&gt;&gt; cache_; mutable std::mutex mutex_; public: std::shared_ptr&lt;Data&gt; get(const std::string&amp; key) &#123; std::lock_guard&lt;std::mutex&gt; lock(mutex_); auto it = cache_.find(key); if (it != cache_.end()) &#123; if (auto data = it-&gt;second.lock()) &#123; return data; // 对象还存在 &#125; else &#123; cache_.erase(it); // 对象已被销毁，清理缓存 &#125; &#125; return nullptr; &#125;&#125;; 3. auto_ptr：已废弃的智能指针3.1 历史背景与设计缺陷3.1.1 auto_ptr 的起源std::auto_ptr 是 C++98 标准中引入的第一个智能指针，旨在提供基本的自动内存管理功能。它在当时是一个重要的创新，但后来被发现存在严重的设计缺陷。 3.1.2 主要设计缺陷 有问题的拷贝语义：auto_ptr 的拷贝操作会转移所有权 不适用于标准库容器：由于非常规的拷贝语义，不能安全地在 STL 容器中使用 缺乏移动语义支持：在 C++11 之前，没有移动语义，导致 awkward 的所有权转移 3.2 问题示例与缺陷分析3.2.1 危险的所有权转移12345678// C++98/03 中的 auto_ptr（已废弃）std::auto_ptr&lt;int&gt; p1(new int(42));std::auto_ptr&lt;int&gt; p2 = p1; // p1 变为空，所有权转移到 p2// 意外行为：p1 现在为空，但代码可能继续使用它if (p1.get()) &#123; // 这个条件为 false *p1 = 100; // 未定义行为！&#125; 3.2.2 与 STL 容器的不兼容123456789std::vector&lt;std::auto_ptr&lt;int&gt;&gt; vec; // 危险的用法！std::auto_ptr&lt;int&gt; p(new int(42));vec.push_back(p); // p 的所有权转移到 vector 中// 现在 p 为空，但代码可能不知道if (p.get()) &#123; // false // 永远不会执行&#125; 3.3 从 auto_ptr 到 unique_ptr 的演进3.3.1 为什么 unique_ptr 更好12345678// unique_ptr 的明确语义std::unique_ptr&lt;int&gt; p1(new int(42));// std::unique_ptr&lt;int&gt; p2 = p1; // 编译错误！防止意外拷贝std::unique_ptr&lt;int&gt; p2 = std::move(p1); // 明确的移动语义// 可以安全地在容器中使用std::vector&lt;std::unique_ptr&lt;int&gt;&gt; vec;vec.push_back(std::make_unique&lt;int&gt;(42)); // 必须显式移动 3.3.2 迁移指南如果遇到旧的 auto_ptr 代码，应该迁移到 unique_ptr： 1234567891011121314// 旧的 auto_ptr 代码std::auto_ptr&lt;MyClass&gt; old_ptr(new MyClass());// 迁移到 unique_ptrstd::unique_ptr&lt;MyClass&gt; new_ptr(new MyClass());// 对于函数参数和返回值std::auto_ptr&lt;MyClass&gt; create_old() &#123; return std::auto_ptr&lt;MyClass&gt;(new MyClass());&#125;std::unique_ptr&lt;MyClass&gt; create_new() &#123; return std::make_unique&lt;MyClass&gt;();&#125; 3.4 现代替代方案总结 特性 auto_ptr (已废弃) unique_ptr shared_ptr weak_ptr 所有权模型 转移所有权 独占所有权 共享所有权 弱引用 拷贝语义 转移所有权（危险） 禁止拷贝 共享所有权 不增加引用计数 移动语义 无（C++98） 支持移动 支持移动 支持移动 容器兼容性 不兼容 兼容（需移动） 兼容 兼容 线程安全 无 无（但可单独保护） 引用计数原子操作 原子操作 推荐使用 不应使用 独占资源 共享资源 打破循环引用 4. 智能指针的最佳实践与陷阱4.1 选择正确的智能指针4.1.1 决策流程 是否需要共享所有权？ 否 → 使用 unique_ptr 是 → 使用 shared_ptr 是否需要观察而不拥有？ 是 → 配合使用 weak_ptr 是否有循环引用风险？ 是 → 使用 weak_ptr 打破循环 4.1.2 使用场景总结1234567891011// 1. 独占资源 - unique_ptrstd::unique_ptr&lt;File&gt; file = openFile(&quot;data.txt&quot;);// 2. 共享资源 - shared_ptrstd::shared_ptr&lt;Database&gt; db = std::make_shared&lt;Database&gt;();auto user1 = User(db);auto user2 = User(db); // 共享数据库连接// 3. 观察资源 - weak_ptrstd::shared_ptr&lt;Subject&gt; subject = std::make_shared&lt;Subject&gt;();std::weak_ptr&lt;Subject&gt; observer = subject; 4.2 常见陷阱与解决方案4.2.1 循环引用问题1234567891011// 错误示例：循环引用导致内存泄漏class BadNode &#123; std::shared_ptr&lt;BadNode&gt; parent; // 应该使用 weak_ptr std::shared_ptr&lt;BadNode&gt; child;&#125;;// 正确解决方案class GoodNode &#123; std::weak_ptr&lt;GoodNode&gt; parent; // 使用 weak_ptr 打破循环 std::shared_ptr&lt;GoodNode&gt; child;&#125;; 4.2.2 避免原始指针与智能指针混用12345678// 危险的做法MyClass* raw_ptr = new MyClass();std::shared_ptr&lt;MyClass&gt; ptr1(raw_ptr);// std::shared_ptr&lt;MyClass&gt; ptr2(raw_ptr); // 灾难！双重删除// 安全的做法std::shared_ptr&lt;MyClass&gt; ptr1 = std::make_shared&lt;MyClass&gt;();std::shared_ptr&lt;MyClass&gt; ptr2 = ptr1; // 共享所有权 4.2.3 this 指针问题12345678910111213class MyClass : public std::enable_shared_from_this&lt;MyClass&gt; &#123;public: std::shared_ptr&lt;MyClass&gt; get_shared() &#123; return shared_from_this(); // 安全地获取 shared_ptr &#125;&#125;;// 错误：直接从 this 创建 shared_ptr// std::shared_ptr&lt;MyClass&gt; bad_ptr(this);// 正确：使用 enable_shared_from_thisauto obj = std::make_shared&lt;MyClass&gt;();auto good_ptr = obj-&gt;get_shared(); 4.3 性能优化建议4.3.1 优先使用 make_shared 和 make_unique123456// 不推荐：两次内存分配std::shared_ptr&lt;MyClass&gt; p1(new MyClass());// 推荐：一次内存分配，更好的性能std::shared_ptr&lt;MyClass&gt; p2 = std::make_shared&lt;MyClass&gt;();std::unique_ptr&lt;MyClass&gt; p3 = std::make_unique&lt;MyClass&gt;(); 4.3.2 避免不必要的 shared_ptr 拷贝1234567891011121314// 不好的做法：不必要的拷贝void process(const std::shared_ptr&lt;Data&gt;&amp; data) &#123; // 如果不需要共享所有权，应该传引用 data-&gt;process();&#125;// 更好的做法：根据需求选择参数类型void process_by_ref(Data&amp; data) &#123; // 不需要所有权 data.process();&#125;void process_by_shared(std::shared_ptr&lt;Data&gt; data) &#123; // 需要共享所有权 data-&gt;process();&#125; 通过理解和正确应用这些智能指针，可以编写出更安全、更高效的 C++ 代码，避免常见的内存管理错误。","link":"","tags":[{"name":"C++","slug":"C","permalink":"https://lyroom.github.io/tags/C/"},{"name":"智能指针","slug":"智能指针","permalink":"https://lyroom.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"name":"shared_ptr","slug":"shared-ptr","permalink":"https://lyroom.github.io/tags/shared-ptr/"},{"name":"auto_ptr","slug":"auto-ptr","permalink":"https://lyroom.github.io/tags/auto-ptr/"},{"name":"weak_ptr","slug":"weak-ptr","permalink":"https://lyroom.github.io/tags/weak-ptr/"}]},{"title":"详解 C++ unique_ptr：独占式智能指针","date":"2025-09-23T00:18:46.000Z","path":"2025/09/23/详解-C-unique-ptr：独占式智能指针/","text":"详解 C++ unique_ptr：独占式智能指针1. unique_ptr 的核心概念与定义1.1 什么是 unique_ptrstd::unique_ptr 是 C++11 标准库中引入的一种智能指针，其核心设计目标是提供一种对动态分配对象的独占所有权（Exclusive Ownership） 管理机制。 与原始指针（raw pointer）不同，unique_ptr 遵循 RAII（Resource Acquisition Is Initialization，资源获取即初始化） 原则，确保其管理的内存在其生命周期结束时能够被自动、可靠地释放，从而有效防止了内存泄漏、悬空指针等常见的内存管理错误。 unique_ptr 对象本身是一个轻量级的封装，它在大多数情况下与原始指针具有相同的性能开销，但提供了更强的安全保障和更清晰的语义。它通过禁止拷贝操作，只允许移动操作，来强制实现所有权的唯一性，即在任何时刻，只有一个 unique_ptr 可以拥有并负责释放一个特定的对象。 1.1.1 独占所有权语义unique_ptr 的”独占所有权”是其最核心的特性。这意味着一个 unique_ptr 对象对其所指向的资源拥有唯一的控制权。当 unique_ptr 被销毁时（例如，离开其作用域），它所管理的对象也会被自动销毁。 这种机制确保了资源的释放是确定性的，并且与 unique_ptr 的生命周期紧密绑定。为了实现这种独占性，unique_ptr 明确禁止了拷贝构造函数和拷贝赋值运算符。任何试图复制一个 unique_ptr 的操作都会导致编译错误。 然而，所有权是可以被转移（Transfer） 的。C++11 引入的移动语义（Move Semantics） 为 unique_ptr 提供了完美的支持。通过 std::move()，可以将一个 unique_ptr 的所有权转移给另一个 unique_ptr，而原指针则会被置为空（nullptr），不再拥有任何资源。 1234std::unique_ptr&lt;int&gt; ptr1(new int(42));// std::unique_ptr&lt;int&gt; ptr2 = ptr1; // 错误：拷贝构造函数被删除std::unique_ptr&lt;int&gt; ptr2 = std::move(ptr1); // 合法：所有权从 ptr1 转移到 ptr2// 此时 ptr1 为 nullptr，ptr2 拥有对 int(42) 的所有权 这种所有权的转移机制，使得 unique_ptr 在函数参数传递和返回值中非常有用，可以清晰地表达所有权的转移意图。 1.1.2 RAII（资源获取即初始化）原则的体现unique_ptr 是 RAII（Resource Acquisition Is Initialization） 原则的绝佳范例。RAII 是一种编程范式，它将资源的生命周期与对象的生命周期绑定。 资源（如内存、文件句柄、锁等）在对象的构造函数中获取，并在对象的析构函数中释放。unique_ptr 完美地遵循了这一原则：当通过 new 创建一个对象并用其初始化 unique_ptr 时，资源被获取；当 unique_ptr 对象离开其作用域并被销毁时，其析构函数会自动调用，从而释放所管理的资源。 这种机制极大地简化了资源管理，尤其是在处理异常时。即使在函数执行过程中抛出异常，导致函数提前退出，局部作用域中的 unique_ptr 对象依然会被正确销毁，其管理的资源也会被安全释放，从而避免了因异常处理不当而导致的资源泄漏。 1.1.3 与原始指针的区别与优势与原始指针相比，unique_ptr 提供了显著的优势： 安全性：原始指针需要程序员手动调用 delete 来释放内存，这极易出错，容易导致内存泄漏（忘记 delete）或悬空指针（delete 后继续使用）。unique_ptr 通过自动管理内存，从根本上消除了这类问题。 清晰的语义：通过其独占所有权的特性，代码的意图变得更加明确：一个 unique_ptr 明确表示它拥有并负责释放该对象。这使得代码更易于理解和维护。 扩展性：unique_ptr 还支持自定义删除器，使其能够管理不仅仅是通过 new 分配的资源，例如文件句柄、网络连接等，进一步扩展了其应用范围。 性能：尽管 unique_ptr 提供了这些额外的功能，但其性能开销极小，在大多数情况下与原始指针相当。 特性 原始指针 (T*) std::unique_ptr 所有权 不明确，需要程序员手动管理 独占所有权，通过移动语义转移 生命周期 不明确，需要手动 delete 与 unique_ptr 对象的生命周期绑定，自动释放 内存泄漏风险 高，容易忘记 delete 无，自动释放 悬垂指针风险 高，delete 后指针仍有效 低，释放后 unique_ptr 变为 nullptr 重复释放风险 高，可能多次 delete 同一指针 无，所有权唯一 拷贝 支持浅拷贝，可能导致多个指针指向同一资源 不支持拷贝，仅支持移动 大小 与平台指针大小相同 通常与原始指针大小相同（得益于空基类优化） 自定义删除器 需要手动调用 支持在模板参数中指定 1.2 模板类定义与参数std::unique_ptr 是一个类模板，其定义位于 &lt;memory&gt; 头文件中。它有两种形式：一种用于管理单个对象，另一种用于管理动态分配的数组。 1.2.1 模板参数 T：被管理的对象类型第一个模板参数 T 指定了 unique_ptr 所管理的对象的类型。例如，std::unique_ptr&lt;int&gt; 管理一个 int 类型的对象，而 std::unique_ptr&lt;MyClass&gt; 则管理一个 MyClass 类型的对象。 在 unique_ptr 的内部，这个类型被别名为 element_type。对于数组特化版本 unique_ptr&lt;T[]&gt;，T 表示数组元素的类型。 需要注意的是，如果 T 是一个引用类型，那么实例化 unique_ptr&lt;T&gt; 的程序是格式错误的。 1.2.2 模板参数 Deleter：自定义删除器类型第二个模板参数 Deleter 是一个可选参数，用于指定一个可调用对象（函数对象或函数指针），该对象定义了如何销毁被管理的资源。这个类型在 unique_ptr 内部被别名为 deleter_type。 默认情况下，Deleter 是 std::default_delete&lt;T&gt;，它简单地调用 delete 来释放内存。然而，通过提供自定义的删除器，unique_ptr 可以管理任何需要特殊清理逻辑的资源。 Deleter 必须是一个可调用对象，能够接受一个 unique_ptr::pointer 类型的参数。将 Deleter 作为模板参数是实现零开销抽象的关键，因为它允许编译器在编译时内联删除器的调用，从而避免了运行时的额外开销。 1.2.3 默认删除器 std::default_deletestd::default_delete&lt;T&gt; 是 unique_ptr 的默认删除器。它是一个无状态的函数对象（functor），其 operator() 简单地调用 delete 来销毁其管理的对象。 对于数组特化版本 unique_ptr&lt;T[]&gt;，default_delete&lt;T[]&gt; 会调用 delete[] 来释放数组。 default_delete 的设计非常高效，因为它是一个空类（empty class），不包含任何数据成员。这使得 unique_ptr 可以利用空基类优化（EBO） 技术，在不增加额外内存开销的情况下存储删除器。 当使用默认删除器时，unique_ptr 的大小通常与原始指针相同，保证了其轻量级的特性。 需要注意的是，如果使用 default_delete，被管理的类型 T 在 unique_ptr 的析构函数、移动赋值运算符和 reset 成员函数被实例化的地方必须是完整类型（complete type）。 1.3 内部类型定义为了方便使用和提高代码的可读性，unique_ptr 定义了几个内部类型别名。 1.3.1 element_type：被管理对象的类型别名element_type 是模板参数 T 的别名。它代表了 unique_ptr 所管理的对象的类型。例如，在 std::unique_ptr&lt;int&gt; 中，element_type 就是 int。 这个别名在编写泛型代码时非常有用，因为它允许在不明确知道 T 的具体类型的情况下，引用被管理对象的类型。 1.3.2 deleter_type：删除器的类型别名deleter_type 是模板参数 Deleter 的别名。它代表了用于销毁被管理对象的删除器的类型。例如，在 std::unique_ptr&lt;int, MyDeleter&gt; 中，deleter_type 就是 MyDeleter。 这个别名同样有助于编写泛型代码，使得代码可以灵活地处理不同类型的删除器。 1.3.3 pointer：指针类型别名pointer 是一个更复杂的类型别名，它定义了 unique_ptr 内部使用的指针类型。它的定义如下： 如果 Deleter 类型（去除引用后）有一个名为 pointer 的内部类型，那么 unique_ptr::pointer 就是这个类型。 否则，pointer 就是 T*。 这个设计允许 Deleter 指定一个”智能”指针类型（例如，一个用于共享内存的偏移指针），而不仅仅是普通的 T*。这使得 unique_ptr 能够与更广泛的资源管理方案集成。 pointer 类型必须满足 NullablePointer 的要求，这意味着它可以被默认构造、与 nullptr 进行比较，并且可以像原始指针一样使用。 2. unique_ptr 的常用接口与用法unique_ptr 提供了一套丰富的接口，用于管理其生命周期和所有权。这些接口的设计旨在提供安全、高效且直观的资源管理方式。 2.1 构造与析构unique_ptr 的构造函数和析构函数是其资源管理功能的核心。 2.1.1 默认构造函数：创建空的 unique_ptrunique_ptr 的默认构造函数创建一个不拥有任何对象的 unique_ptr，其内部指针被初始化为 nullptr。 1std::unique_ptr&lt;int&gt; ptr; // ptr 不管理任何对象，get() 返回 nullptr 这个构造函数是 noexcept 的，并且要求删除器类型 Deleter 是可默认构造的，且其构造过程不抛出异常。 此外，unique_ptr 还有一个接受 std::nullptr_t 的构造函数，其效果与默认构造函数相同，这使得 unique_ptr 可以被显式地初始化为 nullptr。 2.1.2 带指针的构造函数：接管原始指针unique_ptr 提供了一个显式的构造函数，用于从一个原始指针接管所有权。 1std::unique_ptr&lt;int&gt; ptr(new int(42)); // ptr 现在拥有这个 int 对象 这个构造函数将传入的指针存储在 unique_ptr 内部，并负责在析构时释放它。这个构造函数也是 noexcept 的，并且要求删除器是可默认构造的。 需要注意的是，一旦将一个原始指针交给 unique_ptr 管理，就不应该再手动 delete 它，也不应该再使用这个原始指针，因为 unique_ptr 会在其生命周期结束时自动处理释放。 2.1.3 移动构造函数：转移所有权unique_ptr 的核心特性之一是其移动语义。它提供了移动构造函数，允许将所有权从一个 unique_ptr 转移给另一个。 123std::unique_ptr&lt;int&gt; ptr1(new int(42));std::unique_ptr&lt;int&gt; ptr2(std::move(ptr1)); // 所有权从 ptr1 转移到 ptr2// 现在 ptr1 为 nullptr，ptr2 拥有该对象 移动构造函数是 noexcept 的，并且要求删除器是可移动构造的（如果 Deleter 不是引用类型）。 此外，unique_ptr 还支持从一个不同类型的 unique_ptr 进行移动构造，只要源指针类型可以隐式转换为目标指针类型，并且源删除器类型可以转换为目标删除器类型。这种跨类型的移动构造在处理继承层次结构时非常有用。 2.1.4 析构函数：自动释放资源unique_ptr 的析构函数是其 RAII 机制的关键。当一个 unique_ptr 对象被销毁时，其析构函数会检查它是否拥有一个对象。如果拥有，析构函数会调用其存储的删除器来销毁该对象。 例如，对于默认删除器，它会调用 delete。析构函数要求 get_deleter()(get()) 这个表达式是合法的，并且不会抛出异常。 这种自动释放机制确保了即使在发生异常的情况下，资源也能被正确清理，从而极大地提高了代码的健壮性。 2.2 所有权管理核心接口unique_ptr 提供了一组核心接口，用于在不转移所有权的情况下观察和操作其管理的对象。 2.2.1 get()：获取原始指针（不转移所有权）get() 成员函数返回 unique_ptr 内部存储的原始指针，但不会转移所有权。调用 get() 后，unique_ptr 仍然拥有该对象，并将在其析构时负责释放它。 这个函数通常用于需要与只接受原始指针的旧版 API 进行交互的场景。 123std::unique_ptr&lt;int&gt; ptr(new int(42));int* raw_ptr = ptr.get(); // raw_ptr 指向该对象，但 ptr 仍然拥有它// 不要对 raw_ptr 调用 delete get() 是 noexcept 的，并且返回的指针类型是 unique_ptr::pointer。 2.2.2 release()：释放所有权并返回原始指针release() 成员函数会断开 unique_ptr 与其管理对象之间的关联，并返回该对象的原始指针。调用 release() 后，unique_ptr 变为空（get() == nullptr），而调用者则获得了该对象的所有权，并需要负责在适当的时候手动释放它。 123std::unique_ptr&lt;int&gt; ptr(new int(42));int* raw_ptr = ptr.release(); // ptr 变为空，raw_ptr 现在拥有该对象// 现在必须对 raw_ptr 调用 delete: delete raw_ptr; release() 是 noexcept 的，它首先将内部指针设置为 nullptr，然后返回其先前的值。 这个函数在需要将所有权转移给一个不接受 unique_ptr 的函数或 API 时非常有用。 2.2.3 reset()：重置管理的对象reset() 成员函数用于替换 unique_ptr 当前管理的对象。它首先会销毁当前管理的对象（如果存在），然后接管新传入的指针的所有权。 123std::unique_ptr&lt;int&gt; ptr(new int(42));ptr.reset(new int(100)); // 销毁旧的 int(42)，并管理新的 int(100)ptr.reset(); // 销毁 int(100)，并使 ptr 变为空 reset() 可以接受一个原始指针参数，也可以不带参数（默认为 nullptr）。如果传入的指针与当前管理的指针相同，reset() 会先存储新指针，然后删除旧指针，这可能导致传入的指针被立即删除。 reset() 是 noexcept 的，并且要求删除器的调用不抛出异常。 2.2.4 swap()：交换两个 unique_ptr 的管理对象swap() 成员函数用于交换两个 unique_ptr 对象的内容，包括它们管理的指针和删除器。 123std::unique_ptr&lt;int&gt; ptr1(new int(42));std::unique_ptr&lt;int&gt; ptr2(new int(100));ptr1.swap(ptr2); // 现在 ptr1 管理 int(100)，ptr2 管理 int(42) swap() 是 noexcept 的，并且通常具有常数时间复杂度。 此外，标准库还提供了一个非成员的 swap 函数模板，专门用于 unique_ptr，它也会调用成员 swap 函数。 2.3 其他重要操作符与函数除了上述核心接口，unique_ptr 还提供了一些操作符和辅助函数，使其使用起来更像一个原始指针。 2.3.1 operator&#x3D;：移动赋值运算符unique_ptr 提供了移动赋值运算符，允许将一个 unique_ptr 的所有权转移给另一个。与移动构造函数类似，它会销毁左侧 unique_ptr 当前管理的对象，然后接管右侧 unique_ptr 的所有权。 1234std::unique_ptr&lt;int&gt; ptr1(new int(42));std::unique_ptr&lt;int&gt; ptr2;ptr2 = std::move(ptr1); // 所有权从 ptr1 转移到 ptr2// 现在 ptr1 为 nullptr，ptr2 拥有该对象 移动赋值运算符是 noexcept 的，并且要求删除器是可移动赋值的（如果 Deleter 不是引用类型）。 它还支持从一个不同类型的 unique_ptr 进行移动赋值，只要满足相应的类型转换要求。 2.3.2 operator* 与 operator-&gt;：解引用操作对于非数组版本的 unique_ptr，提供了 operator* 和 operator-&gt;，使其可以像原始指针一样进行解引用。 operator* 返回对所管理对象的引用。 operator-&gt; 返回内部存储的原始指针，允许访问对象的成员。 123std::unique_ptr&lt;MyClass&gt; ptr(new MyClass());ptr-&gt;doSomething(); // 调用 MyClass 的成员函数(*ptr).doSomething(); // 等价于上一行 这些操作符使得 unique_ptr 的使用体验与原始指针非常相似，但提供了额外的安全保障。 2.3.3 operator bool：检查是否管理对象unique_ptr 提供了一个转换到 bool 类型的操作符，用于检查其是否管理一个对象。如果 unique_ptr 不为空（即 get() != nullptr），则返回 true；否则返回 false。 1234std::unique_ptr&lt;int&gt; ptr(new int(42));if (ptr) &#123; // ptr 管理一个对象&#125; 这个操作符使得检查 unique_ptr 的状态变得非常直观和方便。 2.3.4 get_deleter()：获取删除器get_deleter() 成员函数返回一个对 unique_ptr 内部存储的删除器的引用。这允许在运行时访问和修改删除器的状态（如果删除器不是无状态的）。 123auto deleter = [](int* p) &#123; std::cout &lt;&lt; &quot;Deleting int\\n&quot;; delete p; &#125;;std::unique_ptr&lt;int, decltype(deleter)&gt; ptr(new int(42), deleter);ptr.get_deleter()(new int(100)); // 手动调用删除器 get_deleter() 有两个重载版本，一个返回非常量引用，另一个返回常量引用。 3. unique_ptr 的内部实现逻辑unique_ptr 的高效性和强大功能源于其精巧的内部实现，特别是其对空基类优化（EBO）的利用。 3.1 核心数据结构unique_ptr 的内部实现主要围绕两个核心数据成员：一个用于存储被管理对象的原始指针，另一个用于存储删除器。 3.1.1 存储原始指针unique_ptr 必须存储一个指向其管理对象的原始指针。这个指针的类型由 unique_ptr::pointer 定义，通常是 T*，但在使用自定义删除器时可能是其他类型。 这个指针是 unique_ptr 的核心，所有对管理对象的访问都通过这个指针进行。 3.1.2 存储删除器unique_ptr 还需要存储其删除器。删除器的类型是 Deleter，它可以是任何可调用对象。 将删除器作为 unique_ptr 的一部分，使得 unique_ptr 能够灵活地管理各种需要特殊清理逻辑的资源。然而，如果删除器是一个有状态的、非空的对象，直接将其作为 unique_ptr 的成员会增加 unique_ptr 的大小，从而引入额外的内存开销。 为了解决这个问题，unique_ptr 采用了空基类优化技术。 3.2 空基类优化（EBO）空基类优化（Empty Base Optimization, EBO） 是 C++ 中一项重要的优化技术，它允许一个空类（即没有非静态数据成员的类）作为基类时，不占用任何额外的内存空间。unique_ptr 利用 EBO 来优化其内部存储，特别是当使用默认的无状态删除器时。 3.2.1 压缩空指针（Compressed Pair）技术为了实现 EBO，unique_ptr 的实现通常依赖于一个名为 compressed_pair（或类似名称）的内部辅助类。这个类模板旨在存储两个对象，并利用 EBO 来消除其中一个对象（如果它是空的）的存储开销。 compressed_pair 的实现通常涉及模板特化和继承。它会检查两个模板参数的类型，如果其中一个类型是空的且不是 final 的，它就会将该类型作为基类，而另一个类型作为成员变量。这样，如果删除器是一个空类（如 default_delete），它就不会占用任何额外的内存空间。 3.2.2 优化空删除器的存储开销在 unique_ptr 的典型实现中，其唯一的成员变量是一个 compressed_pair&lt;pointer, deleter_type&gt;。当使用默认的 default_delete&lt;T&gt; 时，deleter_type 是一个空类。compressed_pair 会检测到这一点，并将 deleter_type 作为其基类。由于 EBO，这个基类不会增加 compressed_pair 的大小。 因此，unique_ptr 的最终大小就只有一个指针的大小，与原始指针完全相同，实现了零开销抽象。 这种优化是 unique_ptr 将 Deleter 作为模板参数而非构造函数参数的关键原因，也是其性能优于 shared_ptr 的重要因素之一。 3.3 移动语义的实现unique_ptr 的独占所有权语义是通过禁用拷贝操作并启用移动操作来实现的。 3.3.1 删除拷贝构造函数和拷贝赋值运算符为了确保所有权的唯一性，unique_ptr 明确地将拷贝构造函数和拷贝赋值运算符声明为 delete。这意味着任何试图复制 unique_ptr 的代码都会在编译时失败，从而从根本上防止了所有权的共享。 3.3.2 实现移动构造函数和移动赋值运算符unique_ptr 提供了移动构造函数和移动赋值运算符，它们允许将所有权从一个 unique_ptr 转移给另一个。这些函数的实现通常涉及以下步骤： 从源 unique_ptr 中获取原始指针（通过 release()）。 将获取的指针存储到目标 unique_ptr 中。 将源 unique_ptr 的删除器移动或复制到目标 unique_ptr 中。 确保源 unique_ptr 在操作后变为空（get() == nullptr）。 通过这种方式，unique_ptr 实现了所有权的明确转移，保证了在任何时候都只有一个 unique_ptr 实例负责管理一个特定的资源。 4. unique_ptr 与 shared_ptr 的区别unique_ptr 和 shared_ptr 是 C++ 标准库中两种主要的智能指针，它们都用于自动管理动态分配的资源，但其底层所有权模型、性能和适用场景有显著不同。 4.1 所有权模型对比所有权模型是 unique_ptr 和 shared_ptr 最根本的区别。 4.1.1 unique_ptr 的独占所有权unique_ptr 遵循独占所有权模型。在任何给定时刻，只有一个 unique_ptr 实例可以拥有一个特定的对象。当这个 unique_ptr 被销毁时，它所拥有的对象也会被销毁。 这种模型保证了资源释放的确定性和即时性。所有权的转移只能通过移动语义（std::move）来完成，这使得所有权的转移在代码中非常明确。 4.1.2 shared_ptr 的共享所有权与引用计数shared_ptr 遵循共享所有权模型。多个 shared_ptr 实例可以同时拥有同一个对象。为了跟踪有多少个 shared_ptr 正在共享一个对象，shared_ptr 内部使用了一个引用计数器。 每当一个新的 shared_ptr 被创建并指向该对象时，引用计数加一；每当一个 shared_ptr 被销毁或重置时，引用计数减一。当引用计数变为零时，意味着没有 shared_ptr 再拥有该对象，此时对象会被自动销毁。 这种模型提供了更大的灵活性，但也引入了额外的开销和潜在的循环引用问题。 4.2 复制与移动语义对比所有权模型的差异直接导致了两者在复制和移动语义上的不同。 4.2.1 unique_ptr 仅支持移动unique_ptr 明确禁止拷贝，只支持移动。拷贝构造函数和拷贝赋值运算符被声明为 delete，以防止所有权的意外共享。移动操作则高效地转移所有权，源 unique_ptr 在操作后会变为空。 4.2.2 shared_ptr 支持复制和移动shared_ptr 既支持拷贝也支持移动。 拷贝：当一个 shared_ptr 被拷贝时，新的 shared_ptr 会与原 shared_ptr 共享同一个对象，并且引用计数会加一。 移动：当一个 shared_ptr 被移动时，所有权会从源 shared_ptr 转移到目标 shared_ptr，源 shared_ptr 会变为空。与拷贝不同，移动操作不会修改引用计数，因此性能更高。 4.3 性能与开销对比性能和开销是选择 unique_ptr 还是 shared_ptr 时需要考虑的重要因素。 4.3.1 unique_ptr 的轻量级特性unique_ptr 是一个非常轻量级的智能指针。在大多数情况下，它的大小与原始指针相同，因为它利用了空基类优化来消除无状态删除器的存储开销。 它的操作（如构造、析构、移动）通常与原始指针的操作一样高效，没有额外的运行时开销。 4.3.2 shared_ptr 的引用计数开销shared_ptr 的性能开销相对较大。这主要源于其内部的引用计数机制。 内存开销：shared_ptr 需要为每个管理的对象分配一个额外的控制块（control block）来存储引用计数和弱引用计数。这使得 shared_ptr 本身的大小通常是原始指针的两倍（一个指针指向对象，一个指针指向控制块）。 运行时开销：引用计数的增减必须是原子操作，以保证线程安全。这些原子操作会带来一定的性能开销，尤其是在多线程环境下频繁创建和销毁 shared_ptr 时。 特性 std::unique_ptr std::shared_ptr 所有权模型 独占所有权 共享所有权 复制语义 不支持（被删除） 支持（增加引用计数） 移动语义 支持（转移所有权） 支持（转移所有权，不增加计数） 内存开销 一个指针大小（轻量级） 两个指针大小 + 控制块（较重） 性能开销 极小 引用计数的原子操作开销 循环引用 不存在 可能导致内存泄漏（需配合 weak_ptr） 适用场景 独占资源、性能敏感、工厂函数 共享资源、复杂数据结构、异步操作 4.4 适用场景对比基于以上区别，unique_ptr 和 shared_ptr 适用于不同的场景。 4.4.1 何时选择 unique_ptr 独占所有权：当资源的生命周期应该由单个所有者明确管理时，应首选 unique_ptr。例如，在工厂函数中创建并返回一个对象，或者在类中作为成员变量管理一个动态分配的子对象。 性能敏感：在对性能要求较高的场景下，应优先使用 unique_ptr，因为它没有引用计数的开销。 RAII 封装：当需要封装任何需要特殊清理逻辑的资源（如文件句柄、数据库连接等）时，unique_ptr 配合自定义删除器是一个非常好的选择。 4.4.2 何时选择 shared_ptr 共享所有权：当多个对象需要共享同一个资源，并且资源的生命周期应该由最后一个使用者决定时，应使用 shared_ptr。例如，在复杂的对象关系图中，或者在缓存系统中。 需要复制：当需要将一个指针传递给多个接收者，并且每个接收者都可能延长该对象的生命周期时，shared_ptr 的拷贝语义非常有用。 与 weak_ptr 配合使用：当需要打破循环引用，或者需要观察一个对象但不想影响其生命周期时，shared_ptr 可以与 weak_ptr 配合使用。 5. unique_ptr 的实际应用场景unique_ptr 凭借其高效、安全和语义清晰的特性，在现代 C++ 编程中有着广泛的应用。 5.1 管理动态分配的对象unique_ptr 最常见的用途是管理通过 new 动态分配的对象，确保其内存能够被自动释放。 5.1.1 作为类成员变量（pImpl 惯用法）在类设计中，将 unique_ptr 作为成员变量是实现 pImpl（Pointer to Implementation） 惯用法的理想选择。pImpl 惯用法通过将实现细节隐藏在一个不透明的指针后面，来减少编译依赖和接口的稳定性。 使用 unique_ptr 作为这个指针，可以自动管理实现对象的生命周期，无需在类的析构函数中手动 delete。 1234567891011121314151617181920// MyClass.hclass MyClass &#123;public: MyClass(); ~MyClass(); void doSomething();private: class Impl; // 前向声明 std::unique_ptr&lt;Impl&gt; pImpl;&#125;;// MyClass.cppclass MyClass::Impl &#123;public: void doSomething() &#123; /* ... */ &#125;&#125;;MyClass::MyClass() : pImpl(std::make_unique&lt;Impl&gt;()) &#123;&#125;MyClass::~MyClass() = default; // 自动生成，会调用 unique_ptr 的析构函数void MyClass::doSomething() &#123; pImpl-&gt;doSomething(); &#125; 这种方式不仅简化了代码，还提供了强大的异常安全保障。 5.1.2 在函数中传递和返回所有权unique_ptr 非常适合在函数之间传递和返回动态分配对象的所有权。 作为返回值：工厂函数可以返回一个 unique_ptr，将新创建对象的所有权转移给调用者。 123std::unique_ptr&lt;MyClass&gt; createMyClass() &#123; return std::make_unique&lt;MyClass&gt;();&#125; 作为参数：函数可以通过值或右值引用的方式接收 unique_ptr，以接管所有权。 123void processMyClass(std::unique_ptr&lt;MyClass&gt; ptr) &#123; // ptr 现在拥有该对象&#125; // ptr 离开作用域，对象被销毁 这种方式使得所有权的转移在代码中非常明确，避免了所有权的混淆。 5.2 管理动态数组unique_ptr 提供了对动态数组的特化版本 unique_ptr&lt;T[]&gt;，用于管理通过 new[] 分配的数组。 5.2.1 使用 unique_ptr&lt;T[]&gt;unique_ptr&lt;T[]&gt; 的特化版本重载了 operator[]，并确保在析构时调用 delete[] 而不是 delete。 1std::unique_ptr&lt;int[]&gt; arr(new int[10]); 这使得管理动态数组变得像管理单个对象一样简单和安全。 5.2.2 访问数组元素对于 unique_ptr&lt;T[]&gt;，可以使用 operator[] 来访问数组的元素，就像使用普通数组一样。 123std::unique_ptr&lt;int[]&gt; arr(new int[10]);arr[0] = 42;std::cout &lt;&lt; arr[0] &lt;&lt; std::endl; 这种方式比使用 std::vector 更轻量，但功能也更有限，因为它不支持动态调整大小。 5.3 与标准库容器结合使用unique_ptr 可以作为标准库容器（如 std::vector）的元素类型，用于创建多态对象容器。 5.3.1 在 vector 中存储 unique_ptr由于 unique_ptr 不可拷贝，但可移动，因此可以将其存储在 std::vector 中。这使得可以创建一个拥有其元素的容器。 123std::vector&lt;std::unique_ptr&lt;MyClass&gt;&gt; vec;vec.push_back(std::make_unique&lt;MyClass&gt;());vec.push_back(std::make_unique&lt;MyClass&gt;()); 当 vec 被销毁时，其所有元素（即 unique_ptr 对象）也会被销毁，从而自动释放所有管理的 MyClass 对象。 5.3.2 实现多态容器通过将基类的 unique_ptr 存储在容器中，可以创建一个多态容器，用于存储不同派生类的对象。 123std::vector&lt;std::unique_ptr&lt;Base&gt;&gt; poly_vec;poly_vec.push_back(std::make_unique&lt;Derived1&gt;());poly_vec.push_back(std::make_unique&lt;Derived2&gt;()); 当 poly_vec 被销毁时，所有 Derived1 和 Derived2 对象都会被自动正确地销毁。 需要注意的是，如果通过基类 unique_ptr 删除派生类对象，基类的析构函数必须是虚函数（virtual），否则会导致未定义行为。 5.4 自定义删除器的应用unique_ptr 的第二个模板参数 Deleter 使其能够管理任何需要特殊清理逻辑的资源，而不仅仅是通过 new 分配的内存。 5.4.1 管理文件句柄（FILE*）这是一个经典的自定义删除器应用场景。C 标准库中的文件操作使用 FILE* 句柄，需要通过 fclose 来关闭。 12345678910111213141516// 定义一个自定义删除器auto file_deleter = [](std::FILE* fp) &#123; if (fp) &#123; std::fclose(fp); std::cout &lt;&lt; &quot;File closed.&quot; &lt;&lt; std::endl; &#125;&#125;;// 创建一个 unique_ptr 来管理 FILE*using unique_file_ptr = std::unique_ptr&lt;std::FILE, decltype(file_deleter)&gt;;unique_file_ptr file(std::fopen(&quot;example.txt&quot;, &quot;r&quot;), file_deleter);if (file) &#123; // 使用文件...&#125;// 当 file 离开作用域时，file_deleter 会被自动调用，关闭文件 5.4.2 管理其他需要特殊清理的资源除了文件句柄，自定义删除器还可以用于管理各种其他资源，例如： 网络套接字：删除器可以调用 close 或 closesocket 来关闭套接字。 数据库连接：删除器可以调用相应的 API 来断开数据库连接。 互斥锁：删除器可以调用 unlock 来释放锁，确保即使在异常情况下锁也能被正确释放。 共享内存：删除器可以调用 shm_unlink 或类似的函数来清理共享内存段。 通过这种方式，unique_ptr 成为了一个通用的 RAII 包装器，可以用于管理任何需要显式清理的资源，极大地提高了代码的健壮性和安全性。","link":"","tags":[{"name":"C++","slug":"C","permalink":"https://lyroom.github.io/tags/C/"},{"name":"智能指针","slug":"智能指针","permalink":"https://lyroom.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"name":"unique_ptr","slug":"unique-ptr","permalink":"https://lyroom.github.io/tags/unique-ptr/"}]},{"title":"C++朝花夕拾-assert宏用法","date":"2025-09-22T13:40:37.000Z","path":"2025/09/22/C-朝花夕拾-assert宏用法/","text":"刚学了 C++ 的 异常机制（throw &#x2F; try &#x2F; catch），现在问到 assert —— 它和异常看似都是“报错”，但用途、时机、行为完全不同！ 🧩 C++ 中的 assert —— 通俗易懂 + 详细对比异常机制 ✅ 一句话总结：assert 是“调试断言”，用于开发阶段捕捉“绝不应该发生”的程序错误；而 异常 是“运行时错误处理”，用于处理“可能发生”的意外情况。 📌 一、什么是 assert？assert 是一个宏（macro），定义在头文件 &lt;cassert&gt; 中（C 语言是 &lt;assert.h&gt;）。 它的作用是： “如果条件为假（false），程序立即终止，并输出错误信息” 🧪 基本语法：123#include &lt;cassert&gt;assert(条件表达式); 🎯 二、assert 的典型用法（调试神器！）✅ 1. 检查函数参数（前置条件）12345678910111213#include &lt;cassert&gt;#include &lt;iostream&gt;using namespace std;double divide(double a, double b) &#123; assert(b != 0.0); // 开发时确保调用者不会传 0 return a / b;&#125;int main() &#123; cout &lt;&lt; divide(10.0, 2.0) &lt;&lt; endl; // ✅ 正常 cout &lt;&lt; divide(10.0, 0.0) &lt;&lt; endl; // ❌ 程序崩溃！输出错误位置&#125; 💥 如果 b == 0.0，程序会立即终止，并输出类似： 1Assertion failed: b != 0.0, file test.cpp, line 6 ✅ 2. 检查函数返回值或中间状态（不变式）12345678910int factorial(int n) &#123; assert(n &gt;= 0); // 阶乘不能对负数计算！ int result = 1; for (int i = 1; i &lt;= n; ++i) &#123; result *= i; assert(result &gt; 0); // 防止整数溢出（调试用） &#125; return result;&#125; ✅ 3. 检查指针不为空（防崩溃）1234void printLength(const char* str) &#123; assert(str != nullptr); // 确保调用者没传空指针 cout &lt;&lt; &quot;长度: &quot; &lt;&lt; strlen(str) &lt;&lt; endl;&#125; ⚙️ 三、assert 的底层机制（重点！）assert 是一个预处理宏，它的行为取决于是否定义了 NDEBUG 宏： 编译模式 NDEBUG 是否定义 assert 行为 Debug 模式 ❌ 未定义 ✅ 检查条件，失败则终止 Release 模式 ✅ 已定义 ❌ 被完全移除，无开销 🔍 举个例子：12345678910111213// 编译时：// Debug: g++ -g -o test test.cpp// Release: g++ -DNDEBUG -O2 -o test test.cpp#include &lt;cassert&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; int x = -1; assert(x &gt;= 0); // Debug 模式下会崩溃，Release 模式下这行代码不存在！ cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl;&#125; ✅ 设计哲学：assert 只用于开发调试阶段，捕捉程序员的逻辑错误；发布版本中完全消失，不影响性能！ 🆚 四、assert vs 异常 —— 核心区别表 特性 assert 异常 (throw/catch) 用途 捕捉“程序员错误”（不该发生的） 处理“运行时错误”（可能发生的） 是否可恢复 ❌ 程序直接终止 ✅ 可捕获并恢复 是否影响发布版 ❌ Release 模式下被移除 ✅ 始终存在 性能开销 ❌ Debug 有开销，Release 无开销 ✅ 无异常时开销极小，抛异常时较大 适用阶段 开发调试阶段 开发 + 发布阶段 典型场景 参数检查、不变式、内部逻辑错误 文件打不开、网络断开、用户输入错误 能否被忽略 ❌ 不能（直接 crash） ✅ 能（但不推荐） 🚫 五、什么时候不该用 assert？❌ 1. 检查用户输入123int age;cin &gt;&gt; age;assert(age &gt;= 0); // ❌ 错误！用户可能输入负数，这是“可预期错误” ✅ 应该用异常或错误码： 123if (age &lt; 0) &#123; throw invalid_argument(&quot;年龄不能为负数！&quot;);&#125; ❌ 2. 检查文件&#x2F;网络等外部资源12FILE* f = fopen(&quot;data.txt&quot;, &quot;r&quot;);assert(f != nullptr); // ❌ 错误！文件可能不存在，这是“运行时异常” ✅ 应该用异常： 123if (!f) &#123; throw runtime_error(&quot;无法打开文件 data.txt&quot;);&#125; ❌ 3. 在析构函数中使用（危险！）123~MyClass() &#123; assert(ptr != nullptr); // ❌ 如果 assert 失败 → 程序终止，可能掩盖更严重问题&#125; ✅ 应记录日志或静默处理。 ✅ 六、什么时候该用 assert？ 场景 示例 函数前置条件 assert(index &gt;= 0 &amp;&amp; index &lt; size); 循环不变式 assert(total &gt;= 0); 指针有效性 assert(p != nullptr); 算法内部状态 assert(sorted == true); 测试驱动开发 assert(result == expected); 🎯 黄金法则：“如果这个条件为假，说明我的代码有 bug —— 用 assert”“如果这个条件为假，是用户&#x2F;环境的问题 —— 用异常” 🧰 七、自定义断言（高级技巧）你可以定义自己的断言宏，添加更多信息： 1234567891011121314151617#include &lt;iostream&gt;#include &lt;cstdlib&gt;#define MY_ASSERT(expr, msg) \\ do &#123; \\ if (!(expr)) &#123; \\ std::cerr &lt;&lt; &quot;Assertion failed: &quot; &lt;&lt; #expr \\ &lt;&lt; &quot; (&quot; &lt;&lt; msg &lt;&lt; &quot;) &quot; \\ &lt;&lt; &quot;in &quot; &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt; std::endl; \\ std::abort(); \\ &#125; \\ &#125; while(0)void test() &#123; int x = -1; MY_ASSERT(x &gt;= 0, &quot;x 应该是非负数&quot;); &#125; 🖨️ 输出： 1Assertion failed: x &gt;= 0 (x 应该是非负数) in test.cpp:15 📊 八、assert 在大型项目中的使用（Google &#x2F; Microsoft 风格） Google C++ Style Guide：鼓励使用 assert 检查内部不变式 Microsoft：在 Windows 内核开发中大量使用 NT_ASSERT 游戏引擎（如 Unreal）：check() 宏（类似 assert） ✅ 原则：“Fail Fast” —— 尽早崩溃，比隐藏 bug 导致后续灾难要好！ 🧠 九、考考你！下面代码在 Debug 和 Release 模式下分别输出什么？ 1234567891011121314#include &lt;cassert&gt;#include &lt;iostream&gt;using namespace std;int getValue() &#123; cout &lt;&lt; &quot;getValue 被调用了！&quot; &lt;&lt; endl; return -1;&#125;int main() &#123; assert(getValue() &gt;= 0); cout &lt;&lt; &quot;程序继续...&quot; &lt;&lt; endl; return 0;&#125; ✅ Debug 模式： 123getValue 被调用了！Assertion failed: getValue() &gt;= 0, file test.cpp, line 10💥 程序终止，不会输出“程序继续...” ✅ Release 模式： 1程序继续... 🌟 解释：Release 模式下 assert(...) 整行被预处理器删除，getValue() 根本不会被调用！ 🧩 十、static_assert —— 编译期断言（C++11）除了运行时 assert，C++11 引入了 编译期断言： 1static_assert(sizeof(int) == 4, &quot;int 必须是 4 字节！&quot;); 在编译时检查条件 失败则编译报错 常用于模板元编程、类型检查 12345template&lt;typename T&gt;void process() &#123; static_assert(std::is_integral_v&lt;T&gt;, &quot;T 必须是整数类型！&quot;); // ...&#125; 📌 总结：assert 使用口诀 ✅ 用 assert： 检查“程序员的错” 调试阶段捕捉 bug 内部逻辑、不变式、前置条件 “Fail Fast” 原则 ❌ 不用 assert： 用户输入、外部资源、可恢复错误 发布版本中需要处理的错误 析构函数中 🔄 用异常： 处理“可能发生”的运行时错误 需要恢复或通知用户的场景 库函数、API 设计 🎯 终极建议： 把 assert 当作你的“代码保镖”，在开发阶段帮你揪出隐藏的逻辑错误；把 异常 当作你的“错误处理专家”，在运行时优雅应对各种意外情况。 两者配合，让你的 C++ 程序既健壮又安全！","link":"","tags":[{"name":"C++","slug":"C","permalink":"https://lyroom.github.io/tags/C/"},{"name":"朝花夕拾","slug":"朝花夕拾","permalink":"https://lyroom.github.io/tags/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"},{"name":"assert","slug":"assert","permalink":"https://lyroom.github.io/tags/assert/"},{"name":"断言","slug":"断言","permalink":"https://lyroom.github.io/tags/%E6%96%AD%E8%A8%80/"}]},{"title":"C++朝花夕拾-异常机制","date":"2025-09-22T12:49:47.000Z","path":"2025/09/22/C-朝花夕拾-异常机制/","text":"🚨 C++ 异常机制 —— 从零到精通 💡 一句话总结：“异常 &#x3D; 程序运行时发生的‘意外情况’，C++ 用 throw, try, catch 三剑客来处理它，让程序不崩溃、能恢复、有尊严地报错。” 🎯 一、为什么要学异常？—— 先看“没有异常”的痛苦👶 传统错误处理方式：返回错误码（return -1, NULL, false…）123456789101112131415int divide(int a, int b) &#123; if (b == 0) &#123; return -1; // 用 -1 表示“除零错误” &#125; return a / b;&#125;int main() &#123; int result = divide(10, 0); if (result == -1) &#123; cout &lt;&lt; &quot;错误：除数不能为0！&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;结果是：&quot; &lt;&lt; result &lt;&lt; endl; &#125;&#125; ❗ 问题来了： 如果忘记检查返回值？→ 程序逻辑错乱！ 如果函数要返回“正常值”和“错误码”？→ 设计混乱！ 如果错误发生在“深层调用”中？→ 一层层往上传，代码臃肿！ 🌟 二、异常机制登场 —— throw, try, catchC++ 异常机制三大关键字： 关键字 作用 throw 抛出一个异常（相当于“报警”） try 包裹可能出错的代码（“监控区”） catch 捕获并处理异常（“接警处理”） 🎬 生活化比喻：餐厅点餐 你点了一份“牛排” → try &#123; 点餐(); &#125; 厨房发现“牛肉卖完了” → throw &quot;没牛肉了！&quot;; 服务员接到通知 → catch (string msg) &#123; 告诉顾客 + 推荐别的菜 &#125; 顾客不会因为“没牛肉”掀桌子（程序不崩溃），而是优雅换菜 😊 🧩 三、基本语法 + 示例✅ 1. 抛出异常：throw 表达式;123456789void checkAge(int age) &#123; if (age &lt; 0) &#123; throw &quot;年龄不能为负数！&quot;; // 抛出字符串异常 &#125; if (age &gt; 150) &#123; throw 999; // 抛出整数异常（不推荐，但合法） &#125; cout &lt;&lt; &quot;年龄合法：&quot; &lt;&lt; age &lt;&lt; endl;&#125; 💡 throw 可以抛出 任何类型：int, string, char*, 自定义类对象等✅ 推荐抛出 异常类对象（后文讲） ✅ 2. 捕获异常：try &#123; ... &#125; catch (...) &#123; ... &#125;123456789101112int main() &#123; try &#123; checkAge(-5); // 可能抛异常 &#125; catch (const char* msg) &#123; // 捕获 char* 类型异常 cout &lt;&lt; &quot;捕获到异常：&quot; &lt;&lt; msg &lt;&lt; endl; &#125; catch (int code) &#123; // 捕获 int 类型异常 cout &lt;&lt; &quot;错误代码：&quot; &lt;&lt; code &lt;&lt; endl; &#125; cout &lt;&lt; &quot;程序继续运行...&quot; &lt;&lt; endl; return 0;&#125; 🖨️ 输出： 12捕获到异常：年龄不能为负数！程序继续运行... 🧱 四、异常的传播（栈展开 —— Stack Unwinding）❓ 问题：如果异常发生在“函数调用深处”，怎么办？1234567891011121314151617181920void func3() &#123; throw &quot;func3 出错了！&quot;;&#125;void func2() &#123; func3(); // func3 抛异常 cout &lt;&lt; &quot;这行不会执行！&quot; &lt;&lt; endl;&#125;void func1() &#123; func2();&#125;int main() &#123; try &#123; func1(); // 异常从 func3 一路“冒泡”到 main &#125; catch (const char* msg) &#123; cout &lt;&lt; &quot;main 捕获：&quot; &lt;&lt; msg &lt;&lt; endl; &#125;&#125; 🔄 栈展开过程： func3() 抛异常 func3() 立刻退出 → 析构局部对象 func2() 退出 → 析构局部对象 func1() 退出 → 析构局部对象 main() 的 catch 捕获异常 → 程序继续 ✅ 关键点：异常会沿着调用栈“向上传播”，直到被捕获，中间函数全部退出（局部对象被析构）！ 🧰 五、标准异常类（推荐使用！）C++ 标准库提供了一套异常类（在 &lt;stdexcept&gt; 中），建议优先使用： 异常类 用途 std::runtime_error 运行时错误（如文件打不开） std::logic_error 逻辑错误（如传参错误） std::invalid_argument 无效参数 std::out_of_range 越界访问（如 vector） ✅ 示例：使用标准异常12345678910111213141516171819202122#include &lt;stdexcept&gt;#include &lt;iostream&gt;using namespace std;double divide(double a, double b) &#123; if (b == 0.0) &#123; throw invalid_argument(&quot;除数不能为零！&quot;); &#125; return a / b;&#125;int main() &#123; try &#123; cout &lt;&lt; divide(10.0, 0.0) &lt;&lt; endl; &#125; catch (const invalid_argument&amp; e) &#123; cout &lt;&lt; &quot;参数错误：&quot; &lt;&lt; e.what() &lt;&lt; endl; &#125; catch (const exception&amp; e) &#123; // 基类，捕获所有标准异常 cout &lt;&lt; &quot;标准异常：&quot; &lt;&lt; e.what() &lt;&lt; endl; &#125; return 0;&#125; 📌 .what() 是 std::exception 的虚函数，返回错误描述字符串。 🛠️ 六、自定义异常类（高级用法）你可以继承 std::exception 或其子类，创建自己的异常： 123456789101112131415161718192021class MyException : public std::exception &#123;private: string msg;public: MyException(const string&amp; m) : msg(m) &#123;&#125; const char* what() const noexcept override &#123; return msg.c_str(); &#125;&#125;;void riskyFunction() &#123; throw MyException(&quot;我的自定义异常！&quot;);&#125;int main() &#123; try &#123; riskyFunction(); &#125; catch (const MyException&amp; e) &#123; cout &lt;&lt; &quot;捕获自定义异常：&quot; &lt;&lt; e.what() &lt;&lt; endl; &#125;&#125; ✅ 自定义异常 &#x3D; 更精确的错误分类 + 更丰富的错误信息！ ⚠️ 七、异常规范（C++11 起已废弃，了解即可）老版本 C++ 支持异常规范： 12void func() throw(int); // 只允许抛 int 异常（已废弃）void func() throw(); // 不允许抛任何异常（已废弃） 🚫 C++11 起废弃，改用 noexcept： 123void safeFunc() noexcept &#123; // 承诺不抛异常 // 如果这里 throw 了 → std::terminate() 程序终止！&#125; 🔄 八、重新抛出异常（throw;）在 catch 块中，你可以“处理一部分，再抛出去”： 12345678910111213141516void handlePartially() &#123; try &#123; riskyOperation(); &#125; catch (...) &#123; cout &lt;&lt; &quot;记录日志：发生异常！&quot; &lt;&lt; endl; throw; // 重新抛出当前异常（不改变类型！） &#125;&#125;int main() &#123; try &#123; handlePartially(); &#125; catch (const char* msg) &#123; cout &lt;&lt; &quot;最终处理：&quot; &lt;&lt; msg &lt;&lt; endl; &#125;&#125; ✅ 用途：日志记录、资源清理、部分处理后交给上层。 🧹 九、异常安全与 RAII（重要！）❗ 异常可能导致资源泄漏！12345void badExample() &#123; int* p = new int[1000]; riskyFunction(); // 如果这里抛异常 → p 永远不会 delete！ delete[] p;&#125; ✅ 解决方案：RAII + 智能指针123456#include &lt;memory&gt;void goodExample() &#123; auto p = std::make_unique&lt;int[]&gt;(1000); // 智能指针 riskyFunction(); // 即使抛异常，p 也会自动析构！ // 不用手动 delete&#125; 🌟 RAII 原则：资源获取即初始化，绑定对象生命周期 → 异常时自动释放！ 🚫 十、不要在析构函数中抛异常！123456class BadClass &#123;public: ~BadClass() &#123; throw &quot;析构函数抛异常！&quot;; // ❌ 危险！ &#125;&#125;; 💥 如果析构函数抛异常，且当前正在处理另一个异常 → std::terminate() 程序直接终止！ ✅ 正确做法：在析构函数中用 try-catch 吞掉异常，或记录日志。 📊 十一、异常的性能开销 无异常时：现代编译器优化得很好，几乎无开销 抛异常时：栈展开、查找 catch 块 → 开销较大（比 if-else 慢很多） ✅ 建议：异常用于“真正异常”的情况（如文件打不开、网络断开），不要用于控制流程！ 🧠 十二、异常 vs 错误码 —— 如何选择？ 场景 推荐方式 频繁发生的“可预期”错误（如用户输错） ✅ 错误码 罕见、严重、不可恢复的错误（如内存不足、文件损坏） ✅ 异常 库函数、API 设计 ✅ 异常（更安全、不易忽略） 性能敏感代码（游戏循环、高频交易） ✅ 错误码 🎓 十三、完整实战示例123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;stdexcept&gt;using namespace std;class ConfigFile &#123; string filename;public: ConfigFile(const string&amp; fname) : filename(fname) &#123;&#125; string load() &#123; ifstream file(filename); if (!file.is_open()) &#123; throw runtime_error(&quot;无法打开配置文件: &quot; + filename); &#125; string content, line; while (getline(file, line)) &#123; content += line + &quot;\\n&quot;; &#125; return content; &#125;&#125;;int main() &#123; ConfigFile cfg(&quot;config.txt&quot;); try &#123; string data = cfg.load(); cout &lt;&lt; &quot;配置内容：\\n&quot; &lt;&lt; data &lt;&lt; endl; &#125; catch (const runtime_error&amp; e) &#123; cerr &lt;&lt; &quot;加载失败：&quot; &lt;&lt; e.what() &lt;&lt; endl; return 1; &#125; catch (...) &#123; cerr &lt;&lt; &quot;未知错误！&quot; &lt;&lt; endl; return 2; &#125; cout &lt;&lt; &quot;程序正常结束。&quot; &lt;&lt; endl; return 0;&#125; 📌 总结：C++ 异常机制核心要点 概念 说明 throw 抛出异常，中断当前函数 try-catch 捕获并处理异常，防止程序崩溃 栈展开 异常向上传播，中间函数退出，局部对象析构 标准异常 优先使用 std::exception 及其子类 自定义异常 继承 std::exception，重写 what() noexcept 声明函数不抛异常（C++11） throw; 重新抛出当前异常 RAII 用对象管理资源，确保异常时自动释放 析构函数 绝对不要抛异常！ 性能 异常用于“真异常”，不要滥用 🧩 考考你！下面代码会输出什么？ 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;struct A &#123; A() &#123; cout &lt;&lt; &quot;A 构造&quot; &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;A 析构&quot; &lt;&lt; endl; &#125;&#125;;void func() &#123; A a; throw &quot;出错了！&quot;; cout &lt;&lt; &quot;这行不会执行&quot; &lt;&lt; endl;&#125;int main() &#123; try &#123; func(); &#125; catch (const char* msg) &#123; cout &lt;&lt; &quot;捕获：&quot; &lt;&lt; msg &lt;&lt; endl; &#125; return 0;&#125; ✅ 答案： 123A 构造A 析构捕获：出错了！ 🌟 解释：即使 throw 中断了 func()，局部对象 a 仍会析构！这就是 栈展开 + RAII 的威力！","link":"","tags":[{"name":"C++","slug":"C","permalink":"https://lyroom.github.io/tags/C/"},{"name":"朝花夕拾","slug":"朝花夕拾","permalink":"https://lyroom.github.io/tags/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"}]},{"title":"C++朝花夕拾-🌊 浅拷贝 vs 🏗️ 深拷贝","date":"2025-09-22T07:36:25.000Z","path":"2025/09/22/C-朝花夕拾-🌊-浅拷贝-vs-🏗️-深拷贝/","text":"🌊 浅拷贝 vs 🏗️ 深拷贝 —— 一文看懂！ 🧍‍♂️ 举个生活例子：复印钥匙想象你有一把家门钥匙🔑，你把它“拷贝”给朋友： 浅拷贝 &#x3D; 你直接把原钥匙给了朋友 → 你们俩用的是同一把钥匙👉 他丢了钥匙，你也进不了门！👉 他配了一把新钥匙，你也多了一把！ 深拷贝 &#x3D; 你去配了一把全新的、独立的钥匙给朋友 → 你们各有各的钥匙👉 他丢了，不影响你👉 他换锁了，你家门还是原样！ 💡 在 C++ 中，这“钥匙”就是——指针指向的堆内存当你有一个类，里面包含指针成员（比如 int* p;），拷贝对象时： 浅拷贝：只复制指针的值（地址）→ 两个对象指向同一块内存 深拷贝：复制指针指向的内容 → 两个对象各自拥有独立的内存 📜 默认拷贝是“浅拷贝”C++ 编译器默认提供的拷贝构造函数和赋值运算符，都是浅拷贝！ 👇 看个浅拷贝出问题的例子：123456789101112131415161718192021222324class Student &#123;public: int* score; // 指向堆内存的指针 Student(int s) &#123; score = new int(s); // 在堆上分配内存 &#125; // 编译器默认生成浅拷贝构造函数： // Student(const Student&amp; other) &#123; // score = other.score; // 只复制地址！ // &#125; ~Student() &#123; delete score; // 释放内存 &#125;&#125;;int main() &#123; Student s1(90); Student s2 = s1; // 浅拷贝！s2.score 和 s1.score 指向同一块内存 // 当 s1 和 s2 析构时...&#125; // 💥 程序崩溃！同一块内存被 delete 了两次！ 💥 这就是“浅拷贝陷阱”——重复释放内存，程序崩溃！ ✅ 深拷贝：自己动手，丰衣足食！我们手动写拷贝构造函数和赋值运算符，实现深拷贝： 123456789101112131415161718192021222324252627282930313233343536class Student &#123;public: int* score; Student(int s) &#123; score = new int(s); &#125; // 👇 深拷贝构造函数 Student(const Student&amp; other) &#123; score = new int(*other.score); // 分配新内存，复制内容 &#125; // 👇 深拷贝赋值运算符 Student&amp; operator=(const Student&amp; other) &#123; if (this == &amp;other) return *this; // 自我赋值检查 delete score; // 先释放旧内存 score = new int(*other.score); // 再深拷贝 return *this; &#125; ~Student() &#123; delete score; &#125;&#125;;int main() &#123; Student s1(90); Student s2 = s1; // 深拷贝！各自有独立内存 // 修改 s2 不影响 s1 *s2.score = 100; cout &lt;&lt; *s1.score &lt;&lt; endl; // 输出 90 ✅ cout &lt;&lt; *s2.score &lt;&lt; endl; // 输出 100 ✅&#125; // 析构时各自释放自己的内存，安全！✅ 🧩 一句话总结 浅拷贝 &#x3D; 复印地址（共享资源，危险！）深拷贝 &#x3D; 复印内容（独立资源，安全！） 🚨 什么时候需要深拷贝？✅ 当你的类中包含： 指针成员（int*, char*, MyClass* 等） 动态分配的资源（new, malloc, 文件句柄等） 任何“独占资源” —— 不能共享的东西！ 📌 口诀：“三五法则”如果你需要自定义析构函数、拷贝构造、赋值运算符中的任何一个，很可能三个都需要写！ 🎁 额外小贴士：现代 C++ 更推荐用“智能指针”或“值语义”比如： 123456class Student &#123;public: std::unique_ptr&lt;int&gt; score; // 自动管理内存，拷贝时编译器会报错（不可拷贝） // 或者 int score; // 直接存值，根本不需要指针 → 默认拷贝就是“深拷贝”&#125;; ✅ 优先使用 std::string, std::vector, std::unique_ptr 等 RAII 类型，避免手动管理内存！ 🧠 考考你！下面代码会出问题吗？ 12345678910class Cat &#123;public: std::string name; Cat(std::string n) : name(n) &#123;&#125;&#125;;int main() &#123; Cat c1(&quot;Tom&quot;); Cat c2 = c1; // 浅拷贝还是深拷贝？&#125; ✅ 答案：深拷贝！因为 std::string 内部已经帮你实现了深拷贝（或写时复制），你无需操心！","link":"","tags":[{"name":"C++","slug":"C","permalink":"https://lyroom.github.io/tags/C/"},{"name":"朝花夕拾","slug":"朝花夕拾","permalink":"https://lyroom.github.io/tags/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"},{"name":"浅拷贝","slug":"浅拷贝","permalink":"https://lyroom.github.io/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"name":"深拷贝","slug":"深拷贝","permalink":"https://lyroom.github.io/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"}]},{"title":"C++朝花夕拾-using关键字","date":"2025-09-22T07:12:49.000Z","path":"2025/09/22/C-朝花夕拾-using关键字/","text":"📘 C++ 中 using 关键字的用法详解在 C++ 中，using 关键字功能强大且用途多样，从 C++11 开始更是得到了显著增强。它主要用于简化代码、提高可读性、解决继承中的函数隐藏问题等。以下是 using 在 C++ 中的主要用法详解： 1️⃣ 引入命名空间成员（Namespace Members）1.1 引入单个成员123456789101112#include &lt;iostream&gt;#include &lt;vector&gt;using std::cout;using std::endl;using std::vector;int main() &#123; vector&lt;int&gt; v = &#123;1, 2, 3&#125;; cout &lt;&lt; v[0] &lt;&lt; endl; // 不用写 std:: return 0;&#125; ✅ 推荐：比 using namespace std; 更安全，避免命名污染。 1.2 引入整个命名空间（谨慎使用）1234567using namespace std;int main() &#123; cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl; vector&lt;int&gt; v; // ...&#125; ⚠️ 警告：不要在头文件或大型项目中使用，容易引起命名冲突！ 2️⃣ 定义类型别名（Type Alias）— 替代 typedefC++11 起，using 可用于定义类型别名，语法更直观，功能更强。 2.1 基本类型别名123using IntPtr = int*;using String = std::string;using Callback = void(*)(int); 等价于： 123typedef int* IntPtr;typedef std::string String;typedef void(*Callback)(int); ✅ using 语法更符合“赋值”语义：别名 = 原类型 2.2 模板别名（typedef 无法做到！）12345678910template&lt;typename T&gt;using Vec = std::vector&lt;T&gt;;Vec&lt;int&gt; v1; // std::vector&lt;int&gt;Vec&lt;std::string&gt; v2; // std::vector&lt;std::string&gt;template&lt;typename T&gt;using MapString = std::map&lt;std::string, T&gt;;MapString&lt;int&gt; m; // std::map&lt;std::string, int&gt; 🌟 这是 using 最强大的优势之一 —— 支持模板别名！ 3️⃣ 在派生类中引入基类成员（解决函数隐藏）当派生类定义了与基类同名的函数时，基类所有重载版本都会被隐藏。使用 using 可显式引入。 12345678910111213141516171819class Base &#123;public: void func(int x) &#123; cout &lt;&lt; &quot;Base::func(int)&quot; &lt;&lt; endl; &#125; void func(double x) &#123; cout &lt;&lt; &quot;Base::func(double)&quot; &lt;&lt; endl; &#125;&#125;;class Derived : public Base &#123;public: using Base::func; // 引入所有重载版本 ✅ void func(char x) &#123; cout &lt;&lt; &quot;Derived::func(char)&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; Derived d; d.func(10); // Base::func(int) d.func(3.14); // Base::func(double) d.func(&#x27;a&#x27;); // Derived::func(char)&#125; ❌ 如果没有 using Base::func;，则 d.func(10) 会报错 —— 因为基类函数被隐藏了！ 4️⃣ 改变继承成员的访问权限（C++11）在派生类中，可以用 using 提升或改变从基类继承的成员的访问级别。 123456789101112131415161718class Base &#123;protected: void protectedFunc() &#123; cout &lt;&lt; &quot;Protected&quot; &lt;&lt; endl; &#125;public: void publicFunc() &#123; cout &lt;&lt; &quot;Public&quot; &lt;&lt; endl; &#125;&#125;;class Derived : private Base &#123; // 私有继承public: using Base::publicFunc; // 保持 public using Base::protectedFunc; // 提升为 public ✅&#125;;int main() &#123; Derived d; d.publicFunc(); // ✅ d.protectedFunc(); // ✅ 现在可以访问了！&#125; 📌 注意：不能用 using 降低访问权限（比如 public → private），只能提升或保持。 5️⃣ 在模板中引入依赖基类成员（解决编译错误）在模板派生类中访问基类成员时，有时编译器无法识别，需用 using 或 this-&gt; 显式声明。 123456789101112131415template&lt;typename T&gt;class Base &#123;protected: T value;&#125;;template&lt;typename T&gt;class Derived : public Base&lt;T&gt; &#123;public: using Base&lt;T&gt;::value; // ✅ 显式引入依赖基类成员 void print() &#123; std::cout &lt;&lt; value &lt;&lt; std::endl; // 现在可以访问 &#125;&#125;; 💡 原因：在模板中，基类是依赖名称（dependent name），编译器默认不查找基类作用域。 📋 总结：using 的五大用途 用途 示例 说明 1️⃣ 引入命名空间成员 using std::cout; 避免写 std::，更安全 2️⃣ 定义类型别名 using IntVec = std::vector&lt;int&gt;; 替代 typedef，支持模板 3️⃣ 引入基类函数 using Base::func; 解决派生类函数隐藏问题 4️⃣ 改变访问权限 using Base::func;（在 public 下） 提升继承成员访问级别 5️⃣ 模板中引入基类成员 using Base&lt;T&gt;::member; 解决依赖名称查找问题 💡 最佳实践建议 ✅ 优先使用 using 定义类型别名（特别是模板别名） ✅ 在类中使用 using 解决函数重载隐藏问题 ✅ 在 .cpp 文件中局部使用 using namespace xxx;，避免在头文件中使用 ✅ 在模板派生类中，对基类成员使用 using 或 this-&gt; 避免编译错误 ❌ 不要用 using 降低访问权限（语法不允许） 🧠 小测验下面代码能否编译通过？ 1234567891011121314class A &#123;public: void foo(int);&#125;;class B : public A &#123;public: void foo(double);&#125;;int main() &#123; B b; b.foo(5); // ❓ 会调用哪个？&#125; ❌ 编译错误！A::foo(int) 被 B::foo(double) 隐藏了。✅ 解决方案：在 B 中添加 using A::foo;","link":"","tags":[{"name":"c++","slug":"c","permalink":"https://lyroom.github.io/tags/c/"},{"name":"朝花夕拾","slug":"朝花夕拾","permalink":"https://lyroom.github.io/tags/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"}]},{"title":"C++朝花夕拾-缺省","date":"2025-09-19T09:51:05.000Z","path":"2025/09/19/C-朝花夕拾-缺省/","text":"📘 c++朝花夕拾-缺省 在C++中，“缺省”（Default）是一个核心概念，主要指系统、编译器或程序员预先设定的默认值或行为，当用户未显式提供具体值或指令时，程序将自动采用这些预设值。以下从多个维度系统解析“缺省”的含义、应用场景及注意事项： 🔑 1. 缺省的核心含义 本质：缺省是“预设的默认状态”，用于简化代码编写、减少冗余参数传递，同时保持灵活性，甚至以下可以把“缺省”两个字改成“默认”也不影响逻辑。 关键特性： 可覆盖性：用户可显式提供值覆盖缺省设置。 上下文依赖性：缺省行为可能因编译器、标准版本或代码上下文而异。 隐式生效：在未明确指定时自动激活，无需额外代码。 🧩 2. 主要应用场景（1）函数默认参数 定义：在函数声明或定义时为参数指定默认值，调用时可省略该参数。 规则： 默认参数需从右向左连续指定（如void func(int a, int b=2, int c=3)合法，但void func(int a=1, int b, int c=3)非法）。 默认参数通常在函数声明中指定（而非定义），以避免多重定义冲突。 示例：1234567void print(int value = 42) &#123; // 缺省参数 value=42 std::cout &lt;&lt; value;&#125;int main() &#123; print(); // 输出 42（使用缺省值） print(100); // 输出 100（覆盖缺省值）&#125; （2）类与结构体的默认成员初始化 C++11及以上：可在类&#x2F;结构体中直接为成员变量指定默认值。 优势：避免未初始化导致的未定义行为，简化构造函数。 示例：123456struct Point &#123; int x = 0; // 缺省值 0 int y = 0; // 缺省值 0&#125;;Point p1; // p1.x=0, p1.y=0Point p2&#123;5&#125;; // p2.x=5, p2.y=0（覆盖 x 的缺省值） （3）模板参数的默认类型 定义：模板参数可指定默认类型，使模板实例化时无需显式提供类型。 规则：默认类型需符合模板的语义要求（如可复制、可比较等）。 示例：12345678template &lt;typename T = int&gt; // 缺省模板参数 T=intclass Box &#123; T data;public: T getValue() const &#123; return data; &#125;&#125;;Box&lt;&gt; b1; // 等价于 Box&lt;int&gt; b1;Box&lt;double&gt; b2; // 覆盖缺省类型 （4）构造函数与特殊成员函数的默认生成 **= default**：显式要求编译器生成默认的构造函数、析构函数、拷贝构造函数、拷贝赋值运算符等。 适用场景：当类需要默认行为（如浅拷贝）但未显式定义时。 示例：12345class MyClass &#123;public: MyClass() = default; // 缺省构造函数 ~MyClass() = default; // 缺省析构函数&#125;; （5）标准库容器的默认行为 容器初始化：如std::vector&lt;int&gt; v;默认构造空向量，std::map&lt;int, std::string&gt; m;默认构造空映射。 算法默认参数：如std::sort(v.begin(), v.end())默认使用&lt;比较元素。 ⚠️ 3. 缺省值的潜在风险与注意事项（1）函数重载歧义 当多个函数具有相同参数数量但不同默认参数时，调用可能因默认参数导致歧义。 示例：123void log(int level);void log(int level, const std::string &amp;message = &quot;&quot;);log(1); // 编译错误：调用存在歧义（匹配第一个还是第二个？） （2）默认值变更的影响 修改函数的默认参数值可能破坏现有代码（如从func(int a=1)改为func(int a=2)）。 需谨慎对待公共API的默认参数，避免频繁变更。 （3）性能与可读性权衡 过度使用默认参数可能隐藏函数依赖关系，降低代码可读性。 对于大型对象，默认参数可能导致不必要的拷贝（需结合引用传递优化）。12void process(const std::string&amp; name = &quot;default&quot;); // ✅ 推荐void process(std::string name = &quot;default&quot;); // ❌ 可能拷贝 （4）与const的交互 默认参数不能是局部变量或需要计算的表达式（需为编译时常量或可求值表达式）。 示例：12int calc();void func(int x = calc()); // 错误：默认参数需为常量表达式 (5) 默认参数与头文件管理 默认参数写在头文件声明中，而非 .cpp 实现文件 否则不同编译单元看到不同默认值 → 链接错误或行为不一致 📈 4. 缺省与C++标准的演变 C++98&#x2F;03：支持函数默认参数、类成员默认初始化（需在构造函数中完成）。 C++11：引入类成员直接默认初始化（如int x=0;）、= default语法、模板默认参数。 C++17&#x2F;20：进一步强化常量表达式、结构化绑定等特性，使缺省值更安全、灵活。 🎯 5. 实际应用中的最佳实践 明确性优先：在关键函数或公共接口中，避免过度依赖默认参数，可通过重载提供更清晰的接口。 文档化：对默认参数的行为进行文档说明，尤其是非直观的逻辑。 测试覆盖：确保默认参数路径被单元测试覆盖，避免因缺省值导致逻辑错误。 避免全局状态：默认参数不应依赖全局变量或可变状态，以免引发难以追踪的bug。 ✅ 总结C++中的“缺省”是预设默认值或行为的机制，广泛应用于函数参数、类成员初始化、模板实例化等场景。它通过减少冗余代码提升开发效率，但需注意潜在风险（如重载歧义、性能影响）。合理使用缺省机制需结合具体场景，权衡灵活性、可读性与维护成本，同时遵循C++标准的演进方向，确保代码的健壮性与可扩展性。","link":"","tags":[{"name":"c++","slug":"c","permalink":"https://lyroom.github.io/tags/c/"},{"name":"朝花夕拾","slug":"朝花夕拾","permalink":"https://lyroom.github.io/tags/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"}]},{"title":"C++朝花夕拾-形参VS实参","date":"2025-09-19T09:33:13.000Z","path":"2025/09/19/C-朝花夕拾-形参VS实参/","text":"📘 c++朝花夕拾-形参VS实参在C++中，形参（形式参数）和实参（实际参数）是函数调用机制的核心概念，二者的区别及使用场景需结合C++的语法特性（如值传递、引用传递、指针传递等）深入理解。以下从定义、区别、使用场景及特殊案例四方面系统解析： 1. 定义与本质 形参（形式参数）在函数定义时声明的参数，是函数接口的“占位符”，用于描述函数需要接收的数据类型、结构及数量。示例： 123void printSum(int a, int b) &#123; // a、b 是形参 std::cout &lt;&lt; a + b;&#125; 实参（实际参数）在函数调用时实际传递给函数的值或变量，是具体的数据，用于替换形参执行函数逻辑。示例： 123printSum(3, 5); // 3 和 5 是实参int x = 10, y = 20;printSum(x, y); // x 和 y 是实参 2. 核心区别 对比维度 形参 实参 存在阶段 函数定义时声明（编译期确定） 函数调用时传递（运行时确定） 作用范围 仅在函数内部有效（局部作用域） 由外部作用域决定（如全局变量、局部变量） 生命周期 函数调用时创建，调用结束销毁 由外部作用域决定（如全局变量持续存在） 内存占用 不占用实际内存（符号引用） 占用具体内存（存储实际值或地址） 修改影响 修改形参仅影响函数内部逻辑 修改实参可能影响外部数据（需看传递方式） 类型要求 需明确指定类型（如int、float） 需与形参类型兼容（或可隐式转换） 3. 传递方式与影响C++中参数传递的本质是数据复制或地址传递，具体分为以下三种方式： （1）值传递（Pass by Value） 机制：实参将值复制给形参，函数内修改形参不影响外部实参。 适用场景：不可变类型（如int、double、struct）或需保护实参不被修改的场景。 示例： 12345678void changeValue(int num) &#123; num = 100; // 修改形参，不影响外部实参&#125;int main() &#123; int x = 5; changeValue(x); std::cout &lt;&lt; x; // 输出 5（x 未被修改）&#125; （2）引用传递（Pass by Reference） 机制：实参将引用（地址）传递给形参，函数内修改形参会直接影响外部实参。 适用场景：可变类型（如数组、类对象）或需在函数内修改外部数据的场景（如交换两个变量）。 示例： 12345678910void swap(int &amp;a, int &amp;b) &#123; // a、b 是引用形参 int temp = a; a = b; b = temp;&#125;int main() &#123; int x = 5, y = 10; swap(x, y); // 传递变量引用 std::cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y; // 输出 10 5（x、y 被交换）&#125; （3）指针传递（Pass by Pointer） 机制：实参将指针（地址）传递给形参，函数内通过指针修改指向的内存。 适用场景：需动态内存操作、数组遍历或兼容C语言接口的场景。 示例： 12345678910void modifyArray(int *arr, int size) &#123; for (int i = 0; i &lt; size; i++) &#123; arr[i] *= 2; // 通过指针修改外部数组 &#125;&#125;int main() &#123; int arr[3] = &#123;1, 2, 3&#125;; modifyArray(arr, 3); // 传递数组首地址 // arr 变为 &#123;2, 4, 6&#125;&#125; 4. 使用场景与最佳实践 使用形参的场景 定义函数接口时，明确需要哪些输入（如double calculateArea(double length, double width)）。 设置默认值（C++11起支持= default或显式默认值），使参数可省略（如void greet(const std::string &amp;name = &quot;游客&quot;)）。 限制参数类型（通过类型提示）或使用const保护形参不被修改（如void process(const std::vector&lt;int&gt; &amp;data)）。 实现函数重载（通过形参类型、数量或顺序区分同名函数）。 使用实参的场景 调用函数时，传递具体值（如calculateArea(5.0, 3.0)）。 传递变量、表达式或函数结果（如calculateArea(a+b, c*2)）。 传递可变对象（如数组、类对象）以修改外部数据（需使用引用或指针）。 传递动态内存地址（如int *ptr = new int[10]; modifyArray(ptr, 10)）。 5. 特殊案例与注意事项 形参与实参的“错位” 数量不匹配：调用时实参数量少于形参会报错（如error: too few arguments to function）；过多则可能被忽略或需使用可变参数（如...）。 类型不匹配：如形参要求int，但实参传递float，可能触发隐式转换或编译错误（需看具体类型兼容性）。 引用与指针的陷阱：若形参为引用类型（如int &amp;a），实参必须是可修改的左值（如变量），不能是常量或临时值（如changeValue(10)会报错）。 const形参与实参 使用const修饰形参可防止函数内意外修改参数（如void print(const std::string &amp;str)）。 实参为const变量时，需确保形参也为const（如const int x = 5; print(x)需形参为const int）。 函数重载与形参C++支持通过形参类型、数量或顺序实现函数重载（如void log(int); void log(double);），但需注意重载解析规则（如类型提升、引用折叠）。 总结形参是函数接口的“设计图”，定义了函数需要的数据结构；实参是“实际材料”，在调用时填充形参的占位符。二者通过传递方式（值、引用、指针）关联，影响数据的复制、修改及内存占用。在C++中，合理选择传递方式（如对大型对象使用引用传递避免拷贝）、利用const保护数据、通过函数重载设计灵活接口，是高效编程的关键。","link":"","tags":[{"name":"c++","slug":"c","permalink":"https://lyroom.github.io/tags/c/"},{"name":"朝花夕拾","slug":"朝花夕拾","permalink":"https://lyroom.github.io/tags/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"}]},{"title":"智能指针","date":"2025-09-19T04:53:17.000Z","path":"2025/09/19/智能指针/","text":"哈哈哈","link":"","tags":[{"name":"智能指针","slug":"智能指针","permalink":"https://lyroom.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"name":"c++","slug":"c","permalink":"https://lyroom.github.io/tags/c/"},{"name":"朝花夕拾","slug":"朝花夕拾","permalink":"https://lyroom.github.io/tags/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"},{"name":"指针","slug":"指针","permalink":"https://lyroom.github.io/tags/%E6%8C%87%E9%92%88/"}]},{"title":"C++ 程序运行时内存布局","date":"2025-09-19T04:26:31.000Z","path":"2025/09/19/C-程序运行时内存布局/","text":"🧠 C++ 程序运行时内存布局 📌 适用于理解全局变量、栈、堆、静态区、代码段的存储位置与生命周期。 本文我们主要介绍 C++ 程序运行时内存布局，以及变量存储位置，包括栈、堆、静态存储区等，并附上 ASCII 图解。 🖼️ 内存布局示意图（ASCII 图）1234567891011121314151617181920212223242526高地址┌──────────────────────────────┐ ← 栈顶（向低地址增长）│ Stack (栈) ││ - 局部变量 ││ - 函数参数 ││ - 返回地址 │├──────────────────────────────┤│ │ ← 未使用内存（空闲区）│ （Free Memory） ││ │├──────────────────────────────┤│ Heap (堆) │ ← 堆底（向高地址增长）│ - new / malloc 分配的对象 ││ - 动态数据结构 │├──────────────────────────────┤│ .bss 段 ││ - 未初始化的全局/静态变量 │ → int global_uninit;├──────────────────────────────┤│ .data 段 ││ - 已初始化的全局/静态变量 │ → int global_init = 100;│ - static 变量 │├──────────────────────────────┤│ .text 段（代码段） ││ - 函数机器指令 │ → main(), func() 等│ - 只读 │└──────────────────────────────┘ ← 低地址 🔍 各内存区域详解1️⃣ 栈（Stack） 位置：高地址 → 向低地址增长 内容： 局部变量 函数参数 返回地址 管理方式：编译器自动分配&#x2F;释放 生命周期：函数作用域，离开函数后自动释放内存 特点：快、安全、容量小（通常几 MB） 123void func(int a) &#123; //函数参数 ← 存在栈上 int x = 10; // 局部变量 ← 存在栈上&#125; 📌 我们常说栈内存是函数调用栈，函数调用时，参数、局部变量会压入栈中，函数返回时，参数、局部变量会从栈中弹出。 2️⃣ 堆（Heap） 位置：静态区之上，栈之下 → 向高地址增长 内容： new &#x2F; malloc 分配的对象 动态数组、对象、容器底层存储等 管理方式：手动 delete &#x2F; free 或使用智能指针（推荐） 生命周期：由程序员控制 特点：慢、灵活、容量大 1int* p = new int(42); // ← p指向对象在堆，p 指针变量在栈 3️⃣ 静态存储区（Data Segment）➤ .data 段 存放已初始化的全局变量和静态变量 示例： 12int global_var = 999; // ← .datastatic int s = 100; // ← .data ➤ .bss 段 存放未初始化或初始化为 0 的全局&#x2F;静态变量 示例： 12int uninit_global; // ← .bss（默认=0）static int zero_static = 0; // ← 通常优化进 .bss 💡 为什么分 .data 和 .bss？.data 需保存初始值 → 占用可执行文件空间；.bss 只需记录大小 → 加载时清零 → 节省磁盘空间。 4️⃣ 代码段（.text） 内容：程序的机器指令（函数体） 属性：只读、不可修改 示例： 1int main() &#123; return 0; &#125; // ← 函数代码存在 .text 段 🧭 地址增长方向示意1234567891011高地址 ────────────────┐ ↓ 栈向下增长（函数调用压栈） ┌───────────────┤ │ Stack │ ├───────────────┤ │ (Free) │ ├───────────────┤ │ Heap │ └───────────────┤ ↑ 堆向上增长（new 分配内存）低地址 ────────────────┘ ⚠️ 实际地址分布可能因操作系统、编译器、架构略有不同，但“栈向下、堆向上”是常见模型。 🧪 示例代码 + 地址输出示意1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int global_data = 100; // → .dataint global_bss; // → .bssint main() &#123; int local_stack = 200; // → 栈 static int local_static = 300; // → .data（静态局部变量） int* heap_ptr = new int(400); // → 堆对象，指针变量在栈 cout &lt;&lt; &quot;global_data (.data): &quot; &lt;&lt; &amp;global_data &lt;&lt; endl; cout &lt;&lt; &quot;global_bss (.bss) : &quot; &lt;&lt; &amp;global_bss &lt;&lt; endl; cout &lt;&lt; &quot;local_static(.data): &quot; &lt;&lt; &amp;local_static &lt;&lt; endl; cout &lt;&lt; &quot;local_stack (stack): &quot; &lt;&lt; &amp;local_stack &lt;&lt; endl; cout &lt;&lt; &quot;heap object (heap) : &quot; &lt;&lt; heap_ptr &lt;&lt; endl; delete heap_ptr; return 0;&#125; 📌 典型输出地址顺序（64位 Linux 示例）： 12345global_data: 0x555555558010 ← .data（低地址区）global_bss: 0x555555558014 ← .bss（紧邻 .data）local_static: 0x555555558018 ← 静态区local_stack: 0x7fffffffdc8c ← 栈（高地址）heap object: 0x555555579eb0 ← 堆（中间地址） ✅ 总结口诀 “代码垫底，数据居中，堆往上爬，栈往下降，全局静态稳如泰山。” 📚 附：变量存储位置速查表 变量类型 存储位置 生命周期 是否需要手动管理 全局变量 静态区（.data&#x2F;.bss） 整个程序运行期 ❌ 否 静态局部变量 静态区 整个程序运行期 ❌ 否 局部变量 栈 函数作用域 ❌ 自动管理 new &#x2F; malloc 对象 堆 手动控制 ✅ 是（或智能指针） 函数代码 代码段（.text） 整个程序运行期 ❌ 只读不可修改 📌 学习建议：配合调试器（如 GDB）或打印变量地址，亲自观察内存分布，理解更深刻！","link":"","tags":[{"name":"C++","slug":"C","permalink":"https://lyroom.github.io/tags/C/"},{"name":"内存","slug":"内存","permalink":"https://lyroom.github.io/tags/%E5%86%85%E5%AD%98/"}]},{"title":"top命令解析","date":"2025-09-16T04:16:44.000Z","path":"2025/09/16/top命令解析/","text":"🐧 Linux 命令解析（杂记）—— top 命令详解 top 是 Linux 系统中最常用的实时性能监控工具，用于动态查看系统资源使用情况和进程状态。本文将结合真实输出示例，逐行逐列解析其含义，并提供实用诊断技巧。 📊 一、实战示例：top 完整输出123456789101112131415root@armbian:~# toptop - 12:20:30 up 2:23, 1 user, load average: 0.00, 0.01, 0.00Tasks: 236 total, 1 running, 235 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.5 us, 0.9 sy, 0.0 ni, 98.6 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st MiB Mem : 1801.0 total, 132.6 free, 928.2 used, 892.1 buff/cache MiB Swap: 0.0 total, 0.0 free, 0.0 used. 872.8 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 2472 1000 20 0 1299292 49084 32056 S 1.0 2.7 1:25.30 kernel 43581 root 20 0 11628 4768 2884 R 1.0 0.3 0:00.16 top 310 root rt 0 0 0 0 S 0.7 0.0 0:48.36 sugov:0 643 root -2 0 0 0 0 S 0.3 0.0 0:33.40 ksdioirqd/mmc0 1452 root 20 0 3445756 57160 33332 S 0.3 3.1 0:10.08 dockerd 2438 root 20 0 1668 1100 820 S 0.3 0.1 0:25.89 procd 2629 root 20 0 85704 22124 9184 S 0.3 1.2 0:24.84 clouddrive 🧭 二、全局系统信息详解（前5行）🔹 第1行：系统运行时间 &amp; 负载平均值1top - 12:20:30 up 2:23, 1 user, load average: 0.00, 0.01, 0.00 当前时间：12:20:30 运行时间：2小时23分钟（新启动系统） 登录用户：1 个用户（root） 负载平均值： 1分钟：0.00 → 几乎无负载 5分钟：0.01 → 极轻负载 15分钟：0.00 → 非常空闲 ✅ 系统非常健康，无过载风险（即使单核 CPU 也远未满载） 🔹 第2行：任务（进程）统计1Tasks: 236 total, 1 running, 235 sleeping, 0 stopped, 0 zombie 总进程数：236 运行中：1 个（就是 top 自己） 睡眠中：235 个（正常，大部分后台服务都在等待） 僵尸进程：0 → ✅ 健康！ 🔹 第3行：CPU 使用情况1%Cpu(s): 0.5 us, 0.9 sy, 0.0 ni, 98.6 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st 用户空间（us）：0.5% → 用户程序占用极低 内核空间（sy）：0.9% → 系统调用&#x2F;驱动占用也很低 空闲（id）：98.6% → CPU 几乎完全空闲 I&#x2F;O 等待（wa）：0.0% → 无磁盘&#x2F;网络瓶颈 虚拟机偷取（st）：0.0% → 不是虚拟机或未被抢占 ✅ CPU 资源充足，无任何瓶颈 🔹 第4行：物理内存（RAM）使用情况1MiB Mem : 1801.0 total, 132.6 free, 928.2 used, 892.1 buff/cache 总内存：1801 MiB ≈ 1.76 GB 空闲内存：132.6 MiB（⚠️ Linux 会缓存，此值小是正常的） 已使用：928.2 MiB（含缓存） 缓冲&#x2F;缓存：892.1 MiB → 可被快速回收供程序使用 🔹 第5行：Swap 与可用内存1MiB Swap: 0.0 total, 0.0 free, 0.0 used. 872.8 avail Mem 交换分区：未配置（total&#x3D;0）→ 嵌入式&#x2F;轻量系统常见 可用内存（avail Mem）：872.8 MiB → ✅ 内存充足！ 💡 尽管 used=928.2 MiB，但 avail Mem=872.8 MiB，说明系统仍有近一半内存可立即分配给新进程，无内存压力。 📋 三、进程列表各列详解（结合示例） 列名 含义说明 示例解析（来自上方输出） PID 进程 ID 43581 是当前运行的 top 进程 USER 进程所有者 root 或 1000（普通用户） PR 调度优先级。rt &#x3D; 实时优先级 sugov:0 的 PR=rt，是内核调度器线程 NI Nice 值（-20~19），影响优先级 多数为 0，ksdioirqd/mmc0 为 -2（高优先级） VIRT 虚拟内存总量（KiB） kernel 进程：1,299,292 KiB ≈ 1.3 GB RES 常驻物理内存（KiB），真实占用 dockerd 占用 57,160 KiB ≈ 57 MB SHR 共享内存部分 clouddrive 的 9,184 KiB 是共享库内存 S 进程状态：• R&#x3D;运行中• S&#x3D;睡眠• Z&#x3D;僵尸等 top 是 R，其余大多是 S（正常） %CPU CPU 使用率（多核可 &gt;100%） top 和 kernel 各占 1.0%，极低 %MEM 物理内存占用百分比（基于 RES） dockerd 占 3.1%，是当前内存占用最高的进程 TIME+ 累计 CPU 时间（分:秒.百分秒） kernel 已累计使用 1分25秒 CPU 时间 COMMAND 启动命令名 clouddrive, dockerd, procd 等 🛠️ 四、实用技巧与诊断建议🔍 快速定位问题 CPU 高？ → 看 %CPU 列，按 P 排序 内存高？ → 看 %MEM 或 RES，按 M 排序 I&#x2F;O 卡？ → 看全局 wa 是否 &gt; 5% 僵尸进程？ → 看 Tasks 行 zombie 是否 &gt; 0 🎯 交互操作（在 top 界面中） 按键 功能 P 按 CPU 使用率排序 M 按内存使用率排序 T 按运行时间排序 c 显示完整命令行 e &#x2F; E 切换内存单位（进程区&#x2F;全局） 1 显示每个 CPU 核心使用情况 k 杀死指定 PID 进程 q 退出 top ⚠️ 异常关注点（本例中均无） 僵尸进程 → Tasks 行显示 0 zombie ✅ 高 I&#x2F;O 等待 → wa=0.0 ✅ Swap 使用 → Swap used=0.0 ✅ 负载过高 → load average 全部 &lt; 0.02 ✅ 🧵 查看线程（进阶）1top -Hp &lt;PID&gt; 例如： 1top -Hp 2472 # 查看 PID=2472（kernel）的所有线程 用于定位具体哪个线程占用过高。 🧩 五、结合示例的诊断结论 💡 系统整体状态健康，资源充足，无性能瓶颈。 CPU：98.6% 空闲，无压力 内存：可用 872 MiB，无 Swap 使用，无泄漏 负载：接近 0，系统极为空闲 进程：无僵尸，无异常状态 热点进程： dockerd 内存占用最高（3.1%） kernel 和 top 是当前唯二轻微使用 CPU 的进程（各 1.0%） 📌 六、附录：速查表 项目 正常范围 本例状态 是否健康 Load Average &lt; CPU 核数 0.00~0.01 ✅ %CPU idle &gt; 20% 98.6% ✅ I&#x2F;O Wait (wa) &lt; 5% 0.0% ✅ Zombie 进程 0 0 ✅ Swap Used 0（或极小） 0.0 ✅ Avail Mem &gt; 总内存 20% 872.8 &#x2F; 1801 ≈ 48% ✅ ✅ 总结通过 top 命令，我们可以： 5秒内判断系统整体健康度（通过前5行全局信息） 精准定位资源占用大户（通过进程列表 + 排序） 发现潜在问题（僵尸、I&#x2F;O瓶颈、内存泄漏等）","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://lyroom.github.io/tags/linux/"},{"name":"top","slug":"top","permalink":"https://lyroom.github.io/tags/top/"}]},{"title":"markdown学习","date":"2025-09-16T02:03:49.511Z","path":"2025/09/16/markdown学习/","text":"📘 Markdown 学习笔记程序员必须要会的MarkDown语法，这是写博客的基石，下面我们来简短的学习一下语法。 1️⃣ 标题输入格式： #（*n）+ 空格 + 标题内容 1234- `#` 一级标题 - `##` 二级标题 - `###` 三级标题 - `####` 四级标题 示例： 123# 一级标题## 二级标题### 三级标题 2️⃣ 字体 斜体：*文本* → Hello World 加粗：**文本** → Hello World 斜体加粗：***文本*** → Hello World 删除线：~~文本~~ → Hello World 3️⃣ 引用1&gt; 这是一段引用 效果： 宇宙很大，生活更大 4️⃣ 分割线12--- *** 效果： 5️⃣ 图片语法： 1{% asset_img \"span>\" \"图片描述\" %} 示例： 1![dilireba](markdown学习/dilirebal.jpg) 6️⃣ 超链接1[点击跳转到 Henry 的博客](https://lyroom.github.io/) 效果： 点击跳转到 Henry 的博客 7️⃣ 列表有序列表： 1231. A2. B3. C 无序列表： 123- A- B- C 效果： A B C A B C 任务列表： 123- [x] 已完成的任务一- [ ] 未完成的任务二- [ ] 未完成的任务三 效果： 已完成的任务一 未完成的任务二 未完成的任务三 8️⃣ 表格1234| 名字 | 性别 | 生日 || ---- | ---- | ---- || 张三 | 男 | 2000 || 李四 | 女 | 2001 | 效果： 名字 性别 生日 张三 男 2000 李四 女 2001 9️⃣ 代码块语法： 123```语言代码内容``` 示例： 12345public class Hello &#123; public static void main(String []args)&#123; System.out.print(&quot;Hello World&quot;); &#125;&#125; 🔟 文章截断有些博客系统支持 &lt;!--more--&gt; 来截断正文。 1&lt;!--more--&gt; 1️⃣1️⃣ 高亮文本语法（部分 Markdown 渲染器支持，如 Typora）： 12==高亮文本==&lt;mark&gt;高亮文本&lt;/mark&gt; 效果： &#x3D;&#x3D;这就是效果&#x3D;&#x3D; 这也是效果 1️⃣2️⃣ 行内代码语法： 1这里有一段 `代码` 在行内。 效果： 这里有一段 代码 在行内。 1️⃣3️⃣ 换行语法： 1231.行尾加两个空格[space][space]2.行尾加&lt;br&gt;3.行尾加反斜杠\\ 效果：第一行第二行第三行\\1️⃣4️⃣ 脚注语法： 1[脚注内容](#脚注 &quot;标题&quot;) 效果： 脚注内容 1️⃣5️⃣ 数学公式语法： 123$$公式内容$$ 效果： $$公式内容$$ 1️⃣6️⃣ 流程图语法： 1️⃣3️⃣ 常用符号 &amp; Emoji🔹 列表符号123456789- 🔹 蓝色小点- 🔸 橙色小点- 🔺 红色三角- 🔻 蓝色三角- ▶ 箭头- ➡ 右箭头- ⬅ 左箭头- ⬆ 上箭头- ⬇ 下箭头 效果： 🔹 蓝色小点 🔸 橙色小点 🔺 红色三角 🔻 蓝色三角 ▶ 箭头 ➡ 右箭头 ⬅ 左箭头 ⬆ 上箭头 ⬇ 下箭头 ✅ 状态符号12345✅ 成功❌ 失败⚠️ 警告ℹ️ 信息❓ 疑问 效果： ✅ 成功 ❌ 失败 ⚠️ 警告 ℹ️ 信息 ❓ 疑问 ⭐ 重点&#x2F;装饰123456789⭐ 星标✨ 闪光🔥 火焰💡 想法📌 图钉📎 回形针📝 记事📂 文件夹📦 包裹 效果： ⭐ 星标 ✨ 闪光 🔥 火焰 💡 想法 📌 图钉 📎 回形针 📝 记事 📂 文件夹 📦 包裹 ⏰ 时间&#x2F;进度1234⏰ 时钟⌛ 沙漏🔄 循环🚀 火箭 效果： ⏰ 时钟 ⌛ 沙漏 🔄 循环 🚀 火箭 🔗 常用图标12345678💻 电脑📱 手机🌐 地球🔑 钥匙🔒 锁🔓 解锁⚙️ 齿轮🖥️ 显示器 效果： 💻 电脑 📱 手机 🌐 地球 🔑 钥匙 🔒 锁 🔓 解锁 ⚙️ 齿轮 🖥️ 显示器 📌 小技巧 在 Markdown 里直接复制粘贴 Emoji 即可使用。 可与 - 或 * 搭配，做成漂亮的列表。 在标题里用 Emoji，让层次更清晰： 1234## 🚀 快速开始## ⚙️ 配置方法## 📝 使用示例## ❓ 常见问题 参考链接菜鸟markdown","link":"","tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://lyroom.github.io/tags/Markdown/"}]},{"title":"linux离线安装软件方法","date":"2025-09-15T16:02:05.000Z","path":"2025/09/16/linux离线安装软件方法/","text":"🐧 Linux离线安装软件方法在离线环境下安装软件时，不仅需要下载主包，还要把依赖包一并下载。这里提供两种情况的处理方法。 跨架构安装软件方法（例如在 x86 上下载 arm64 包）1234567891011121314151617181920# 先查看发行版本里面有没有对应的架构和版本apt list -a top# 或者apt-cache policy &lt;包名&gt;# 1. 添加目标架构支持sudo dpkg --add-architecture arm64# 2. 安装依赖分析工具sudo apt install apt-rdepends# 3. 查看对应包的依赖apt-rdepends &lt;包名&gt;:arm64# 4. 建立目录并进入mkdir dependsdep &amp;&amp; cd dependsdep# 5. 批量下载依赖包apt-rdepends &lt;包名&gt;:arm64 | grep -E -v &#x27;^ &#x27; | xargs -I&#123;&#125; apt download &#123;&#125;:arm64 📌sudo dpkg --add-architecture arm64这条命令是永久切换软件包下载吗不是的，不是永久 切换，而是永久 增加 一种架构支持。 🔹解释一下 dpkg --print-architecture 显示系统的「主架构」（通常是 amd64）。 dpkg --print-foreign-architectures 显示系统额外支持的「外部架构」。 当你执行： 1sudo dpkg --add-architecture arm64 系统会在 /var/lib/dpkg/arch 里记录 arm64。 以后 apt update 时，就会同时获取 amd64 和 arm64 的软件包信息。 这样你就可以安装 :arm64 后缀的包（如果源里有）。 🔹是否“永久”？ ✅ 永久有效（除非你手动删除）。 ❌ 不是切换主架构，主架构仍然是 amd64。 你可以随时删除： 1sudo dpkg --remove-architecture arm64 🔹举个例子 默认情况： 12345dpkg --print-architecture# amd64dpkg --print-foreign-architectures# （空） 加了 arm64： 12345678sudo dpkg --add-architecture arm64sudo apt updatedpkg --print-architecture# amd64dpkg --print-foreign-architectures# arm64 同架构安装软件方法（例如 x86 上下载 x86 包）123456789101112131415# 1. 安装依赖分析工具sudo apt install apt-rdepends# 2. 查看包的依赖apt-rdepends &lt;包名&gt;# 3. 建立目录并进入mkdir dependsdep &amp;&amp; cd dependsdep# 4. 批量下载依赖包apt-rdepends &lt;包名&gt; | grep -E -v &#x27;^ &#x27; | xargs -I&#123;&#125; apt download &#123;&#125;# 5. 安装目标包（假设包已经下载到上一级目录）sudo dpkg -i ../&lt;包名&gt;*.deb","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://lyroom.github.io/tags/linux/"}]},{"title":"构建工具链深度解析：GCC、G++、CMake、Make、QMake 和 CMakeLists.txt","date":"2025-09-05T03:35:00.000Z","path":"2025/09/05/构建工具链深度解析：GCC、G-、CMake、Make、QMake-和-CMakeLists-txt/","text":"GCC、G++、CMake、Make、QMake 和 CMakeLists.txt这一系列的名词对于初学c++的学者来说是不是听起来很迷茫，但是又在很多的项目中遇到过？今天我们来简短的介绍一下这些专有名词，并且搞懂他们之间的关联。 1. GCC (GNU Compiler Collection) 本质：编译器 作用： 将源代码（.c&#x2F;.cpp）转换为机器可执行文件 处理编译过程的4个阶段： 预处理（宏展开、头文件包含） 编译（源代码 → 汇编代码） 汇编（汇编代码 → 机器码） 链接（合并多个目标文件和库） 特点： 支持多种语言（C, C++, Objective-C, Fortran等） 跨平台（Linux&#x2F;Windows&#x2F;macOS） 提供丰富的编译选项（优化级别、警告控制等） 使用示例： 12gcc -c main.c -o main.o # 编译C文件g++ -Wall -O2 app.cpp -o app # 编译C++文件并优化 2. G++ 本质：C++前端编译器 作用： GCC的C++特定版本 自动链接C++标准库（libstdc++） 处理C++特有的编译特性（模板、异常处理等） 与GCC的关系： G++是GCC的一部分，专注于C++编译 相当于gcc -lstdc++的快捷方式 使用示例： 1g++ -std=c++17 main.cpp utils.cpp -o app 3. Make 本质：构建自动化工具 作用： 根据Makefile规则管理构建过程 自动检测需要重新编译的文件（增量编译） 执行编译命令（调用gcc&#x2F;g++） 核心概念： 目标（targets） 依赖（dependencies） 命令（commands） Makefile示例： 1234567891011app: main.o utils.o g++ main.o utils.o -o app main.o: main.cpp g++ -c main.cpp utils.o: utils.cpp utils.h g++ -c utils.cpp clean: rm -f *.o app 特点： 简单直接 需要手动管理依赖关系 跨平台性有限 4. QMake 本质：Qt专用的构建系统生成器 作用： 解析.pro文件 生成平台特定的构建文件（Makefile或IDE项目文件） 自动处理Qt特有的构建步骤（moc, uic, rcc） .pro文件示例： 12345QT += widgetsTARGET = myappSOURCES += main.cpp widget.cppHEADERS += widget.hRESOURCES += app.qrc 特点： Qt原生支持 简单易学 跨平台（生成不同平台的构建文件） 功能相对有限（相比CMake） 5. CMake 本质：跨平台构建系统生成器 作用： 解析CMakeLists.txt文件 生成平台特定的构建系统文件： Linux&#x2F;macOS → Makefile Windows → Visual Studio解决方案(.sln) Ninja → build.ninja 自动检测系统环境和依赖库 核心优势： “Write once, build everywhere” 支持复杂项目结构 强大的依赖管理 模块化系统 使用流程： 123mkdir build &amp;&amp; cd buildcmake .. # 生成构建系统make # 执行构建 6. CMakeLists.txt 本质：CMake的配置文件 作用： 描述项目结构和构建规则 定义编译目标（可执行文件、库） 指定依赖关系和链接选项 示例： 123456789101112cmake_minimum_required(VERSION 3.10)project(MyApp)add_executable(myapp main.cpp)find_package(Qt5 COMPONENTS Widgets REQUIRED)target_link_libraries(myapp PRIVATE Qt5::Widgets)set_target_properties(myapp PROPERTIES CXX_STANDARD 17 CXX_STANDARD_REQUIRED ON) 工具链对比分析层级关系12345[源代码] ├── [GCC/G++] → 直接编译（简单项目） ├── [Makefile] → [make] → 调用[GCC/G++] ├── [.pro] → [qmake] → 生成[Makefile] → [make] → [GCC/G++] └── [CMakeLists.txt] → [cmake] → 生成[Makefile/VS项目等] → [make/MSBuild] → [GCC/G++/MSVC] 功能对比表 工具&#x2F;文件 主要作用 输入 输出 跨平台性 复杂度 适用场景 GCC&#x2F;G++ 编译源代码 源代码文件 目标文件&#x2F;可执行文件 高 低 简单程序、单文件编译 Make 执行构建规则 Makefile 构建产物 中 中 中小型项目 QMake 生成Qt项目构建系统 .pro文件 Makefile&#x2F;项目文件 高 中 Qt项目 CMake 生成跨平台构建系统 CMakeLists.txt 构建系统文件 极高 高 大型跨平台项目 CMakeLists.txt 描述项目构建规则 无 无 极高 高 所有CMake项目 工作流程对比简单项目： 1main.cpp → g++ → a.out Make项目： 1main.cpp + utils.cpp + Makefile → make → (g++) → app QMake项目： 1main.cpp + widget.cpp + app.pro → qmake → Makefile → make → (g++) → app CMake项目： 1main.cpp + utils.cpp + CMakeLists.txt → cmake → Makefile → make → (g++) → app 现代C++项目推荐工作流对于Qt项目 关键配置示例Qt项目的CMakeLists.txt： 1234567891011121314151617181920212223242526272829cmake_minimum_required(VERSION 3.16)project(MyQtApp)# 查找Qt库find_package(Qt6 COMPONENTS Widgets Network REQUIRED)# 创建可执行文件add_executable(myapp main.cpp mainwindow.cpp resources.qrc)# 链接Qt库target_link_libraries(myapp PRIVATE Qt6::Widgets Qt6::Network)# 自动处理Qt元对象系统set_target_properties(myapp PROPERTIES AUTOMOC ON AUTOUIC ON AUTORCC ON CXX_STANDARD 17)# 安装规则install(TARGETS myapp DESTINATION bin) 如何选择构建工具？ 小型工具&#x2F;快速原型： 直接使用G++编译 或简单Makefile Qt专用项目： 传统：QMake + .pro文件 现代：CMake（Qt官方推荐） 跨平台C++库&#x2F;应用： CMake（行业标准） 大型复杂系统： CMake + 现代构建系统（如Ninja） 常见问题解答Q：CMake能完全替代Make吗？A：不完全。CMake生成Makefile，然后Make执行构建。CMake是构建系统生成器，Make是构建执行器。 Q：QMake会被淘汰吗？A：Qt官方已转向CMake作为首选构建系统，但QMake仍被广泛使用，特别是维护旧项目时。 Q：为什么需要构建系统？A：当项目具有以下特点时： 多个源文件 复杂的依赖关系 需要跨平台构建 包含资源文件和代码生成 需要安装规则和打包 Q：GCC和Clang的区别？A：两者都是编译器，GCC是GNU项目，Clang是LLVM项目。Clang有更友好的错误信息，更快的编译速度，更好的C++标准支持。 总结 编译器层：GCC&#x2F;G++ 负责将源代码转换为机器码 构建执行层：Make 负责执行构建规则 构建系统生成层： QMake：专为Qt优化的构建系统生成器 CMake：通用跨平台构建系统生成器 配置文件： .pro：QMake的配置文件 CMakeLists.txt：CMake的配置文件 现代C++开发中，CMake + GCC&#x2F;Clang + Ninja 已成为主流组合，提供最高效、最灵活的构建解决方案。对于Qt项目，虽然QMake仍可用，但CMake已成为官方推荐的选择，特别是新项目。","link":"","tags":[{"name":"c/c++","slug":"c-c","permalink":"https://lyroom.github.io/tags/c-c/"},{"name":"GCC/G++","slug":"GCC-G","permalink":"https://lyroom.github.io/tags/GCC-G/"},{"name":"Make","slug":"Make","permalink":"https://lyroom.github.io/tags/Make/"},{"name":"QMake","slug":"QMake","permalink":"https://lyroom.github.io/tags/QMake/"},{"name":"CMake","slug":"CMake","permalink":"https://lyroom.github.io/tags/CMake/"},{"name":"CMakeLists","slug":"CMakeLists","permalink":"https://lyroom.github.io/tags/CMakeLists/"}]},{"title":"ubuntu虚拟机安装vmtools遇到的问题","date":"2025-09-03T20:02:02.000Z","path":"2025/09/04/ubuntu虚拟机安装vmtools遇到的问题/","text":"123sudo apt-get autoremove open-vm-toolssudo apt-get install open-vm-toolssudo apt-get install open-vm-tools-desktop done!","link":"","tags":[{"name":"VMware","slug":"VMware","permalink":"https://lyroom.github.io/tags/VMware/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://lyroom.github.io/tags/Ubuntu/"}]},{"title":"c++继承中的父子纠葛","date":"2024-10-23T14:42:31.000Z","path":"2024/10/23/c-继承中的父子纠葛/","text":"想必各位对于面向对象都已了然于胸了吧，今天我偶然间遇到了一个面试题，是关于继承方面的，蛮有不错的，邀请各位来探讨一下。 先看下面一段代码： 12345678910111213141516171819202122232425#include &lt;iostream&gt;class Base &#123;public: int a = 1; virtual void print(int n = 2) &#123; &#125;&#125;;class Derive:public Base&#123; public: int b=3; virtual void print(int n = 10)override &#123; std::cout &lt;&lt; &quot;Derive :&quot;&lt;&lt;b + n &lt;&lt; std::endl; &#125;&#125;; int main()&#123; Base *arr = new Derive[10]; arr[7].print(); delete[] arr; Base *ptr = new Derive(); ptr-&gt;print(); delete ptr;&#125; 你可以尝试分析一下，这段代码的结果吗？我们可以回顾一下继承的概念运行这段代码之后我们发现，结果如下： 12345mingw64： Derive :5 Derive :5mingw32： exited with code -1073741819 为什么会出现这种情况呢？我们一步步来分析。 代码关键点解释 类结构： Base类：包含成员变量a = 1，以及虚函数print(int n = 2)，默认参数为2。函数输出&quot;Base:&quot; &lt;&lt; a + n。 Derive类：继承自Base，添加成员变量b = 3，并覆盖虚函数print(int n = 10)，默认参数改为10。函数输出&quot;Derive:&quot; &lt;&lt; b + n。 虚函数（virtual）支持运行时多态：通过基类指针调用时，实际执行派生类的覆盖函数（动态绑定）。 结构体（类）在内存中的存放规则 ​ 为了更方便的访问结构体对象中的成员变量，通常需要在内存中对齐存储，所以通常需要空一段内存，这便是填充。所以一个结构体对象在内存中的存储原则是： 结构体的起始地址 &#x3D; 最大成员对齐值的整数倍 每个成员的起始地址能够被该成员大小整除 结构体的大小 &#x3D; 最大成员的整数倍 在64位系统中，每个内存单元的大小通常为64b即8B，所以一般按照8B对齐，指针大小通常也为8B 在32位系统中，每个内存单元的大小通常时32b即4B，所以一般按照4B对齐，指针大小通常也为4B ​ 按照上面的原则，可以知道上述父子类对象在不同系统中，内存的存储方式： 默认参数的绑定规则： 默认参数是静态绑定（在编译时基于指针或引用类型确定），而非动态绑定。 当通过基类指针调用虚函数时： 函数实现（函数体）使用派生类的版本（动态绑定）。 默认参数值使用基类定义的默认值（静态绑定），忽略派生类的默认值，所以运算时n的值始终为2。 数组分配问题： Base* arr = new Derive[10]：这里分配了一个包含10个Derive对象的数组，但用Base*指针指向它。 我们希望情况如下： 但实际上呢？？？ 输出结果分析1. 第一次调用：arr[7].print() 输出结果： mingw64构建运行时： 1Derive :5 mingw32构建运行时: 1exited with code -1073741819 两个编译器为啥输出结果不同？： ​ 关键在于arr[7] 有没有指向[Derive7] mingw64构建时： 虽然Base和Derive大小不同，但是由于内存对齐使得Base的大小和Derive大小相同，阴差阳错的使得arr[7]指向了Derive[7]的位置，使得可以调用Derive的print函数，输出为5； mingw32构建时： 指针算术错误：arr指向Derive[10]数组，但arr[7]基于sizeof(Base)计算地址（例如，在32位系统中，arr + 7 * 8 = arr + 56）。实际第7个Derive对象位于arr + 7 * 12 = arr + 84（假设sizeof(Derive)=12）。因此，arr[7]指向无效内存。所以输出错误值。 为什么不是多态输出？ 即使忽略指针错误，理论上： 函数调用应使用Derive::print实现（虚函数动态绑定）。 但默认参数静态绑定为Base::print的n=2（因为arr类型是Base*）。 输出应为&quot;Derive:&quot; &lt;&lt; b + 2（即Derive:5），但由于对象地址错误，b的值可能无效或取自错误内存。 2. 第二次调用：ptr-&gt;print() 输出结果：Derive:5 原因： ptr指向一个有效的Derive对象（new Derive()），多态正确：ptr类型是Base*，但对象是Derive，因此虚函数调用Derive::print实现（动态绑定）。 默认参数静态绑定：调用ptr-&gt;print()未提供参数，编译器基于ptr的静态类型（Base*）使用Base::print的默认值n=2（忽略Derive::print的n=10）。 因此，实际调用Derive::print(2)： b + n = 3 + 2 = 5。 输出：&quot;Derive:5&quot;。 关键原理：默认参数在编译时确定，基于指针类型（Base*），而函数体在运行时确定，基于对象类型（Derive）。","link":"","tags":[{"name":"c++","slug":"c","permalink":"https://lyroom.github.io/tags/c/"},{"name":"继承","slug":"继承","permalink":"https://lyroom.github.io/tags/%E7%BB%A7%E6%89%BF/"},{"name":"多态","slug":"多态","permalink":"https://lyroom.github.io/tags/%E5%A4%9A%E6%80%81/"},{"name":"虚函数","slug":"虚函数","permalink":"https://lyroom.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"},{"name":"虚函数表","slug":"虚函数表","permalink":"https://lyroom.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/"},{"name":"虚函数指针","slug":"虚函数指针","permalink":"https://lyroom.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"}]},{"title":"C++核心编程","date":"2024-10-16T03:56:40.000Z","path":"2024/10/16/C-核心编程/","text":"本阶段主要针对C++ , 面向对象 , 编程技术做详细讲解，探讨C++中的核心和精髓。 1 内存分区模型C++程序在执行时，将内存大方向划分为4个区域 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收 内存四区意义： 不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程 1.1 程序运行前​ 在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域 ​ 代码区： ​ 存放 CPU 执行的机器指令 ​ 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 ​ 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令 ​ 全局区： ​ 全局变量和静态变量存放在此. ​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此. ​ &#x3D;&#x3D;该区域的数据在程序结束后由操作系统释放&#x3D;&#x3D;. 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243//全局变量int g_a = 10;int g_b = 10;//全局常量const int c_g_a = 10;const int c_g_b = 10;int main() &#123; //局部变量 int a = 10; int b = 10; //打印地址 cout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl; cout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl; cout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt; (int)&amp;g_a &lt;&lt; endl; cout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt; (int)&amp;g_b &lt;&lt; endl; //静态变量 static int s_a = 10; static int s_b = 10; cout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl; cout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl; cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl; cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl; cout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl; cout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl; const int c_l_a = 10; const int c_l_b = 10; cout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl; cout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 打印结果： 总结： C++中在程序运行前分为全局区和代码区 代码区特点是共享和只读 全局区中存放全局变量、静态变量、常量 常量区中存放 const修饰的全局常量 和 字符串常量 1.2 程序运行后​ 栈区： ​ 由编译器自动分配释放, 存放函数的参数值,局部变量等 ​ 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放 示例： 1234567891011121314151617int * func()&#123; int a = 10; return &amp;a;&#125;int main() &#123; int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; ​ 堆区： ​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收 ​ 在C++中主要利用new在堆区开辟内存 示例： 1234567891011121314151617int* func()&#123; int* a = new int(10); return a;&#125;int main() &#123; int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结： 堆区数据由程序员管理开辟和释放 堆区数据利用new关键字进行开辟内存 1.3 new操作符​ C++中利用&#x3D;&#x3D;new&#x3D;&#x3D;操作符在堆区开辟数据 ​ 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 &#x3D;&#x3D;delete&#x3D;&#x3D; ​ 语法： new 数据类型 ​ 利用new创建的数据，会返回该数据对应的类型的指针 示例1： 基本语法 12345678910111213141516171819202122int* func()&#123; int* a = new int(10); return a;&#125;int main() &#123; int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; //利用delete释放堆区数据 delete p; //cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问 system(&quot;pause&quot;); return 0;&#125; 示例2：开辟数组 12345678910111213141516171819202122//堆区开辟数组int main() &#123; int* arr = new int[10]; for (int i = 0; i &lt; 10; i++) &#123; arr[i] = i + 100; &#125; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; //释放数组 delete 后加 [] delete[] arr; system(&quot;pause&quot;); return 0;&#125; 2 引用2.1 引用的基本使用**作用： **给变量起别名 语法： 数据类型 &amp;别名 = 原名 示例： 1234567891011121314151617int main() &#123; int a = 10; int &amp;b = a; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; b = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 2.2 引用注意事项 引用必须初始化 引用在初始化后，不可以改变 示例： 12345678910111213141516int main() &#123; int a = 10; int b = 20; //int &amp;c; //错误，引用必须初始化 int &amp;c = a; //一旦初始化后，就不可以更改 c = b; //这是赋值操作，不是更改引用 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 2.3 引用做函数参数作用：函数传参时，可以利用引用的技术让形参修饰实参 优点：可以简化指针修改实参 示例： 12345678910111213141516171819202122232425262728293031323334353637383940//1. 值传递void mySwap01(int a, int b) &#123; int temp = a; a = b; b = temp;&#125;//2. 地址传递void mySwap02(int* a, int* b) &#123; int temp = *a; *a = *b; *b = temp;&#125;//3. 引用传递void mySwap03(int&amp; a, int&amp; b) &#123; int temp = a; a = b; b = temp;&#125;int main() &#123; int a = 10; int b = 20; mySwap01(a, b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; mySwap02(&amp;a, &amp;b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; mySwap03(a, b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单 2.4 引用做函数返回值作用：引用是可以作为函数的返回值存在的 注意：不要返回局部变量引用 用法：函数调用作为左值 示例： 123456789101112131415161718192021222324252627282930313233//返回局部变量引用int&amp; test01() &#123; int a = 10; //局部变量 return a;&#125;//返回静态变量引用int&amp; test02() &#123; static int a = 20; return a;&#125;int main() &#123; //不能返回局部变量的引用 int&amp; ref = test01(); cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl; cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl; //如果函数做左值，那么必须返回引用 int&amp; ref2 = test02(); cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; test02() = 1000; cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; ​ 2.5 引用的本质本质：引用的本质在c++内部实现是一个指针常量. 讲解示例： 1234567891011121314151617//发现是引用，转换为 int* const ref = &amp;a;void func(int&amp; ref)&#123; ref = 100; // ref是引用，转换为*ref = 100&#125;int main()&#123; int a = 10; //自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改 int&amp; ref = a; ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20; cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl; func(a); return 0;&#125; 结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了 2.6 常量引用作用：常量引用主要用来修饰形参，防止误操作 在函数形参列表中，可以加&#x3D;&#x3D;const修饰形参&#x3D;&#x3D;，防止形参改变实参 示例： 1234567891011121314151617181920212223//引用使用的场景，通常用来修饰形参void showValue(const int&amp; v) &#123; //v += 10; cout &lt;&lt; v &lt;&lt; endl;&#125;int main() &#123; //int&amp; ref = 10; 引用本身需要一个合法的内存空间，因此这行错误 //加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp; const int&amp; ref = 10; //ref = 100; //加入const后不可以修改变量 cout &lt;&lt; ref &lt;&lt; endl; //函数中利用常量引用防止误操作修改实参 int a = 10; showValue(a); system(&quot;pause&quot;); return 0;&#125; 3 函数提高3.1 函数默认参数在C++中，函数的形参列表中的形参是可以有默认值的。 语法： 返回值类型 函数名 （参数= 默认值）&#123;&#125; 示例： 1234567891011121314151617181920int func(int a, int b = 10, int c = 10) &#123; return a + b + c;&#125;//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数int func2(int a = 10, int b = 10);int func2(int a, int b) &#123; return a + b;&#125;int main() &#123; cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(20, 20) &lt;&lt; endl; cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(100) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 3.2 函数占位参数C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置 语法： 返回值类型 函数名 (数据类型)&#123;&#125; 在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术 示例： 12345678910111213//函数占位参数 ，占位参数也可以有默认参数void func(int a, int) &#123; cout &lt;&lt; &quot;this is func&quot; &lt;&lt; endl;&#125;int main() &#123; func(10,10); //占位参数必须填补 system(&quot;pause&quot;); return 0;&#125; 3.3 函数重载3.3.1 函数重载概述作用：函数名可以相同，提高复用性 函数重载满足条件： 同一个作用域下 函数名称相同 函数参数类型不同 或者 个数不同 或者 顺序不同 注意: 函数的返回值不可以作为函数重载的条件 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041//函数重载需要函数都在同一个作用域下void func()&#123; cout &lt;&lt; &quot;func 的调用！&quot; &lt;&lt; endl;&#125;void func(int a)&#123; cout &lt;&lt; &quot;func (int a) 的调用！&quot; &lt;&lt; endl;&#125;void func(double a)&#123; cout &lt;&lt; &quot;func (double a)的调用！&quot; &lt;&lt; endl;&#125;void func(int a ,double b)&#123; cout &lt;&lt; &quot;func (int a ,double b) 的调用！&quot; &lt;&lt; endl;&#125;void func(double a ,int b)&#123; cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;&#125;//函数返回值不可以作为函数重载条件//int func(double a, int b)//&#123;// cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;//&#125;int main() &#123; func(); func(10); func(3.14); func(10,3.14); func(3.14 , 10); system(&quot;pause&quot;); return 0;&#125; 3.3.2 函数重载注意事项 引用作为重载条件 函数重载碰到函数默认参数 示例： 123456789101112131415161718192021222324252627282930313233343536373839//函数重载注意事项//1、引用作为重载条件void func(int &amp;a)&#123; cout &lt;&lt; &quot;func (int &amp;a) 调用 &quot; &lt;&lt; endl;&#125;void func(const int &amp;a)&#123; cout &lt;&lt; &quot;func (const int &amp;a) 调用 &quot; &lt;&lt; endl;&#125;//2、函数重载碰到函数默认参数void func2(int a, int b = 10)&#123; cout &lt;&lt; &quot;func2(int a, int b = 10) 调用&quot; &lt;&lt; endl;&#125;void func2(int a)&#123; cout &lt;&lt; &quot;func2(int a) 调用&quot; &lt;&lt; endl;&#125;int main() &#123; int a = 10; func(a); //调用无const func(10);//调用有const //func2(10); //碰到默认参数产生歧义，需要避免 system(&quot;pause&quot;); return 0;&#125; 4 类和对象C++面向对象的三大特性为：&#x3D;&#x3D;封装、继承、多态&#x3D;&#x3D; C++认为&#x3D;&#x3D;万事万物都皆为对象&#x3D;&#x3D;，对象上有其属性和行为 例如： ​ 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌… ​ 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调… ​ 具有相同性质的&#x3D;&#x3D;对象&#x3D;&#x3D;，我们可以抽象称为&#x3D;&#x3D;类&#x3D;&#x3D;，人属于人类，车属于车类 4.1 封装4.1.1 封装的意义封装是C++面向对象三大特性之一 封装的意义： 将属性和行为作为一个整体，表现生活中的事物 将属性和行为加以权限控制 封装意义一： ​ 在设计类的时候，属性和行为写在一起，表现事物 语法： class 类名&#123; 访问权限： 属性 / 行为 &#125;; 示例1：设计一个圆类，求圆的周长 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839//圆周率const double PI = 3.14;//1、封装的意义//将属性和行为作为一个整体，用来表现生活中的事物//封装一个圆类，求圆的周长//class代表设计一个类，后面跟着的是类名class Circle&#123;public: //访问权限 公共的权限 //属性 int m_r;//半径 //行为 //获取到圆的周长 double calculateZC() &#123; //2 * pi * r //获取圆的周长 return 2 * PI * m_r; &#125;&#125;;int main() &#123; //通过圆类，创建圆的对象 // c1就是一个具体的圆 Circle c1; c1.m_r = 10; //给圆对象的半径 进行赋值操作 //2 * pi * 10 = = 62.8 cout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 示例2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号 示例2代码： 123456789101112131415161718192021222324252627282930//学生类class Student &#123;public: void setName(string name) &#123; m_name = name; &#125; void setID(int id) &#123; m_id = id; &#125; void showStudent() &#123; cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl; &#125;public: string m_name; int m_id;&#125;;int main() &#123; Student stu; stu.setName(&quot;德玛西亚&quot;); stu.setID(250); stu.showStudent(); system(&quot;pause&quot;); return 0;&#125; 封装意义二： 类在设计时，可以把属性和行为放在不同的权限下，加以控制 访问权限有三种： public 公共权限 protected 保护权限 private 私有权限 示例： 123456789101112131415161718192021222324252627282930313233343536373839//三种权限//公共权限 public 类内可以访问 类外可以访问//保护权限 protected 类内可以访问 类外不可以访问//私有权限 private 类内可以访问 类外不可以访问class Person&#123; //姓名 公共权限public: string m_Name; //汽车 保护权限protected: string m_Car; //银行卡密码 私有权限private: int m_Password;public: void func() &#123; m_Name = &quot;张三&quot;; m_Car = &quot;拖拉机&quot;; m_Password = 123456; &#125;&#125;;int main() &#123; Person p; p.m_Name = &quot;李四&quot;; //p.m_Car = &quot;奔驰&quot;; //保护权限类外访问不到 //p.m_Password = 123; //私有权限类外访问不到 system(&quot;pause&quot;); return 0;&#125; 4.1.2 struct和class区别在C++中 struct和class唯一的区别就在于 默认的访问权限不同 区别： struct 默认权限为公共 class 默认权限为私有 12345678910111213141516171819202122class C1&#123; int m_A; //默认是私有权限&#125;;struct C2&#123; int m_A; //默认是公共权限&#125;;int main() &#123; C1 c1; c1.m_A = 10; //错误，访问权限是私有 C2 c2; c2.m_A = 10; //正确，访问权限是公共 system(&quot;pause&quot;); return 0;&#125; 4.1.3 成员属性设置为私有优点1：将所有成员属性设置为私有，可以自己控制读写权限 优点2：对于写权限，我们可以检测数据的有效性 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Person &#123;public: //姓名设置可读可写 void setName(string name) &#123; m_Name = name; &#125; string getName() &#123; return m_Name; &#125; //获取年龄 int getAge() &#123; return m_Age; &#125; //设置年龄 void setAge(int age) &#123; if (age &lt; 0 || age &gt; 150) &#123; cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl; return; &#125; m_Age = age; &#125; //情人设置为只写 void setLover(string lover) &#123; m_Lover = lover; &#125;private: string m_Name; //可读可写 姓名 int m_Age; //只读 年龄 string m_Lover; //只写 情人&#125;;int main() &#123; Person p; //姓名设置 p.setName(&quot;张三&quot;); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl; //年龄设置 p.setAge(50); cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl; //情人设置 p.setLover(&quot;苍井&quot;); //cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl; //只写属性，不可以读取 system(&quot;pause&quot;); return 0;&#125; 练习案例1：设计立方体类 设计立方体类(Cube) 求出立方体的面积和体积 分别用全局函数和成员函数判断两个立方体是否相等。 练习案例2：点和圆的关系 设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。 4.2 对象的初始化和清理 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全 C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。 4.2.1 构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题 ​ 一个对象或者变量没有初始状态，对其使用后果是未知 ​ 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题 c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。 对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供 编译器提供的构造函数和析构函数是空实现。 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。 构造函数语法：类名()&#123;&#125; 构造函数，没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次 析构函数语法： ~类名()&#123;&#125; 析构函数，没有返回值也不写void 函数名称与类名相同,在名称前加上符号 ~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次 1234567891011121314151617181920212223242526272829class Person&#123;public: //构造函数 Person() &#123; cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl; &#125; //析构函数 ~Person() &#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; Person p;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.2.2 构造函数的分类及调用两种分类方式： ​ 按参数分为： 有参构造和无参构造 ​ 按类型分为： 普通构造和拷贝构造 三种调用方式： ​ 括号法 ​ 显示法 ​ 隐式转换法 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//1、构造函数分类// 按照参数分类分为 有参和无参构造 无参又称为默认构造函数// 按照类型分类分为 普通构造和拷贝构造class Person &#123;public: //无参（默认）构造函数 Person() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; &#125; //有参构造函数 Person(int a) &#123; age = a; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; age = p.age; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; &#125; //析构函数 ~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; &#125;public: int age;&#125;;//2、构造函数的调用//调用无参构造函数void test01() &#123; Person p; //调用无参构造函数&#125;//调用有参的构造函数void test02() &#123; //2.1 括号法，常用 Person p1(10); //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明 //Person p2(); //2.2 显式法 Person p2 = Person(10); Person p3 = Person(p2); //Person(10)单独写就是匿名对象 当前行结束之后，马上析构 //2.3 隐式转换法 Person p4 = 10; // Person p4 = Person(10); Person p5 = p4; // Person p5 = Person(p4); //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明 //Person p5(p4);&#125;int main() &#123; test01(); //test02(); system(&quot;pause&quot;); return 0;&#125; 4.2.3 拷贝构造函数调用时机C++中拷贝构造函数调用时机通常有三种情况 使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Person &#123;public: Person() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; mAge = 0; &#125; Person(int age) &#123; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; mAge = age; &#125; Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; mAge = p.mAge; &#125; //析构函数在释放内存之前调用 ~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; &#125;public: int mAge;&#125;;//1. 使用一个已经创建完毕的对象来初始化一个新对象void test01() &#123; Person man(100); //p对象已经创建完毕 Person newman(man); //调用拷贝构造函数 Person newman2 = man; //拷贝构造 //Person newman3; //newman3 = man; //不是调用拷贝构造函数，赋值操作&#125;//2. 值传递的方式给函数参数传值//相当于Person p1 = p;void doWork(Person p1) &#123;&#125;void test02() &#123; Person p; //无参构造函数 doWork(p);&#125;//3. 以值方式返回局部对象Person doWork2()&#123; Person p1; cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl; return p1;&#125;void test03()&#123; Person p = doWork2(); cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;&#125;int main() &#123; //test01(); //test02(); test03(); system(&quot;pause&quot;); return 0;&#125; 4.2.4 构造函数调用规则默认情况下，c++编译器至少给一个类添加3个函数 1．默认构造函数(无参，函数体为空) 2．默认析构函数(无参，函数体为空) 3．默认拷贝构造函数，对属性进行值拷贝 构造函数调用规则如下： 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造 如果用户定义拷贝构造函数，c++不会再提供其他构造函数 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Person &#123;public: //无参（默认）构造函数 Person() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; &#125; //有参构造函数 Person(int a) &#123; age = a; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; age = p.age; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; &#125; //析构函数 ~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; &#125;public: int age;&#125;;void test01()&#123; Person p1(18); //如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作 Person p2(p1); cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;void test02()&#123; //如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造 Person p1; //此时如果用户自己没有提供默认构造，会出错 Person p2(10); //用户提供的有参 Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供 //如果用户提供拷贝构造，编译器不会提供其他构造函数 Person p4; //此时如果用户自己没有提供默认构造，会出错 Person p5(10); //此时如果用户自己没有提供有参，会出错 Person p6(p5); //用户自己提供拷贝构造&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.2.5 深拷贝与浅拷贝深浅拷贝是面试经典问题，也是常见的一个坑 浅拷贝：简单的赋值拷贝操作 深拷贝：在堆区重新申请空间，进行拷贝操作 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Person &#123;public: //无参（默认）构造函数 Person() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; &#125; //有参构造函数 Person(int age ,int height) &#123; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; m_age = age; m_height = new int(height); &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题 m_age = p.m_age; m_height = new int(*p.m_height); &#125; //析构函数 ~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; if (m_height != NULL) &#123; delete m_height; &#125; &#125;public: int m_age; int* m_height;&#125;;void test01()&#123; Person p1(18, 180); Person p2(p1); cout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl; cout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题 4.2.6 初始化列表作用： C++提供了初始化列表语法，用来初始化属性 语法：构造函数()：属性1(值1),属性2（值2）... &#123;&#125; 示例： 123456789101112131415161718192021222324252627282930313233class Person &#123;public: ////传统方式初始化 //Person(int a, int b, int c) &#123; // m_A = a; // m_B = b; // m_C = c; //&#125; //初始化列表方式初始化 Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125; void PrintPerson() &#123; cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl; cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl; cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl; &#125;private: int m_A; int m_B; int m_C;&#125;;int main() &#123; Person p(1, 2, 3); p.PrintPerson(); system(&quot;pause&quot;); return 0;&#125; 4.2.7 类对象作为类成员C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员 例如： 12345class A &#123;&#125;class B&#123; A a；&#125; B类中有对象A作为成员，A为对象成员 那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？ 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Phone&#123;public: Phone(string name) &#123; m_PhoneName = name; cout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl; &#125; ~Phone() &#123; cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl; &#125; string m_PhoneName;&#125;;class Person&#123;public: //初始化列表可以告诉编译器调用哪一个构造函数 Person(string name, string pName) :m_Name(name), m_Phone(pName) &#123; cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl; &#125; void playGame() &#123; cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl; &#125; string m_Name; Phone m_Phone;&#125;;void test01()&#123; //当类中成员是其他类对象时，我们称该成员为 对象成员 //构造的顺序是 ：先调用对象成员的构造，再调用本类构造 //析构顺序与构造相反 Person p(&quot;张三&quot; , &quot;苹果X&quot;); p.playGame();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.2.8 静态成员静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员 静态成员分为： 静态成员变量 所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 示例1 ：静态成员变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Person&#123; public: static int m_A; //静态成员变量 //静态成员变量特点： //1 在编译阶段分配内存 //2 类内声明，类外初始化 //3 所有对象共享同一份数据private: static int m_B; //静态成员变量也是有访问权限的&#125;;int Person::m_A = 10;int Person::m_B = 10;void test01()&#123; //静态成员变量两种访问方式 //1、通过对象 Person p1; p1.m_A = 100; cout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; Person p2; p2.m_A = 200; cout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据 cout &lt;&lt; &quot;p2.m_A = &quot; &lt;&lt; p2.m_A &lt;&lt; endl; //2、通过类名 cout &lt;&lt; &quot;m_A = &quot; &lt;&lt; Person::m_A &lt;&lt; endl; //cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 示例2：静态成员函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Person&#123;public: //静态成员函数特点： //1 程序共享一个函数 //2 静态成员函数只能访问静态成员变量 static void func() &#123; cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl; m_A = 100; //m_B = 100; //错误，不可以访问非静态成员变量 &#125; static int m_A; //静态成员变量 int m_B; // private: //静态成员函数也是有访问权限的 static void func2() &#123; cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl; &#125;&#125;;int Person::m_A = 10;void test01()&#123; //静态成员变量两种访问方式 //1、通过对象 Person p1; p1.func(); //2、通过类名 Person::func(); //Person::func2(); //私有权限访问不到&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.3 C++对象模型和this指针4.3.1 成员变量和成员函数分开存储在C++中，类内的成员变量和成员函数分开存储 只有非静态成员变量才属于类的对象上 1234567891011121314151617181920212223242526class Person &#123;public: Person() &#123; mA = 0; &#125; //非静态成员变量占对象空间 int mA; //静态成员变量不占对象空间 static int mB; //函数也不占对象空间，所有函数共享一个函数实例 void func() &#123; cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl; &#125; //静态成员函数也不占对象空间 static void sfunc() &#123; &#125;&#125;;int main() &#123; cout &lt;&lt; sizeof(Person) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 4.3.2 this指针概念通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码 那么问题是：这一块代码是如何区分那个对象调用自己的呢？ c++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象 this指针是隐含每一个非静态成员函数内的一种指针 this指针不需要定义，直接使用即可 this指针的用途： 当形参和成员变量同名时，可用this指针来区分 在类的非静态成员函数中返回对象本身，可使用return *this 1234567891011121314151617181920212223242526272829303132333435363738class Person&#123;public: Person(int age) &#123; //1、当形参和成员变量同名时，可用this指针来区分 this-&gt;age = age; &#125; Person&amp; PersonAddPerson(Person p) &#123; this-&gt;age += p.age; //返回对象本身 return *this; &#125; int age;&#125;;void test01()&#123; Person p1(10); cout &lt;&lt; &quot;p1.age = &quot; &lt;&lt; p1.age &lt;&lt; endl; Person p2(10); p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1); cout &lt;&lt; &quot;p2.age = &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.3.3 空指针访问成员函数C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针 如果用到this指针，需要加以判断保证代码的健壮性 示例： 12345678910111213141516171819202122232425262728293031323334//空指针访问成员函数class Person &#123;public: void ShowClassName() &#123; cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl; &#125; void ShowPerson() &#123; if (this == NULL) &#123; return; &#125; cout &lt;&lt; mAge &lt;&lt; endl; &#125;public: int mAge;&#125;;void test01()&#123; Person * p = NULL; p-&gt;ShowClassName(); //空指针，可以调用成员函数 p-&gt;ShowPerson(); //但是如果成员函数中用到了this指针，就不可以了&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.3.4 const修饰成员函数常函数： 成员函数后加const后我们称为这个函数为常函数 常函数内不可以修改成员属性 成员属性声明时加关键字mutable后，在常函数中依然可以修改 常对象： 声明对象前加const称该对象为常对象 常对象只能调用常函数 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Person &#123;public: Person() &#123; m_A = 0; m_B = 0; &#125; //this指针的本质是一个指针常量，指针的指向不可修改 //如果想让指针指向的值也不可以修改，需要声明常函数 void ShowPerson() const &#123; //const Type* const pointer; //this = NULL; //不能修改指针的指向 Person* const this; //this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的 //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量 this-&gt;m_B = 100; &#125; void MyFunc() const &#123; //mA = 10000; &#125;public: int m_A; mutable int m_B; //可修改 可变的&#125;;//const修饰对象 常对象void test01() &#123; const Person person; //常量对象 cout &lt;&lt; person.m_A &lt;&lt; endl; //person.mA = 100; //常对象不能修改成员变量的值,但是可以访问 person.m_B = 100; //但是常对象可以修改mutable修饰成员变量 //常对象访问成员函数 person.MyFunc(); //常对象不能调用const的函数&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.4 友元生活中你的家有客厅(Public)，有你的卧室(Private) 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 但是呢，你也可以允许你的好闺蜜好基友进去。 在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术 友元的目的就是让一个函数或者类 访问另一个类中私有成员 友元的关键字为 &#x3D;&#x3D;friend&#x3D;&#x3D; 友元的三种实现 全局函数做友元 类做友元 成员函数做友元 4.4.1 全局函数做友元123456789101112131415161718192021222324252627282930313233343536373839404142class Building&#123; //告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容 friend void goodGay(Building * building);public: Building() &#123; this-&gt;m_SittingRoom = &quot;客厅&quot;; this-&gt;m_BedRoom = &quot;卧室&quot;; &#125;public: string m_SittingRoom; //客厅private: string m_BedRoom; //卧室&#125;;void goodGay(Building * building)&#123; cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123; Building b; goodGay(&amp;b);&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.4.2 类做友元12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Building;class goodGay&#123;public: goodGay(); void visit();private: Building *building;&#125;;class Building&#123; //告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容 friend class goodGay;public: Building();public: string m_SittingRoom; //客厅private: string m_BedRoom;//卧室&#125;;Building::Building()&#123; this-&gt;m_SittingRoom = &quot;客厅&quot;; this-&gt;m_BedRoom = &quot;卧室&quot;;&#125;goodGay::goodGay()&#123; building = new Building;&#125;void goodGay::visit()&#123; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123; goodGay gg; gg.visit();&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.4.3 成员函数做友元1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Building;class goodGay&#123;public: goodGay(); void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容 void visit2(); private: Building *building;&#125;;class Building&#123; //告诉编译器 goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容 friend void goodGay::visit();public: Building();public: string m_SittingRoom; //客厅private: string m_BedRoom;//卧室&#125;;Building::Building()&#123; this-&gt;m_SittingRoom = &quot;客厅&quot;; this-&gt;m_BedRoom = &quot;卧室&quot;;&#125;goodGay::goodGay()&#123; building = new Building;&#125;void goodGay::visit()&#123; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void goodGay::visit2()&#123; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; //cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123; goodGay gg; gg.visit();&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.5 运算符重载运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 4.5.1 加号运算符重载作用：实现两个自定义数据类型相加的运算 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Person &#123;public: Person() &#123;&#125;; Person(int a, int b) &#123; this-&gt;m_A = a; this-&gt;m_B = b; &#125; //成员函数实现 + 号运算符重载 Person operator+(const Person&amp; p) &#123; Person temp; temp.m_A = this-&gt;m_A + p.m_A; temp.m_B = this-&gt;m_B + p.m_B; return temp; &#125;public: int m_A; int m_B;&#125;;//全局函数实现 + 号运算符重载//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;// Person temp(0, 0);// temp.m_A = p1.m_A + p2.m_A;// temp.m_B = p1.m_B + p2.m_B;// return temp;//&#125;//运算符重载 可以发生函数重载 Person operator+(const Person&amp; p2, int val) &#123; Person temp; temp.m_A = p2.m_A + val; temp.m_B = p2.m_B + val; return temp;&#125;void test() &#123; Person p1(10, 10); Person p2(20, 20); //成员函数方式 Person p3 = p2 + p1; //相当于 p2.operaor+(p1) cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl; Person p4 = p3 + 10; //相当于 operator+(p3,10) cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;&#125;int main() &#123; test(); system(&quot;pause&quot;); return 0;&#125; 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的 总结2：不要滥用运算符重载 4.5.2 左移运算符重载作用：可以输出自定义数据类型 123456789101112131415161718192021222324252627282930313233343536373839404142class Person &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);public: Person(int a, int b) &#123; this-&gt;m_A = a; this-&gt;m_B = b; &#125; //成员函数 实现不了 p &lt;&lt; cout 不是我们想要的效果 //void operator&lt;&lt;(Person&amp; p)&#123; //&#125;private: int m_A; int m_B;&#125;;//全局函数实现左移重载//ostream对象只能有一个ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123; out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B; return out;&#125;void test() &#123; Person p1(10, 20); cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程&#125;int main() &#123; test(); system(&quot;pause&quot;); return 0;&#125; 总结：重载左移运算符配合友元可以实现输出自定义数据类型 4.5.3 递增运算符重载作用： 通过重载递增运算符，实现自己的整型数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class MyInteger &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);public: MyInteger() &#123; m_Num = 0; &#125; //前置++ MyInteger&amp; operator++() &#123; //先++ m_Num++; //再返回 return *this; &#125; //后置++ MyInteger operator++(int) &#123; //先返回 MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++； m_Num++; return temp; &#125;private: int m_Num;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) &#123; out &lt;&lt; myint.m_Num; return out;&#125;//前置++ 先++ 再返回void test01() &#123; MyInteger myInt; cout &lt;&lt; ++myInt &lt;&lt; endl; cout &lt;&lt; myInt &lt;&lt; endl;&#125;//后置++ 先返回 再++void test02() &#123; MyInteger myInt; cout &lt;&lt; myInt++ &lt;&lt; endl; cout &lt;&lt; myInt &lt;&lt; endl;&#125;int main() &#123; test01(); //test02(); system(&quot;pause&quot;); return 0;&#125; 总结： 前置递增返回引用，后置递增返回值 4.5.4 赋值运算符重载c++编译器至少给一个类添加4个函数 默认构造函数(无参，函数体为空) 默认析构函数(无参，函数体为空) 默认拷贝构造函数，对属性进行值拷贝 赋值运算符 operator&#x3D;, 对属性进行值拷贝 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Person&#123;public: Person(int age) &#123; //将年龄数据开辟到堆区 m_Age = new int(age); &#125; //重载赋值运算符 Person&amp; operator=(Person &amp;p) &#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; //编译器提供的代码是浅拷贝 //m_Age = p.m_Age; //提供深拷贝 解决浅拷贝的问题 m_Age = new int(*p.m_Age); //返回自身 return *this; &#125; ~Person() &#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; &#125; //年龄的指针 int *m_Age;&#125;;void test01()&#123; Person p1(18); Person p2(20); Person p3(30); p3 = p2 = p1; //赋值操作 cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;&#125;int main() &#123; test01(); //int a = 10; //int b = 20; //int c = 30; //c = b = a; //cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; //cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; //cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 4.5.5 关系运算符重载作用：重载关系运算符，可以让两个自定义类型对象进行对比操作 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125;; bool operator==(Person &amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return true; &#125; else &#123; return false; &#125; &#125; bool operator!=(Person &amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return false; &#125; else &#123; return true; &#125; &#125; string m_Name; int m_Age;&#125;;void test01()&#123; //int a = 0; //int b = 0; Person a(&quot;孙悟空&quot;, 18); Person b(&quot;孙悟空&quot;, 18); if (a == b) &#123; cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl; &#125; if (a != b) &#123; cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.5.6 函数调用运算符重载 函数调用运算符 () 也可以重载 由于重载后使用的方式非常像函数的调用，因此称为仿函数 仿函数没有固定写法，非常灵活 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class MyPrint&#123;public: void operator()(string text) &#123; cout &lt;&lt; text &lt;&lt; endl; &#125;&#125;;void test01()&#123; //重载的（）操作符 也称为仿函数 MyPrint myFunc; myFunc(&quot;hello world&quot;);&#125;class MyAdd&#123;public: int operator()(int v1, int v2) &#123; return v1 + v2; &#125;&#125;;void test02()&#123; MyAdd add; int ret = add(10, 10); cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl; //匿名对象调用 cout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 4.6 继承继承是面向对象三大特性之一 有些类与类之间存在特殊的关系，例如下图中： 我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。 这个时候我们就可以考虑利用继承的技术，减少重复代码 4.6.1 继承的基本语法例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同 接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处 普通实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//Java页面class Java &#123;public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl; &#125;&#125;;//Python页面class Python&#123;public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl; &#125;&#125;;//C++页面class CPP &#123;public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; //Java页面 cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //Python页面 cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //C++页面 cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 继承实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//公共页面class BasePage&#123;public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; &#125;&#125;;//Java页面class Java : public BasePage&#123;public: void content() &#123; cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl; &#125;&#125;;//Python页面class Python : public BasePage&#123;public: void content() &#123; cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl; &#125;&#125;;//C++页面class CPP : public BasePage&#123;public: void content() &#123; cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; //Java页面 cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //Python页面 cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //C++页面 cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 继承的好处：&#x3D;&#x3D;可以减少重复的代码&#x3D;&#x3D; class A : public B; A 类称为子类 或 派生类 B 类称为父类 或 基类 派生类中的成员，包含两大部分： 一类是从基类继承过来的，一类是自己增加的成员。 从基类继承过过来的表现其共性，而新增的成员体现了其个性。 4.6.2 继承方式继承的语法：class 子类 : 继承方式 父类 继承方式一共有三种： 公共继承 保护继承 私有继承 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Base1&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;//公共继承class Son1 :public Base1&#123;public: void func() &#123; m_A; //可访问 public权限 m_B; //可访问 protected权限 //m_C; //不可访问 &#125;&#125;;void myClass()&#123; Son1 s1; s1.m_A; //其他类只能访问到公共权限&#125;//保护继承class Base2&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;class Son2:protected Base2&#123;public: void func() &#123; m_A; //可访问 protected权限 m_B; //可访问 protected权限 //m_C; //不可访问 &#125;&#125;;void myClass2()&#123; Son2 s; //s.m_A; //不可访问&#125;//私有继承class Base3&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;class Son3:private Base3&#123;public: void func() &#123; m_A; //可访问 private权限 m_B; //可访问 private权限 //m_C; //不可访问 &#125;&#125;;class GrandSon3 :public Son3&#123;public: void func() &#123; //Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到 //m_A; //m_B; //m_C; &#125;&#125;; 4.6.3 继承中的对象模型问题：从父类继承过来的成员，哪些属于子类对象中？ 示例： 123456789101112131415161718192021222324252627282930class Base&#123;public: int m_A;protected: int m_B;private: int m_C; //私有成员只是被隐藏了，但是还是会继承下去&#125;;//公共继承class Son :public Base&#123;public: int m_D;&#125;;void test01()&#123; cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 利用工具查看： 打开工具窗口后，定位到当前CPP文件的盘符 然后输入： cl &#x2F;d1 reportSingleClassLayout查看的类名 所属文件名 效果如下图： 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到 4.6.4 继承中构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数 问题：父类和子类的构造和析构顺序是谁先谁后？ 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142class Base &#123;public: Base() &#123; cout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl; &#125;&#125;;class Son : public Base&#123;public: Son() &#123; cout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; //继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 Son s;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 4.6.5 继承同名成员处理方式问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？ 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Base &#123;public: Base() &#123; m_A = 100; &#125; void func() &#123; cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl; &#125; void func(int a) &#123; cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl; &#125;public: int m_A;&#125;;class Son : public Base &#123;public: Son() &#123; m_A = 200; &#125; //当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数 //如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域 void func() &#123; cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl; &#125;public: int m_A;&#125;;void test01()&#123; Son s; cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl; s.func(); s.Base::func(); s.Base::func(10);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return EXIT_SUCCESS;&#125; 总结： 子类对象可以直接访问到子类中同名成员 子类对象加作用域可以访问到父类同名成员 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数 4.6.6 继承同名静态成员处理方式问题：继承中同名的静态成员在子类对象上如何进行访问？ 静态成员和非静态成员出现同名，处理方式一致 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Base &#123;public: static void func() &#123; cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl; &#125; static void func(int a) &#123; cout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl; &#125; static int m_A;&#125;;int Base::m_A = 100;class Son : public Base &#123;public: static void func() &#123; cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl; &#125; static int m_A;&#125;;int Son::m_A = 200;//同名成员属性void test01()&#123; //通过对象访问 cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl; Son s; cout &lt;&lt; &quot;Son 下 m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl; //通过类名访问 cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl; cout &lt;&lt; &quot;Son 下 m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;&#125;//同名成员函数void test02()&#123; //通过对象访问 cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl; Son s; s.func(); s.Base::func(); cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl; Son::func(); Son::Base::func(); //出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问 Son::Base::func(100);&#125;int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名） 4.6.7 多继承语法C++允许一个类继承多个类 语法： class 子类 ：继承方式 父类1 ， 继承方式 父类2... 多继承可能会引发父类中有同名成员出现，需要加作用域区分 C++实际开发中不建议用多继承 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Base1 &#123;public: Base1() &#123; m_A = 100; &#125;public: int m_A;&#125;;class Base2 &#123;public: Base2() &#123; m_A = 200; //开始是m_B 不会出问题，但是改为mA就会出现不明确 &#125;public: int m_A;&#125;;//语法：class 子类：继承方式 父类1 ，继承方式 父类2 class Son : public Base2, public Base1 &#123;public: Son() &#123; m_C = 300; m_D = 400; &#125;public: int m_C; int m_D;&#125;;//多继承容易产生成员同名的情况//通过使用类名作用域可以区分调用哪一个基类的成员void test01()&#123; Son s; cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(s) &lt;&lt; endl; cout &lt;&lt; s.Base1::m_A &lt;&lt; endl; cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域 4.6.8 菱形继承菱形继承概念： ​ 两个派生类继承同一个基类 ​ 又有某个类同时继承者两个派生类 ​ 这种继承被称为菱形继承，或者钻石继承 典型的菱形继承案例： 菱形继承问题： 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。 示例： 1234567891011121314151617181920212223242526272829303132class Animal&#123;public: int m_Age;&#125;;//继承前加virtual关键字后，变为虚继承//此时公共的父类Animal称为虚基类class Sheep : virtual public Animal &#123;&#125;;class Tuo : virtual public Animal &#123;&#125;;class SheepTuo : public Sheep, public Tuo &#123;&#125;;void test01()&#123; SheepTuo st; st.Sheep::m_Age = 100; st.Tuo::m_Age = 200; cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl; cout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt; st.Tuo::m_Age &lt;&lt; endl; cout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 菱形继承： 12345678910class A &#123; public: int data; &#125;;class B : public A &#123;&#125;;class C : public A &#123;&#125;;class D : public B, public C &#123;&#125;;int main() &#123; D d; d.data = 10; // 错误！二义性：不知道访问 B::data 还是 C::data d.B::data = 10; // 需显式指定路径（仍有重复内存）&#125; 解决方案：虚继承 123456789101112131415//利用虚继承后class A &#123; public: int data; &#125;;// 关键：使用 virtual 继承class B : virtual public A &#123;&#125;; // 虚继承class C : virtual public A &#123;&#125;; // 虚继承class D : public B, public C &#123;&#125;;int main() &#123; D d; d.data = 10; // ✅ 正确！不再有二义性 d.B::data = 20; // ✅ 修改的是同一份数据 d.C::data = 30; // ✅ 值变为30（共享同一份）&#125; 内存对比： 123456789101112普通继承：D &#123; B &#123; A &#123; data &#125; &#125; C &#123; A &#123; data &#125; &#125; // 每个派生类对象都保留了父类的成员，产生了重复副本！&#125;虚继承：D &#123; B &#123; ... &#125; C &#123; ... &#125; 共享的 A &#123; data &#125; // 唯一副本&#125; 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义 利用虚继承可以解决菱形继承问题 4.7 多态4.7.1 多态的基本概念多态是C++面向对象三大特性之一 多态分为两类 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名 动态多态: 派生类和虚函数实现运行时多态 静态多态和动态多态区别： 静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 - 运行阶段确定函数地址 下面通过案例进行讲解多态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Animal&#123;public: //Speak函数就是虚函数 //函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。 virtual void speak() &#123; cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl; &#125;&#125;;class Cat :public Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125;&#125;;class Dog :public Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl; &#125;&#125;;//我们希望传入什么对象，那么就调用什么对象的函数//如果函数地址在编译阶段就能确定，那么静态联编//如果函数地址在运行阶段才能确定，就是动态联编void DoSpeak(Animal &amp; animal)&#123; animal.speak();&#125;////多态满足条件： //1、有继承关系//2、子类重写父类中的虚函数//多态使用：//父类指针或引用指向子类对象void test01()&#123; Cat cat; DoSpeak(cat); Dog dog; DoSpeak(dog);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 多态满足条件 有继承关系 子类重写父类中的虚函数 多态使用条件 父类指针或引用指向子类对象 重写：函数返回值类型 函数名 参数列表 完全一致称为重写 4.7.2 多态案例一-计算器类案例描述： 分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类 多态的优点： 代码组织结构清晰 可读性强 利于前期和后期的扩展以及维护 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//普通实现class Calculator &#123;public: int getResult(string oper) &#123; if (oper == &quot;+&quot;) &#123; return m_Num1 + m_Num2; &#125; else if (oper == &quot;-&quot;) &#123; return m_Num1 - m_Num2; &#125; else if (oper == &quot;*&quot;) &#123; return m_Num1 * m_Num2; &#125; //如果要提供新的运算，需要修改源码 &#125;public: int m_Num1; int m_Num2;&#125;;void test01()&#123; //普通实现测试 Calculator c; c.m_Num1 = 10; c.m_Num2 = 10; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;&#125;//多态实现//抽象计算器类//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护class AbstractCalculator&#123;public : virtual int getResult() &#123; return 0; &#125; int m_Num1; int m_Num2;&#125;;//加法计算器class AddCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 + m_Num2; &#125;&#125;;//减法计算器class SubCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 - m_Num2; &#125;&#125;;//乘法计算器class MulCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 * m_Num2; &#125;&#125;;void test02()&#123; //创建加法计算器 AbstractCalculator *abc = new AddCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; //用完了记得销毁 //创建减法计算器 abc = new SubCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; //创建乘法计算器 abc = new MulCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc;&#125;int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多 4.7.3 纯虚函数和抽象类在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容 因此可以将虚函数改为纯虚函数 纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ; 当类中有了纯虚函数，这个类也称为&#x3D;&#x3D;抽象类&#x3D;&#x3D; 抽象类特点： 无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 示例： 123456789101112131415161718192021222324252627282930313233343536class Base&#123;public: //纯虚函数 //类中只要有一个纯虚函数就称为抽象类 //抽象类无法实例化对象 //子类必须重写父类中的纯虚函数，否则也属于抽象类 virtual void func() = 0;&#125;;class Son :public Base&#123;public: virtual void func() &#123; cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl; &#125;;&#125;;void test01()&#123; Base * base = NULL; //base = new Base; // 错误，抽象类无法实例化对象 base = new Son; base-&gt;func(); delete base;//记得销毁&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.7.4 多态案例二-制作饮品案例描述： 制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料 利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//抽象制作饮品class AbstractDrinking &#123;public: //烧水 virtual void Boil() = 0; //冲泡 virtual void Brew() = 0; //倒入杯中 virtual void PourInCup() = 0; //加入辅料 virtual void PutSomething() = 0; //规定流程 void MakeDrink() &#123; Boil(); Brew(); PourInCup(); PutSomething(); &#125;&#125;;//制作咖啡class Coffee : public AbstractDrinking &#123;public: //烧水 virtual void Boil() &#123; cout &lt;&lt; &quot;煮农夫山泉!&quot; &lt;&lt; endl; &#125; //冲泡 virtual void Brew() &#123; cout &lt;&lt; &quot;冲泡咖啡!&quot; &lt;&lt; endl; &#125; //倒入杯中 virtual void PourInCup() &#123; cout &lt;&lt; &quot;将咖啡倒入杯中!&quot; &lt;&lt; endl; &#125; //加入辅料 virtual void PutSomething() &#123; cout &lt;&lt; &quot;加入牛奶!&quot; &lt;&lt; endl; &#125;&#125;;//制作茶水class Tea : public AbstractDrinking &#123;public: //烧水 virtual void Boil() &#123; cout &lt;&lt; &quot;煮自来水!&quot; &lt;&lt; endl; &#125; //冲泡 virtual void Brew() &#123; cout &lt;&lt; &quot;冲泡茶叶!&quot; &lt;&lt; endl; &#125; //倒入杯中 virtual void PourInCup() &#123; cout &lt;&lt; &quot;将茶水倒入杯中!&quot; &lt;&lt; endl; &#125; //加入辅料 virtual void PutSomething() &#123; cout &lt;&lt; &quot;加入枸杞!&quot; &lt;&lt; endl; &#125;&#125;;//业务函数void DoWork(AbstractDrinking* drink) &#123; drink-&gt;MakeDrink(); delete drink;&#125;void test01() &#123; DoWork(new Coffee); cout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl; DoWork(new Tea);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.7.5 虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码 解决方式：将父类中的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构共性： 可以解决父类指针释放子类对象 都需要有具体的函数实现 虚析构和纯虚析构区别： 如果是纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法： virtual ~类名()&#123;&#125; 纯虚析构语法： virtual ~类名() = 0; 类名::~类名()&#123;&#125; 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Animal &#123;public: Animal() &#123; cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl; &#125; virtual void Speak() = 0; //析构函数加上virtual关键字，变成虚析构函数 //virtual ~Animal() //&#123; // cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl; //&#125; virtual ~Animal() = 0;&#125;;Animal::~Animal()&#123; cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;&#125;//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。class Cat : public Animal &#123;public: Cat(string name) &#123; cout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl; m_Name = new string(name); &#125; virtual void Speak() &#123; cout &lt;&lt; *m_Name &lt;&lt; &quot;小猫在说话!&quot; &lt;&lt; endl; &#125; ~Cat() &#123; cout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl; if (this-&gt;m_Name != NULL) &#123; delete m_Name; m_Name = NULL; &#125; &#125;public: string *m_Name;&#125;;void test01()&#123; Animal *animal = new Cat(&quot;Tom&quot;); animal-&gt;Speak(); //通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏 //怎么解决？给基类增加一个虚析构函数 //虚析构函数就是用来解决通过父类指针释放子类对象 delete animal;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： ​ 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象 ​ 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构 ​ 3. 拥有纯虚析构函数的类也属于抽象类 4.7.6 多态案例三-电脑组装案例描述： 电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储） 将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商 创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口 测试时组装三台不同的电脑进行工作 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;iostream&gt;using namespace std;//抽象CPU类class CPU&#123;public: //抽象的计算函数 virtual void calculate() = 0;&#125;;//抽象显卡类class VideoCard&#123;public: //抽象的显示函数 virtual void display() = 0;&#125;;//抽象内存条类class Memory&#123;public: //抽象的存储函数 virtual void storage() = 0;&#125;;//电脑类class Computer&#123;public: Computer(CPU * cpu, VideoCard * vc, Memory * mem) &#123; m_cpu = cpu; m_vc = vc; m_mem = mem; &#125; //提供工作的函数 void work() &#123; //让零件工作起来，调用接口 m_cpu-&gt;calculate(); m_vc-&gt;display(); m_mem-&gt;storage(); &#125; //提供析构函数 释放3个电脑零件 ~Computer() &#123; //释放CPU零件 if (m_cpu != NULL) &#123; delete m_cpu; m_cpu = NULL; &#125; //释放显卡零件 if (m_vc != NULL) &#123; delete m_vc; m_vc = NULL; &#125; //释放内存条零件 if (m_mem != NULL) &#123; delete m_mem; m_mem = NULL; &#125; &#125;private: CPU * m_cpu; //CPU的零件指针 VideoCard * m_vc; //显卡零件指针 Memory * m_mem; //内存条零件指针&#125;;//具体厂商//Intel厂商class IntelCPU :public CPU&#123;public: virtual void calculate() &#123; cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl; &#125;&#125;;class IntelVideoCard :public VideoCard&#123;public: virtual void display() &#123; cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl; &#125;&#125;;class IntelMemory :public Memory&#123;public: virtual void storage() &#123; cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl; &#125;&#125;;//Lenovo厂商class LenovoCPU :public CPU&#123;public: virtual void calculate() &#123; cout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl; &#125;&#125;;class LenovoVideoCard :public VideoCard&#123;public: virtual void display() &#123; cout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl; &#125;&#125;;class LenovoMemory :public Memory&#123;public: virtual void storage() &#123; cout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; //第一台电脑零件 CPU * intelCpu = new IntelCPU; VideoCard * intelCard = new IntelVideoCard; Memory * intelMem = new IntelMemory; cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl; //创建第一台电脑 Computer * computer1 = new Computer(intelCpu, intelCard, intelMem); computer1-&gt;work(); delete computer1; cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl; //第二台电脑组装 Computer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);; computer2-&gt;work(); delete computer2; cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl; //第三台电脑组装 Computer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);; computer3-&gt;work(); delete computer3;&#125; 5 文件操作程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放 通过文件可以将数据持久化 C++中对文件操作需要包含头文件 &#x3D;&#x3D;&lt; fstream &gt;&#x3D;&#x3D; 文件类型分为两种： 文本文件 - 文件以文本的ASCII码形式存储在计算机中 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们 操作文件的三大类: ofstream：写操作 ifstream： 读操作 fstream ： 读写操作 5.1文本文件5.1.1写文件 写文件步骤如下： 包含头文件 #include &lt;fstream&gt; 创建流对象 ofstream ofs; 打开文件 ofs.open(“文件路径”,打开方式); 写数据 ofs &lt;&lt; “写入的数据”; 关闭文件 ofs.close(); 文件打开方式： 打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件而打开文件 ios::ate 初始位置：文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在先删除，再创建 ios::binary 二进制方式 注意： 文件打开方式可以配合使用，利用|操作符 例如：用二进制方式写文件 ios::binary | ios:: out 示例： 12345678910111213141516171819202122#include &lt;fstream&gt;void test01()&#123; ofstream ofs; ofs.open(&quot;test.txt&quot;, ios::out); ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl; ofs.close();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 文件操作必须包含头文件 fstream 读文件可以利用 ofstream ，或者fstream类 打开文件时候需要指定操作文件的路径，以及打开方式 利用&lt;&lt;可以向文件中写数据 操作完毕，要关闭文件 5.1.2读文件读文件与写文件步骤相似，但是读取方式相对于比较多 读文件步骤如下： 包含头文件 #include &lt;fstream&gt; 创建流对象 ifstream ifs; 打开文件并判断文件是否打开成功 ifs.open(“文件路径”,打开方式); 读数据 四种方式读取 关闭文件 ifs.close(); 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;fstream&gt;#include &lt;string&gt;void test01()&#123; ifstream ifs; ifs.open(&quot;test.txt&quot;, ios::in); if (!ifs.is_open()) &#123; cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; return; &#125; //第一种方式 //char buf[1024] = &#123; 0 &#125;; //while (ifs &gt;&gt; buf) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; //第二种 //char buf[1024] = &#123; 0 &#125;; //while (ifs.getline(buf,sizeof(buf))) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; //第三种 //string buf; //while (getline(ifs, buf)) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; char c; while ((c = ifs.get()) != EOF) &#123; cout &lt;&lt; c; &#125; ifs.close();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 读文件可以利用 ifstream ，或者fstream类 利用is_open函数可以判断文件是否打开成功 close 关闭文件 5.2 二进制文件以二进制的方式对文件进行读写操作 打开方式要指定为 &#x3D;&#x3D;ios::binary&#x3D;&#x3D; 5.2.1 写文件二进制方式写文件主要利用流对象调用成员函数write 函数原型 ：ostream&amp; write(const char * buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 示例： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public: char m_Name[64]; int m_Age;&#125;;//二进制文件 写文件void test01()&#123; //1、包含头文件 //2、创建输出流对象 ofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary); //3、打开文件 //ofs.open(&quot;person.txt&quot;, ios::out | ios::binary); Person p = &#123;&quot;张三&quot; , 18&#125;; //4、写文件 ofs.write((const char *)&amp;p, sizeof(p)); //5、关闭文件 ofs.close();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 文件输出流对象 可以通过write函数，以二进制方式写数据 5.2.2 读文件二进制方式读文件主要利用流对象调用成员函数read 函数原型：istream&amp; read(char *buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 示例： 1234567891011121314151617181920212223242526272829303132#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public: char m_Name[64]; int m_Age;&#125;;void test01()&#123; ifstream ifs(&quot;person.txt&quot;, ios::in | ios::binary); if (!ifs.is_open()) &#123; cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; &#125; Person p; ifs.read((char *)&amp;p, sizeof(p)); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 文件输入流对象 可以通过read函数，以二进制方式读数据","link":"","tags":[{"name":"C++","slug":"C","permalink":"https://lyroom.github.io/tags/C/"},{"name":"面向对象","slug":"面向对象","permalink":"https://lyroom.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"编程技术","slug":"编程技术","permalink":"https://lyroom.github.io/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"}]},{"title":"shell小工具推荐——tldr","date":"2024-10-14T06:27:55.000Z","path":"2024/10/14/shell小工具推荐——tldr/","text":"tldr使用效果今天偶然发现了一个宝藏shell工具，推荐linux，macos用户使用：tldr 在使用man手册查询命令的功能时候，往往会出现一大堆参数，如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950$ man lsLS(1) User Commands LS(1)NAME ls - list directory contentsSYNOPSIS ls [OPTION]... [FILE]...DESCRIPTION List information about the FILEs (the current directory by default). Sort entries alphabetically if none of -cftuvSUX nor --sort is speci‐ fied. Mandatory arguments to long options are mandatory for short options too. -a, --all do not ignore entries starting with . -A, --almost-all do not list implied . and .. --author with -l, print the author of each file -b, --escape print C-style escapes for nongraphic characters --block-size=SIZE with -l, scale sizes by SIZE when printing them; e.g., &#x27;--block-size=M&#x27;; see SIZE format below -B, --ignore-backups do not list implied entries ending with ~ -c with -lt: sort by, and show, ctime (time of last modification of file status information); with -l: show ctime and sort by name; otherwise: sort by ctime, newest first -C list entries by columns --color[=WHEN] colorize the output; WHEN can be &#x27;always&#x27; (default if omitted), &#x27;auto&#x27;, or &#x27;never&#x27;; more info below -d, --directory 我们有时候需要快速的使用这个命令，而不希望需要查阅这么多的资料，这时候tldr工具就来了，使用效果如下： 12345678910111213141516171819202122232425262728293031$ tldr lsls 列出目录中的内容。 更多信息：https://www.gnu.org/software/coreutils/ls. - 列出目录中的文件，每个文件占一行： ls -1 - 列出包含隐藏文件的所有文件： ls -a - 列出所有文件，如果是目录，则在目录名后面加上「/」： ls -F - 列出包含隐藏文件的所有文件信息，包括权限，所有者，大小和修改日期： ls -la - 列出所有文件信息，大小用人类可读的单位表示（KiB, MiB, GiB）： ls -lh - 列出所有文件信息，按大小降序排序： ls -lSR - 列出所有文件信息，按修改日期从旧到新排序： ls -ltr - 只列出目录： ls -d */ tldr+命令可以快速且简短的给出使用说明，很节省时间。 tldr安装tldr：全称是：too long，don&#96;t read,就是为了简短的显示命令的使用方式，以下是ubuntu下的安装方法。 sudo apt install tldr 以上方法被舍弃的原因是更新太麻烦了，tldr --update经常卡住，所以我们选择一种新的方法安装。 tealdeer代替node.js安装12345# 卸载npm安装的tldrnpm uninstall -g tldr# 安装tealdeersudo apt updatesudo apt install tealdeer 手动配置配置文件需要我们手动创建配置文件 1234# 创建新的目录mkdir -p ~/.config/tealdeer# 创建配置文件touch ~/.config/tealdeer/config.toml 配置文件内容如下： 12345678910111213141516171819202122# tealdeer 配置文件 (~/.config/tealdeer/config.toml)[display]# 设置显示语言为中文language = &quot;zh&quot;# 启用彩色输出（auto = 根据终端自动判断，always = 总是彩色，never = 禁用彩色）use_color = &quot;auto&quot;# 是否显示命令示例前的标题（比如 &quot;Examples&quot;）show_headers = true# 是否显示超链接（有的命令会带参考链接）hyperlinks = true[updates]# 自动更新启用auto_update = true# 自动更新的时间间隔（单位：小时）# 这里设置为 168 小时 = 7 天auto_update_interval_hours = 168 汉化前提是你安装了nodejs和npm,安装tldr客户端sudo npm install -g tldr设置语言环境为中文，修改系统变量 首先查看终端语言环境和系统默认语言环境： 12localeecho $LANG 如果显示如下 12345678910111213141516171819localeLANG=en_US.UTF-8LANGUAGE=en_US.UTF-8LC_CTYPE=&quot;en_US.UTF-8&quot;LC_NUMERIC=&quot;en_US.UTF-8&quot;LC_TIME=&quot;en_US.UTF-8&quot;LC_COLLATE=&quot;en_US.UTF-8&quot;LC_MONETARY=&quot;en_US.UTF-8&quot;LC_MESSAGES=&quot;en_US.UTF-8&quot;LC_PAPER=&quot;en_US.UTF-8&quot;LC_NAME=&quot;en_US.UTF-8&quot;LC_ADDRESS=&quot;en_US.UTF-8&quot;LC_TELEPHONE=&quot;en_US.UTF-8&quot;LC_MEASUREMENT=&quot;en_US.UTF-8&quot;LC_IDENTIFICATION=&quot;en_US.UTF-8&quot;LC_ALL=en_US.UTF-8echo $LANGen_US.UTF-8 则表明终端语言环境（LANG）和系统语言环境（LC_ALL）均为英文，我们需要修改终端语言环境如下： 1vim ~/.bashrc 在文件末尾添加： 123456export TLDR_LANG=zhexport TLDR_LANGUAGE=zh_Hansexport LANG=zh_CN.UTF-8export TEALDEER_LANGUAGE=zhexport LANGUAGE=zh_CN:zhunset LC_All #仅仅修改终端让其不生效 最后更新一下是更改生效： 1source ~/.bashrc 更新tldr缓存12tldr --updatetldr ls # 查看一下成果吧 接下来就可以愉快使用啦！","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://lyroom.github.io/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://lyroom.github.io/tags/shell/"},{"name":"shell工具推荐","slug":"shell工具推荐","permalink":"https://lyroom.github.io/tags/shell%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"}]},{"title":"github学习","date":"2024-10-11T09:05:12.000Z","path":"2024/10/11/github学习/","text":"本文会较为详细的学习github的一些操作，以下是具体的步骤。 安装与配置git安装git的环境，在这里有详细的解答,便不过多赘述了。 git学习这是git操作的基本流程 Repository,index,workspace，都存储在本地 一. git的基本操作（这部分由master完成）git init-初始化一个本地仓库1$ git init #初始化了一个本地仓库，建立了一个.git文件夹 这是git init后当前文件夹的目录结构图，将仓库，暂存区和工作树（项目本地目录）都确定下来了。 12345678910111213141516githublearning ├── .git │ ├── branches │ ├── COMMIT_EDITMSG │ ├── config │ ├── description │ ├── HEAD │ ├── hooks │ ├── index │ ├── info │ ├── logs │ ├── objects │ └── refs ├── git学习.md ├── GitHub.webp └── README.md 工作树：.git所在的目录，就是workplace。本例中就是githublearning文件夹，该文件夹内的内容就是需要版本控制的文件 暂存区：.git下的index的文件 仓库：.git文件夹就是仓库 ​ **HEAD**：这是一个指向当前活动分支的引用，它告诉 Git 你当前处在哪个分支上。 ​ **config**：存储仓库级别的配置信息，如用户信息、远程仓库地址等。 ​ **refs**：存储分支（refs/heads/）、标签（refs/tags/）等引用。每个分支和标签都指向特定的提交对象。 ​ **objects**：存储 Git 对象（提交、树、文件 blob）的数据库。Git 是通过哈希（SHA-1 值）来存储每个对象的，确保了内容的唯一性和完整性。 ​ **index**：即暂存区，用于存储那些你已经用 git add 命令暂存的更改，准备提交时从这里取数据。 ​ **logs**：保存引用的历史，记录了每个分支或引用的变更日志，便于追踪。 12345678$ git status #记录着当前处于master还是branch分支，有无需要commit的文件等##以下是状态位于分支 master要提交的变更： （使用 &quot;git restore --staged &lt;文件&gt;...&quot; 以取消暂存） 修改： &quot;git\\345\\255\\246\\344\\271\\240.md&quot; gid add-向暂存区添加文件123git add xxx.cpp #上传一个xxx.cpp文件git add -A #上传当前文件夹下的所有文件git add . #同上 git commit-提交到本地仓库12$ git commit -m “本次提交的备注” #上传到master分支，并打上备注$ git commit #可以直接commit，之后再详细编辑备注 git log-查看提交日志查看全部日志 123456789101112131415161718$ git log##以下是日志内容commit b3f611dafea403f51c52a04491a23e1e4e059190 (HEAD -&gt; master)Author: lyroom &lt;codingfish@outlook.com&gt;Date: Sat Oct 12 13:07:04 2024 +0800 这是我的第二次详细修改 xxxxxxxxxxxxxxxxxxxxxxxxxxxxcommit d1f94f3bb752ad1fc2551cd9ccb06c8eee5a39c8Author: lyroom &lt;codingfish@outlook.com&gt;Date: Sat Oct 12 13:04:45 2024 +0800 第一次提交 查看日志常用快捷键：和man操作，less操作基本一样f：往后翻一页b：往前翻一页 也可以简短一行的输出每次提交的修改 12345678910111213141516$ git log --pretty=short##以下是日志内容commit b3f611dafea403f51c52a04491a23e1e4e059190 (HEAD -&gt; master)Author: lyroom &lt;codingfish@outlook.com&gt;Date: Sat Oct 12 13:07:04 2024 +0800 这是我的第二次详细修改commit d1f94f3bb752ad1fc2551cd9ccb06c8eee5a39c8Author: lyroom &lt;codingfish@outlook.com&gt;Date: Sat Oct 12 13:04:45 2024 +0800 第一次提交 也可以查看文件前后修改的对比 123456789101112131415$ git log -p README.md##以下是对比内容Author: lyroom &lt;codingfish@outlook.com&gt;Date: Sat Oct 12 15:33:31 2024 +0800 这是第七次修改diff --git a/README.md b/README.mdindex 5f9894b..ffbea86 100644--- a/README.md+++ b/README.md@@ -1 +1,2 @@ 第六次修改+第七次修改 也可以以图形的方式查看提交历史 1$ git log --graph git diff-查看更改前后的区别git diff命令可以查看工作树、暂存区、仓库最新提交之间的差别。 查看工作树和暂存区的区别1$ git diff vscode配合gitlens插件可以清楚看到本地工作目录（左边）和暂存区（右边）的区别，红色表示删除，绿色表示新添加的内容 当然使用git diff命令也能明显的看出区别，如下,+代表添加或者修改，-代表删除内容：这两种方法都可以看出工作树和暂存区的区别当我git add -A后，git diff就无任何输出了 查看工作树和本地仓库最新提交的差别1$ git diff HEAD 由于本地工作树和暂存区内容是一样的， 这个命令比较的就是仓库的最新提交和工作树的区别，比较的结果形式和上面的比较是一样的，就不贴图了 二. 分支操作（本部分由分支1完成）通常一个大型的项目视需要多人合作完成的，每个人负责不同的模块和功能，这通常是并行进行的，所以我们需要分支进行，在各自的功能没有完全上线，各个分支和已经上线的程序master应互不干扰！分支1完成后，需要与master合并 git branch-显示所有的分支12$ git branch* master 当前只有一个master分支，*指向了master分支，表示当前处于master分支下 git checkout -b-创建切换分支创建切换分支1创建一个名字为分支1的分支，并切换到分支1下： 1$ git checkout -b 分支1 查看结果： 123$ git branch master* 分支1 等价操作： 12git branch 分支1 #创建一个名为分支1的分支git checkout 分支1 #切换到分支1下 提交修改： 12git add -Agit commit -m &quot;分支1的第一次提交&quot; 切换到到master分支1git checkout master #切换到主分支 继续查看当前文件大纲，发现master分支的大纲并没有分支1的这部分的文字，如下图： 而在分支1的大纲是这样的： 切换到上一个分支1git checkout - 分支的删除1234git branch -d 分支名$ git branch -d 分支1已删除分支 分支1（曾为 6dfa1e7）。 分支的分类在 GitHub 或 Git 版本控制系统中，特性分支（feature branch）和主干分支（通常是 main 或 master 分支）是两种常见的分支类型，它们用于不同的开发目的： 1. 主干分支（Main&#x2F;Master Branch） 作用：主干分支是项目的稳定版本，通常包含可部署的代码。它是团队协作时的主分支，代表项目当前的生产环境代码。 特点： 代码通常是稳定的、经过测试的版本。 项目的发布版本往往基于主干分支。 只有当代码经过充分测试、代码审核通过后，才会合并到主干分支。 2. 特性分支（Feature Branch） 作用：特性分支用于开发某个特定的功能或修复某个 bug。每个新功能、改进或问题修复通常会创建一个单独的特性分支，以便与主干分支保持隔离，确保主干分支的稳定性。 特点： 每个特性分支的命名通常与开发的功能相关，如 feature/login-system 或 feature/add-profile-page。 开发人员可以自由地在特性分支上进行实验，而不会影响到其他开发者的工作或主干分支的稳定性。 开发完成后，特性分支会通过 Pull Request 进行代码审核，测试通过后才合并到主干分支。流程： 从主干分支拉取最新代码，创建一个新的特性分支。 在特性分支上开发和测试功能。 开发完成后，提交 Pull Request 以请求将特性分支的代码合并到主干分支。 经过代码审核和测试，确认无问题后合并到主干分支。 这种分支模型能够帮助团队并行开发不同功能，同时确保主干分支始终保持在一个稳定的状态。 git merge-分支的合并合并分支分支1已经完成了当前的功能，需要与master合并1.切换回主干分支 1git checkout master 2.合并分支 1git merge --no-ff 分支1 冲突解决每次的合并并都不是一帆风顺的，如果分支修改了相同的文件，就会产生冲突，需要手动解决冲突以下是合并后的报错，提示有冲突： 123456$ git merge --no-ff 分支1自动合并 git学习.md冲突（内容）：合并冲突于 git学习.md自动合并失败，修正冲突然后提交修正的结果。 解决办法： 1.查看合并的状态，找到冲突的文件12345678910111213141516git status位于分支 master您的分支领先 &#x27;origin/master&#x27; 共 20 个提交。 （使用 &quot;git push&quot; 来发布您的本地提交）您有尚未合并的路径。 （解决冲突并运行 &quot;git commit&quot;） （使用 &quot;git merge --abort&quot; 终止合并）未合并的路径： （使用 &quot;git add &lt;文件&gt;...&quot; 标记解决方案） 双方修改： README.md修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;） 2.打开冲突的文件（README.md），解决冲突打开文件，会发现文件中有以下的标注，如下： 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD（当前分支的内容）这是当前分支的内容======= # 分割线，上面的是master内容，下面是分支1的内容这是branch修改的的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch（传入合并分支的内容） 可以手动的选择要保留的内容，保留后，删除’&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD’，’&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ‘，’&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch’，等标注，保存文件即可。 3.提交解决冲突后的文件12git add README.mdgit commit -m &quot;解决冲突&quot; 4.合并完成1git merge 分支1 git log-以图表的形式查看分支可以以图形的方式查看分支的合并情况，并且看到分支的提交记录 1234567891011121314151617181920212223242526272829303132333435363738git log --graph* commit 307375175df620d5a6e9e913a0c92a61c5af91a7 (HEAD -&gt; master)|\\ Merge: 788c7a9 c4687fb| | Author: lyroom &lt;codingfish@outlook.com&gt;| | Date: Tue Oct 15 09:32:29 2024 +0800| | | | Merge branch &#x27;分支1&#x27;| | | * commit c4687fbd37f633b82b74ad6048daf356610b4c03 (分支1)| | Author: lyroom &lt;codingfish@outlook.com&gt;| | Date: Tue Oct 15 09:31:23 2024 +0800| | | | 这是分支一的第五次修改| | * | commit 788c7a90543f684b062e3b514db4adcbdd52cf99| | Author: lyroom &lt;codingfish@outlook.com&gt;| | Date: Tue Oct 15 09:27:33 2024 +0800| | | | master merge后的第一次提交| | * | commit c9cc7dcb6d5283b0dfd4fc149d067c70940a867f| | Author: lyroom &lt;codingfish@outlook.com&gt;| | Date: Tue Oct 15 09:23:37 2024 +0800| | | | real mergegit add -A!| | * | commit ac08a828e2279d605a40a6a3d674ec78b7cdf949|\\| Merge: 9c20e8d 3aa2344| | Author: lyroom &lt;codingfish@outlook.com&gt;| | Date: Tue Oct 15 09:16:17 2024 +0800| | | | 第一次合并后的提交| | | * commit 3aa23441ddb6cdf4ff390d191b69850395fd2e6c| | Author: lyroom &lt;codingfish@outlook.com&gt;...... 三. 更改提交的操作git reset-回溯历史版本为了有助于学习，我们先回到创建分支1的时候，然后创建一个fix—B的特性分支 回到分支1创建前1git reset --hard hash值 #这个hash值就是每次commit后的hash值 如果你没有做好标记寻找创建分支前的hash值的技巧：git log –graph ,找到分叉前的一个提交的hash值!，如下就是第8次修改的hash值 | | Author: lyroom &#x63;&#x6f;&#x64;&#105;&#x6e;&#x67;&#x66;&#105;&#115;&#104;&#64;&#x6f;&#117;&#116;&#x6c;&#x6f;&#x6f;&#107;&#46;&#99;&#x6f;&#109; | | Date: Mon Oct 14 16:59:48 2024 +0800 | | | | master的第10次提交 | | * | commit 7362bced26a2648153fac6779e4c5d2067eab42b |&#x2F; Author: lyroom &#x63;&#x6f;&#x64;&#105;&#x6e;&#x67;&#x66;&#105;&#115;&#x68;&#x40;&#111;&#117;&#116;&#108;&#x6f;&#111;&#107;&#x2e;&#99;&#x6f;&#109; | Date: Mon Oct 14 16:57:45 2024 +0800 | | master下的第九次修改 | * commit 61126b34e2330bad3945c616374df80de7346be1 | Author: lyroom &#99;&#111;&#x64;&#x69;&#110;&#103;&#102;&#x69;&#115;&#104;&#x40;&#x6f;&#x75;&#x74;&#x6c;&#111;&#111;&#107;&#46;&#99;&#111;&#109; | Date: Mon Oct 14 16:17:33 2024 +0800 | | 第8次修改 | * commit ce7d1ccfd971bed9e79a3ececcdb67df97428692 | Author: lyroom &#99;&#111;&#100;&#105;&#110;&#x67;&#102;&#105;&#115;&#x68;&#64;&#111;&#117;&#x74;&#108;&#x6f;&#x6f;&#107;&#x2e;&#x63;&#111;&#109; | Date: Mon Oct 14 16:15:19 2024 +0800 创建分支fix-B当前状态：fix-B的下一个目标： 回溯到分支1合并后的状态git reflog-查看当前仓库的操作日志使用git reflog查看当前仓库的操作日志，找到回溯之前的hash值 1234567891011$ git reflogd261a61 (HEAD -&gt; 分支1) HEAD@&#123;0&#125;: commit: 来自分支1的修改65f7981 HEAD@&#123;1&#125;: checkout: moving from fix-B to 分支1083f020 (fix-B) HEAD@&#123;2&#125;: commit: 创建fix-B61126b3 (master) HEAD@&#123;3&#125;: checkout: moving from master to fix-B61126b3 (master) HEAD@&#123;4&#125;: checkout: moving from 分支1 to master65f7981 HEAD@&#123;5&#125;: commit: 分支1的修改3574200 HEAD@&#123;6&#125;: checkout: moving from master to 分支161126b3 (master) HEAD@&#123;7&#125;: reset: moving to 61126b34e2330bad3945c616374df80de7346be1f77bdd9 HEAD@&#123;8&#125;: checkout: moving from 分支1 to master 回溯： 1$ git reset --hard f77bdd9 目前状态如下：合并fix-B到master: 1$ git merge --no-ff fix-B 消除冲突后，达到最终状态： git commit –amend-修改最新的一次commit信息查看git log: 123456commit b8c8f1ba295a524f8b85593aa2cde9c233900e61 (HEAD -&gt; master)Merge: ac54cd9 083f020Author: lyroom &lt;codingfish@outlook.com&gt;Date: Tue Oct 15 13:36:28 2024 +0800 master和fix-B冲突消除 上次在消除冲突后，master又commit一次，这次提交本质是无意义的，因为没有冲突，就不需要提交了，因此需要修改提交备注信息： 1$ git commit --amend 修改提交信息为：合并master和fix-B： 123456commit 9441272bca5d390e54cfd05ba8b6ead3412c72b7 (HEAD -&gt; master)Merge: ac54cd9 083f020Author: lyroom &lt;codingfish@outlook.com&gt;Date: Tue Oct 15 13:36:28 2024 +0800 合并master和fix-B 这样就修改成功了，除了备注不一样，其他信息都一样。 git rebase -i-修改历史提交信息当我们提交了多次，但是发现这些提交工作树的内容都一样，或者无关紧要的好几次commit。如下： 1234567891011121314151617181920$ git logcommit 2979c94b8b6269cfb16c01a730098d6b2ec6ad4a (HEAD -&gt; master)Author: lyroom &lt;codingfish@outlook.com&gt;Date: Tue Oct 15 14:02:40 2024 +0800 又添加了几个空格,修改3次commit d81aa63d0f933bf1b0d49cb98a197eb55eb26c55Author: lyroom &lt;codingfish@outlook.com&gt;Date: Tue Oct 15 13:56:44 2024 +0800 删除了几个多余字母,修改2次commit d63d466638457b1923c83d79b908e327e5fe56e7Author: lyroom &lt;codingfish@outlook.com&gt;Date: Tue Oct 15 13:56:03 2024 +0800 删除了几个空格,修改1次 这些仅仅都是些微的修改，但是提交了多次，我们可以使用git rebase -i命令，修改合并这些提交信息。如下： 1$ git rebase -i HEAD~3 # 修改最近3次提交信息 合并后的commit的hash值，时间和最新的一致，但是提交信息已经修改了 12345678$ git logcommit 2979c94b8b6269cfb16c01a730098d6b2ec6ad4a (HEAD -&gt; master)Author: lyroom &lt;codingfish@outlook.com&gt;Date: Tue Oct 15 14:02:40 2024 +0800 合并备注信息 虽然’git rebase -i’ 和 ‘git commit –amend’ 都能修改commit的备注信息，但是‘git rebase -i’ 可以合并多次提交，‘git commit –amend’ 只能修改最近一次提交的备注信息。 四. 推送至远程仓库前面的所有操作都是基于本地的操作，接下来我们要进行的是远程仓库的操作。 当然前提是你需要在github创建一个仓库，如果本地写了README.md就不要勾选创建README.md文档了 1. git remote add-添加远程仓库12git remote add &lt;远程名称&gt; &lt;远程仓库URL&gt; # 添加远程仓库命令格式git remote add origin https://github.com/yourusername/your-repo.git # https方式添加仓库 &lt;远程名称&gt;：为远程仓库指定的别名，常用的是 origin，但您可以根据需要自定义名称。 &lt;远程仓库URL&gt;：远程仓库的实际地址。它可以是 HTTPS 或 SSH 的 URL，格式如下： HTTPS: https://github.com/user/repo.git SSH: git@github.com:user/repo.git 12345$ git remote add origin https://github.com/lyroom/githublearning.git #用户名：lyroom,仓库名字：githublearning$ git remote -v #查看远程仓库和urlorigin https://github.com/lyroom/githublearning.git (fetch)origin https://github.com/lyroom/githublearning.git (push) 2.git push-推送本地仓库到远程仓库推送至远程仓库master分支1234567891011121314$ git push -u origin master #推送本地仓库到远程仓库 u:upstream上游的缩写， # -u :将oring设置为上游仓库枚举对象中: 111, 完成.对象计数中: 100% (111/111), 完成.使用 20 个线程进行压缩压缩对象中: 100% (102/102), 完成.写入对象中: 100% (108/108), 1.18 MiB | 28.73 MiB/s, 完成.总共 108（差异 51），复用 0（差异 0），包复用 0remote: Resolving deltas: 100% (51/51), done.To https://github.com/lyroom/githublearning.git e362a53..99a3c4e master -&gt; master分支 &#x27;master&#x27; 设置为跟踪来自 &#x27;origin&#x27; 的远程分支 &#x27;master&#x27;。 推送至远程仓库master以外分支12$ git checkout fix-B #切换到fix-B分支$ git push -u origin fix-B #推送本地分支fix-B到远程仓库 五.从远程仓库获取1.git clone-克隆远程仓库到本地获取远程仓库（master） 首先我们切换到其他目录下 12345678910$ git clone https://github.com/lyroom/githublearning.git #克隆远程仓库到本地正克隆到 &#x27;githublearning&#x27;...remote: Enumerating objects: 132, done.remote: Counting objects: 100% (132/132), done.remote: Compressing objects: 100% (62/62), done.remote: Total 132 (delta 58), reused 131 (delta 57), pack-reused 0 (from 0)接收对象中: 100% (132/132), 1.18 MiB | 3.06 MiB/s, 完成.处理 delta 中: 100% (58/58), 完成. 执行完成之后我们默认处于master分支下，并且和远程仓库master&#x2F;main分支的内容是一样的 12$ git branch * master 获取远程仓库（非master）git branch -a-查看远程分支我们可以使用git branch -a查看远程和本地的分支 12345$ git branch -a* master remotes/origin/HEAD -&gt; origin/master remotes/origin/fix-B remotes/origin/master 可以看到本地只有master分支，远程有master和fix-B分支 注意：我们已经切换了文件夹(gitlearning—&gt;githublearning)，所以之前本地仓库只上传了master和fix-B分支,不要和之前的仓库搞混了 git checkout -b-克隆远程仓库的fix-B分支到本地12$ git checkout -b fix-B origin/fix-B #克隆远程仓库的fix-B分支到本地 #-b：创建分支并切换到fix-B分支 向本地的fix-B分支提交更改1$ git commit -am &quot;向本地的fix-B添加了内容&quot; #向本地的fix-B分支提交更改 推送fix-B分支到远程仓库12345678910111213$ git push #推送本地的fix-B分支到远程仓库枚举对象中: 5, 完成.对象计数中: 100% (5/5), 完成.使用 20 个线程进行压缩压缩对象中: 100% (3/3), 完成.写入对象中: 100% (3/3), 367 字节 | 367.00 KiB/s, 完成.总共 3（差异 1），复用 0（差异 0），包复用 0remote: Resolving deltas: 100% (1/1), completed with 1 local object.To https://github.com/lyroom/githublearning.git 083f020..bfde7fb fix-B -&gt; fix-B 2.git pull-拉取远程仓库到本地仓库刚刚在githublearning的仓库中修改了fix-B分支的内容并且上传到了github，但是我们gitlearnging仓库中的fix-B分支并没有更新，所以我们需要拉取远程仓库的fix-B分支到本地仓库 注意要切换到最开始的项目目录(githublearning—&gt;gitlearning) 12$ git checkout fix-B #切换到fix-B分支$ git pull origin fix-B #拉取远程仓库的master分支到本地仓库 参考资料GitHub 入门与实践本项目github地址","link":"","tags":[{"name":"github","slug":"github","permalink":"https://lyroom.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://lyroom.github.io/tags/git/"}]},{"title":"正则表达式学习","date":"2024-10-11T05:37:38.000Z","path":"2024/10/11/正则表达式学习/","text":"正则表达式语法有点复杂，而且不同的工具使用的语法还不尽相同。下面我们介绍一些常用的正则表达式语法规则。 基本单位基本单位主要包含：字符，转义字符(如\\n，\\d)，.(匹配任意字符)，集合（如[abc],[^abc]:集合[abc]取反）,(一个正则表达式) 基本操作基本操作的对象是基本单位，主要包含两个基本操作：连接和重复 连接将两个或多个字符或子模式直接拼接在一起进行匹配。每个子模式按顺序依次匹配字符串中的相应部分。 简单字符连接 正则表达式：&quot;abc&quot;匹配：字符串中的 “abc” 片段。例子：&quot;abc&quot;, “123abc456” 都会匹配；而 “ab”, “abcd” 不会完全匹配。 带有转义字符的连接 正则表达式：&quot;\\.txt&quot;解释：”.“代表匹配所有的单个字符，而”\\.“表示转义字符，匹配所有的字符串匹配：”file.txt”,”document.txt”等所有的 txt 文件，而”file.pdf”无法匹配 字符类连接 正则表达式：&quot;[A-Z][0-9]&quot;解释：第一个字符是大写字母，第二个字符是数字。匹配：像 “A1”, “Z9” 这样的字符串。 带有量词的连接 正则表达式：&quot;a&#123;2&#125;b&#123;3&#125;&quot;解释：表示有两个 “a” 和三个 “b” 连在一起。匹配：”aabbb”。 复杂子模式连接 正则表达式：&quot;(\\d&#123;3&#125;)-(\\d&#123;2&#125;)-(\\d&#123;4&#125;)&quot;解释：匹配形如 “123-45-6789” 的字符串，\\d 表示数字，{3} 和 {2} 指定数字的个数。匹配：像 “123-45-6789” 这样的字符串。 重复用于匹配一个模式的多次重复，通常使用量词来控制重复的次数。以下是常用的重复操作符和它们的含义：常用量词： *（星号）：匹配前面的模式 &gt;&#x3D; 0 次。 例子：a* 可以匹配 “a” 重复 0 次或多次，因此会匹配 “”（空字符串），”a”，”aa”，”aaa” 等。[abc]*可以匹配 零个或多个 由 字母 a、b、c 组成的字符序列,如””，”a”,”b”,”bacabc”等.*可以匹配所有的句子包含空格等字符 +（加号）：匹配前面的模式 1 次或多次。 例子：a+ 匹配至少一个 “a”，所以会匹配 “a”，”aa”，”aaa” 等，但不会匹配空字符串。[abc]+可以匹配任意长度的由 abc 组成的字符串 ?（问号）：匹配前面的模式 0 次或 1 次。 例子：a? 匹配一个 “a” 或没有 “a”，所以会匹配 “” 或 “a”。[abc]?以匹配 零次或一次出现的 字母 a、b 或 c，如：””,”a”,”b”,”c”,无法匹配”ab” &#123;n&#125;：匹配前面的模式恰好 n 次。 例子：a&#123;3&#125; 只会匹配 “aaa”，因为它要求 “a” 恰好出现 3 次。 &#123;n,&#125;：匹配前面的模式至少 n 次。 例子：a&#123;2,&#125; 匹配 “a” 至少出现 2 次的情况，因此会匹配 “aa”，”aaa”，”aaaa” 等。 &#123;n,m&#125;：匹配前面的模式至少 n 次，最多 m 次。 例子：a&#123;2,4&#125; 会匹配 “a” 出现 2 次到 4 次的情况，因此会匹配 “aa”，”aaa”，”aaaa”。 指定基本单位出现的位置 ^：行首，比如^1 匹配行首必须以 1 开始 $行尾，比如xyz$匹配行尾必须以 xyz 结尾 \\&lt;：词首，比如&lt;f 匹配词首必须以 f 为开头 \\&gt;：词尾，比如 xyz&gt; 匹配词尾必须以 xyz 为结尾 实战演习小例子：中国电话号码正则表达式要求： 1.第一位必须是 1； 2.第二位是 3-9 之间的数字 3.一共 11 位数字 1^1[3-9]\\d&#123;9&#125;$ 解释： ^：表示字符串的开始，确保从开头匹配。 1：中国手机号码以 1 开头。 [3-9]：第二位数字是 3 到 9，因为中国的手机号码段通常是 13x, 14x, 15x, 16x, 17x, 18x, 19x 等等。 \\d&#123;9&#125;：表示接下来有 9 位数字，\\d 表示数字，{9} 表示恰好 9 位。 $：表示字符串的结尾，确保整个字符串是完整的 11 位号码。 身份证号码正则表达式要求： 1.一共 18 位 2.前 6 位是地区码 3.中间 8 位是出生年月日 4.最后 3 位是纯数字 5.最后一位可以是数字也可以是字母 X 1^\\d&#123;6&#125;(18|19|20)\\d&#123;2&#125;(0[1-9]|1[0-2](0[1-9]|[12]\\d|3[01])\\d&#123;3&#125;(\\d|x)$ 解释： ^：表示字符串的开始，确保从开头匹配。 \\d&#123;6&#125;：前 6 位是地区码，由 6 位数字组成。 (18|19|20)：接下来的 2 位是年份的前两位，匹配 18、19 或 20（即 1800 年代、1900 年代或 2000 年代）。 \\d&#123;2&#125;：匹配年份的后两位数字，组成 4 位年份（如 1980、2002 等）。 (0[1-9]|1[0-2])：匹配月份，01 到 09 表示 1 月到 9 月，10 到 12 表示 10 月到 12 月。 (0[1-9]|[12]\\d|3[01])：匹配日期，01 到 09 表示 1 日到 9 日，10 到 29 表示 10 日到 29 日，30 和 31 表示 30 日和 31 日。 \\d&#123;3&#125;：匹配顺序码，由 3 位数字组成。 (\\d|X)：最后一位是校验码，可能是数字或字母 X。 $：表示字符串的结尾，确保整个字符串是完整的 18 位号码。 匹配字符串要求： 1.匹配单词 2.开头以 f 3.结尾为 t 123\\&lt;f[a-z]*t\\&gt; #仅仅是单词或者\\&lt;f[^ \\t]*t\\&gt;#字符数字都可以 解释： \\&lt;：表示单词的开始边界（这在一些正则表达式引擎中有效，如 GNU grep、sed 等）。表示匹配一个单词的起始位置，确保匹配的是独立的单词，而不是其他词中的一部分。 f：字母 f，匹配单词的第一个字母。 [^ \\t]*： [^ \\t]：字符类取反，表示不能包含空格（ ）或制表符（\\t）。 *：量词，表示前面的模式可以重复 0 次或多次，即允许后续任意多个非空格或非制表符的字符。 t：字母t，匹配单词的最后一个字母 \\&gt;：表示单词的结束边界，确保匹配的结束处是一个完整的单词。","link":"","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://lyroom.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"github抽风","date":"2024-09-13T03:51:12.000Z","path":"2024/09/13/github抽风/","text":"端口 22 无法访问今天突然发现 github 可以访问，但是克隆不了项目，问题如何下： 踩坑 修改 hosts 文件 开启 clash verge 代理 修改 dns以上三种方法均失败 解决办法先用 443 端口 ssh 访问试试： 1ssh -T -p 443 git@ssh.github.com 如果可以访问则修改配置文件 完成！","link":"","tags":[{"name":"bug","slug":"bug","permalink":"https://lyroom.github.io/tags/bug/"},{"name":"github","slug":"github","permalink":"https://lyroom.github.io/tags/github/"},{"name":"clashverge","slug":"clashverge","permalink":"https://lyroom.github.io/tags/clashverge/"}]},{"title":"linux文件子系统","date":"2024-09-13T01:18:02.000Z","path":"2024/09/13/linux文件子系统/","text":"🐧linux下常见的命令linux下常见的目录概览不同于 windows，在一切资源为文件的 linux 系统中，是以树结构来管理文件系统，根节点被称为根目录，用“&#x2F;”表示 常见目录及功能 &#x2F;sys 目录详解 偏向硬件和底层，专门用于提供与内核和硬件设备的交互，提供了内核对象及其属性的可视化界面，通常用于监控和管理硬件设备。 例如查看 cpu 的核心线程数量（13600kf：6 大核，4 小核，20 线程）可以访问： 1cd /sys/devices/system/cpu 可以看到以下信息： &#x2F;proc 目录详解面向进程&#x2F;运行时统计信息 &#x2F;bin 目录详解 linux文件系统中有很多个bin目录，如上图，他们通常起着不同的作用： usr:并不是 user 的缩写，而是 Unix System Resources ,代表 Unix 系统资源 目录 含义 包含 &#x2F;bin（binary） 存放核心 OS 程序和脚本文件，一般是系统预装的程序 cat,bash,ls,pwd 等 &#x2F;user&#x2F;bin 存放用户程序的二进制文件，不是系统自带的程序，用户自己安装的发行版程序 gcc,g++,git 等 &#x2F;user&#x2F;local&#x2F;bin 存放用户自己的可执行程序，不会被系统升级而覆盖同名文件，例如 gcc 之后的文件。 &#x2F;sbin 存放 root 用户或者使用 sudo 权限的用户才能访问的程序或者命令 ifconfig,shutdown,mount 等 存放于 bin 目录下的程序或者脚本是可以直接执行的，执行的顺序取决于环境变量中各个文件夹的前后顺序！ 根据环境变量可知.如果这几个 bin 目录中有同一个可执行文件，他们的执行顺序会是：**&#x2F;usr&#x2F;local&#x2F;bin &gt; &#x2F;sbin &gt; &#x2F;bin** &#x2F;etc 目录详解存储系统配置文件和全局配置文件 系统配置文件：passwd 文件储存用户密码，group 文件存储用户自定义组信息，hosts 定义本地主机名字和 IP 地址的映射，ssh 存储与 ssh 服务相关配置文件等 全局配置文件：.bashrc 文件存储全系统的 bash 配置等 &#x2F;run 目录详解 run 目录在 Linux 系统中通常位于根目录下 (/run)。这个目录主要用于存储系统和进程的运行时数据，例如 PID 文件、套接字文件、锁文件等。 一些 run 目录的特点： 临时文件系统 (tmpfs)： /run 通常挂载为 tmpfs，这意味着它在系统启动时创建，并在系统关闭或重启后清空。 早期启动： 由于 /run 是在系统早期启动时创建的，所以它可以用于存储需要在其他文件系统挂载之前可用的临时文件。 权限和所有权： 只有 root 用户和特定服务或进程可以在 /run 目录中创建文件。 常见的子目录和文件： /run/lock/：锁文件目录，进程用来避免多个实例同时运行。 /run/user/：每个用户有自己的运行时目录，用于用户进程的临时文件。 /run/systemd/：Systemd 使用的一些运行时数据。 &#x2F;home 目录详解在 Linux 系统中，/home 目录是用户的主目录，存放每个用户的个人数据和配置文件。每个用户通常在 /home 目录下有一个独立的子目录，这个子目录以该用户的用户名命名。 一些特点和用途： 用户数据存储：用户的个人文件、文档、下载、图片、音乐等通常存储在他们的主目录下（例如 /home/username）。 配置文件：用户配置文件（如桌面环境、应用程序的设置）通常保存在主目录中的隐藏文件夹或文件中。这些文件夹和文件的名称以 . 开头，例如 .bashrc、.config 等。 权限：每个用户通常只对自己的 /home/username 目录有完全的读写权限，而对其他用户的主目录没有权限，除非是系统管理员（root）用户。 分区：有些系统管理员在安装操作系统时会将 /home 分为一个单独的分区，这样在系统重装时可以保留用户的数据。 你可以通过 cd ~ 或 cd /home/username 来切换到当前用户的主目录。 &#x2F;root 目录详解在 Linux 系统中，/root 文件夹是专门为 root 用户（超级用户）设置的主目录。与普通用户的主目录通常位于 /home/username 不同，root 用户的主目录位于系统的根目录下，即 /root。 关键点： 权限限制：只有 root 用户或具有足够权限的用户才能访问和修改 /root 目录中的文件。普通用户默认无法访问这个目录。 用途：root 用户可以在 /root 目录中存储自己的配置文件、脚本和数据，类似于普通用户在他们的主目录中保存个人文件的方式。 **不要混淆 /**：/root 目录不同于根目录 /，根目录是整个文件系统的起点，而 /root 是 root 用户的个人主目录。 参考资料 linux下目录的操作cd-切换目录1234$ man cd cd — change the working directory格式： cd [选项] [directory] 常用方式： 1234567$ cd # 切换到用户家目录$ cd /usr/lib # 切换到/usr/lib目录$ cd / # 切换到 / 目录$ cd ~ # 切换到用户家目录$ cd . # 切换到当前工作目录（不切换）$ cd .. # 切换到父目录$ cd - # 切换到上一次目录 cd -：切换到上次的工作目录，通过 env 中的 OLDPWD 变量记录着工作目录的切换 mkdir-创建目录1234567$ man mkdirmkdir - make directories格式: mkdir [选项] directory...常用选项： -p, --parents 如果父目录不存在，则创建父目录 常用方式： 123$ mkdir dir$ mkdir dir1 dir2 dir3$ mkdir -p a/b/c rmdir-删除空目录rmdir 不同于 rm -r 只能用来删除空目录 1234567$ man rmdir rmdir - remove empty directories格式： rmdir [选项] dirctory...常用选项： -p, --parents 递归删除空目录 常用方式： 123$ rmdir dir$ rmdir dir1 dir2 dir3$ rmdir -p a/b/c 通配符通配符：主要用于文件名匹配，功能简单，常用于操作系统的命令行（如 ls、cp）。常见的通配符包括： *：匹配任意长度的字符（包括零个字符）。 ?：匹配单个字符。 [abc]：匹配括号内的任意一个单字符。 [!abc]:不匹配括号内的任意一个字符 示例： *.txt 匹配所有 .txt 结尾的文件。 file?.txt 匹配 file1.txt、file2.txt 等。 常用方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#这是当前的目录结构.├── a│ └── b│ └── c├── dir├── dir1├── dira├── dirab├── dirabc├── dirabcd├── dirb├── diri├── dirj├── dirk└── dirrrmdir dir[ijk] #删除名字为diri，dirj,dirk的文件夹.├── a│ └── b│ └── c├── dir├── dir1├── dira├── dirab├── dirabc├── dirabcd├── dirb└── dirrrmdir dir? #删除名字为dir[char]的空文件夹.├── a│ └── b│ └── c├── dir├── dirab├── dirabc└── dirabcdrmdir dir* #删除名字为dirxxx的文件夹.└── a └── b └── c ls-查看目录项12345678910111213$ man lsls - list directory contents格式：ls [选项] [FILE]...常用选项：-a, --all显示所有的内容，包括以.开头的文件和目录-i, --inode显示文件的inode编号(inode是物理文件的标识)。-l以长格式的形式显示目录中的内容-h, --human-readable和-l选项一起使用，以人类可读的方式显示文件的大小。 常用方式： 1234567$ ls # 查看当前的工作目录$ ls dir # 查看dir$ ls dir1 dir2 dir3 # 查看dir1，dir2，dir3$ ls -a dir # 查看dir中所有的内容，包括以.开头的文件和目录$ ls -i dir # 查看dir中所有的内容，以及每个文件所在的逻辑块号$ ls -h dir # 查看dir中所有的内容，包括以.开头的文件和目录$ ls -ilh dir # 显示inode编号，显示详细信息，并以人类可读的方式显示文件的大小 目录项详解12345$ ls -l-rw-rw-r-- 2 yong yong 11 9月 18 17:13 a.txtdrwxr-xr-x 8 yong yong 4096 9月 18 16:02 Blog-rw-rw-r-- 2 yong yong 11 9月 18 17:13 b.txt... 第 1 列的第一个字母用来表示文件的类型： -: 普通文件d(directory): 目录c(character): 字符设备文件(鼠标，键盘，显示器…)b(block): 块设备文件(磁盘)l(symbolic link): 符号链接s(socket): 本地套接字p(named pipe): 有名管道 第 1 列后面九个字符(分为 3 组)表示权限。依次代表拥有者、拥有组和其他用户的读(r)、写(w)、执行(x)权限。可读则显示 r，可写则显示 w，可执行则显示 x， 没有相关权限则显示-。 第 2 列表示硬链接数。 第 3 列表示拥有者。 第 4 列表示拥有组。 第 5 列表示文件所占空间的大小。 第 6 列表示最近修改时间。 第 7 列为文件名 cp-复制文件或目录123456789101112$ man cpcp - copy files and directories格式：cp [选项] SOURCE DESTcp [选项] SOURCE... DEST常用选项：-n, --no-clobber如果文件已存在，则不覆盖(默认会覆盖已有文件)。-i, --interactive如果文件存在，则给用户提示信息(由用户决定是否覆盖?)-R, -r, --recursive递归复制(用于copy目录) 常用方式： 123456$ cp text1 text2 # 将text1复制到text2中；如果text2存在，则覆盖。$ cp text1 text2 text3 dir # 将text1,text2,text3复制到目录dir中；如果文件已存在，则覆盖。$ cp -n text1 text2 # 将text1复制到text2中；如果text2存在，不覆盖。$ cp -i text1 text2 text3 dir # 将text1,text2,text3复制到目录dir中；如果文件已存在，则提示用户是否覆盖。$ cp -r dir1 dir2 # 递归地将目录dir1复制到目录dir2,即复制dir1的所有内容到dir2中去$ cp -r dir/* dir2 # 递归地将目录dir中的所有内容复制到目录dir2中去 mv-移动文件mv（move）命令可以用来移动文件和目录，我们也可以用 mv 命令来为文件和目录重命名。 12345678910111213$ man mv mv - move (rename) files格式： mv [选项] SOURCE DEST mv [选项] SOURCE... DIRECTORY Rename SOURCE to DEST,or move SOURCE(s) to DIRECTORY.常用选项： -i, --interactive 如果文件存在，则给用户提示信息(由用户决定是否覆盖?) -f, --force 如果文件存在，则不提示用户，直接覆盖 -n, --no-clobber 如果文件存在，则不覆盖(默认是覆盖的) move 为什么没有-r 选项，而 cp 却有？移动操作（mv）本质上只是改变文件或目录的位置指针，而不涉及复制或删除文件内容。复制操作（cp）需要复制目录中的所有内容，因此需要 -r 选项来递归复制。 常用方式： 12345$ mv text1 text2 #将text2重命名为text1；如果text2存在则覆盖$ mv dir1 dir2 #将dir1重命名为dir2$ mv -n text1 text2 #将text2重命名为text1；如果text2存在则不覆盖$ mv text1 text2 text3 dir #将text1,text2,text3移动到目录dir中；如果文件已存在，则覆盖$ mv -i text1 text2 text3 dir #将text1,text2,text3移动到目录dir中；如果文件已存在，则提示用户是否覆盖 rm-删除文件或目录rm(remove)命令可以删除文件或目录 1234567891011$ man rmrm - remove files or directories格式： rm [选项] FILE...常用选项： -f, --force 删除文件时，不提示用户确认 -i, --interactive 删除文件时，提示用户确认 -r, -R, --recursive 递归删除目录及其内容 常用方式： 123456$ rm text1 text2 text3 #删除text1,text2,text3$ rm -f text1 text2 text3 #删除text1,text2,text3，不提示用户确认$ rm -i text1 text2 text3 #删除text1,text2,text3，提示用户确认$ rm -r dir1 dir2 dir3 #删除dir1,dir2,dir3及其内容$ rm -rf / #删除根目录及其所有内容，危险操作！$ rm *.txt #删除当前目录下所有txt文件(不包括隐藏文件),可以搭配通配符使用 rm 删除的文件是无发找回的，请慎重使用 linux下的文件操作touch-创建文件linux 有很多创建文件的方法，最常见的有以下三种： 123$ echo &quot;hello world!&quot; &gt; text #创建文件text，并且文件中包含内容“hello world”$ touch text1,text2,text3 #创建文件text1，text2，text3要求text1，2，3不存在$ vim hello.cpp #编辑hello.cpp文件，使用wq推出 查找文件which-查找可执行程序的路径1234567$ man which which - locate a command格式： which [-a] cmd...选项： -a 显示所有匹配的路径 常用方式： 123$ which bash # 查看bash的路径$ which ls tree # 查看命令ls和tree的路径$ which -a vim # 查看vim的所有路径 which 查找的程序路径是和环境变量中 PATH [bin 目录的顺序](# &#x2F;bin 目录详解)有关的,是 path 中的第一个路径 find-可以在一个目录中递归的查询符合指定要求的文件123456789101112131415161718192021222324252627282930313233343536373839404142434445$ man find find - search for files in a directory hierarchy格式： find [start-point...] 查找条件 # 省略start-point，默认起始点为当前目录，可以指定多个路径常用选项： -name pattern 查找文件名符合pattern的文件 -type c 查找类型为c的文件： b(block): 块设备文件 c(character): 字符设备文件 d(directory): 目录 p(named pipe): 有名管道 f(file): 普通文件 l(symbolic link): 符号链接 s(socket): 套接字 -size n[cwbkMG] #[cwbkMG]:表示单位 File uses n units of space, rounding up.（向上取整，例如2.3M，向上取整3M） b: for 512-byte blocks (this is the default if no suffix is used) #块 c: for bytes #char w: for two-byte words k: for Kibibytes (KiB, units of 1024 bytes) M: for Mebibytes (MiB, units of 1024 * 1024 = 1048576 bytes) G: for Gibibytes (GiB, units of 1024 * 1024 * 1024 = 1073741824 bytes) 可以在n前面添加&#x27;+&#x27;和&#x27;-&#x27;，表示大于和小于。 -empty 查找空的文件或空的文件夹 -user username, -uid uid 根据用户名和用户id查找 -group groupname, -gid gid 根据组名和组id查找 -perm mode 根据权限查找 根据时间查找： -amin n, -atime n, -cmin n, -ctime n, -mmin n, -mtime n a(access): 文件访问的时间 c(change): 文件属性发生改变的时间 m(modify): 文件内容发生改变的时间 min: 以分钟为单位 time: 以天为单位 可以在n前面添加&#x27;+&#x27;和&#x27;-&#x27;，表示大于和小于。组合查找： -a(and), -o(or), !(not): 分别表示与、或、非 常用方式： 1$ find /usr/include/ ~/Code/filelearning/ -name &quot;stdio.h&quot; 1$ find /dev/ -type b 12345678910111213$ find . -size 66M #找大小向上取整为66M的文件$ find . -size +66M #找大小向上取整大于66M的文件$ find . -size -66M #找大小向上取整小于66M的文件当前目录如下：-rw-rw-r-- 1 yong yong 17K 9月 11 14:43 20个常用Linux命令.md-rw-rw-r-- 1 yong yong 166M 9月 11 17:05 app.asardrwxrwxr-x 2 yong yong 4.0K 9月 11 14:48 C++基础与提高-rw-rw-r-- 1 yong yong 4.3M 9月 11 14:47 C++基础与提高.zip---x--x--x 1 yong yong 66M 9月 10 12:42 qt-online-installer-linux-x64-4.8.0.run-rw-rw-r-- 1 yong yong 126M 9月 11 17:04 Xmind-for-Linux-amd64bit-23.08.02122-202308281754.deb-rw-rw-r-- 1 yong yong 153M 9月 11 15:41 Xmind-for-Linux-x86_64bit-24.04.10311-202405240021.rpmdrwxrwxr-x 2 yong yong 4.0K 9月 11 15:40 xmind-winmm-rw-rw-r-- 1 yong yong 5.7M 9月 11 15:40 xmind-winmm.zip 1234567891011121314$ find /usr/include -name &quot;stdio.h&quot; # 在/usr/include目录下查找stdio.h文件$ find . -name &quot;*.c&quot; # 在当前工作目录下查找所有以.c结尾的文件$ find /dev -type b # 在/dev目录下查找所有的块设备文件$ find . -size 5M # 在当前工作目录下查找所有大小为5M的文件$ find . -size +5M # 在当前工作目录下查找所有大于5M的文件$ find dir1 dir2 dir3 -empty # 在dir1,dir2,dir3目录下查找所有空的文件和空的文件夹$ find . -user he # 在当前工作目录下查找he用户拥有的文件$ find . -gid 0 # 在当前工作目录下查找root组(gid=0)拥有的文件$ find . -perm 664 # 在当前工作目录下查找权限为664(rw-rw-r--)的文件$ find . -mtime 1 # 在当前工作目录下查找在[1, 2)天前内容发生修改的文件(find会省略小数部分)$ find . -mtime +2 # 在当前工作目录下查找在[3, +∞)天前内容发生修改的文件$ find /dev -type c -a -name &quot;tty*&quot; # 在/dev目录下查找以tty开头的字符设备文件$ find /dev -type b -o -name &quot;tty*&quot; # 在/dev目录下查找块设备文件或者是以tty开头的文件$ find /dev -type c -a ! -name &quot;tty*&quot; # 在/dev目录下查找不以tty开头的字符设备文件 权限查找中的数字含义：$ find . -perm 777 1234$ ls -l-rwxrw-r-- 2 yong yong 11 9月 18 17:13 a.txtdrwxr-xr-x 8 yong yong 4096 9月 18 16:02 Blog-rw-rw-r-- 2 yong yong 11 9月 18 17:13 b.txt 第 1 列后面九个字符(分为 3 组)表示权限。依次代表所属用户、同组用户和其他用户的读(r)、写(w)、执行(x)权限。可读则显示 r，可写则显示 w，可执行则显示 x， 没有相关权限则显示-。 可以用二进制来简易表示这些用户的所拥有的权限，1 代表有该权限，0 代表无该权限：rwx rw- r– &lt;&#x3D;&#x3D;可写为&#x3D;&#x3D;&gt;111 110 100，而三个二进制的数组成一个 8 进制的数，于是又可以改写为：rwx rw- r– &lt;&#x3D;&#x3D;可写为&#x3D;&#x3D;&gt;111 110 100&lt;&#x3D;&#x3D;可写为&#x3D;&#x3D;&gt;746所以 777&lt;&#x3D;&#x3D;可写为&#x3D;&#x3D;&gt;rwxrwxrwx,即所有用户都有读写执行该文件的权限，$ find &#x2F;dev -perm 777:查找可以被所有用户读写执行的文件 查看文件cat-查看文件所有内容1234567$ man catcat - 连接多个文件并打印到标准输出。格式： cat [选项] [file]...常见选项： -n, --number 对每一行进行编号 常见用法 123$ cat /etc/passwd$ cat -n /etc/passwd$ sudo cat /etc/passwd /etc/shadow head-查看文件的前几行1234567$ man head head - 显示文件的开头部分。格式： head [选项] [file]...常见选项： -n, --lines=[-]NUM 显示前NUM行；若在NUM前面添加&#x27;-&#x27;号，则显示除了后NUM行的所有行 常见用法： 1234$ head text1 #默认查看text1的前10行$ head text1 text2 text3 #显示text1，2，3的前10行$ head -n 5 text1 #显示text1的前5行$ head -n -5 text1 #显示text1的后5行 tail-查看文件的后几行123456789$ man tail tail - output the last part of files格式： tail [选项] [file]...常见选项： -n, --lines=[+]NUM 显示后NUM行；若在NUM前面添加&#x27;+&#x27;号，则从第NUM开始显示 -F 显示后面追加的数据。一般用于查看日志文件。 常见用法： 123##常规用法和head差不多，便不赘述$ tail -n +5 text1 #显示text1的前5行$ tail -F server.log #能够实时的监视server.log文件后几行 less&#x2F;more-分屏浏览文件1234$ man more more - file perusal filter for crt viewing (说人话就是单页浏览)格式： more [选项] file... less 是 more 的升级版本，性能更好，不需要一次性加载所有的文件内容到内存中，有 less 选 less 常见用法： 12$ less text1$ less text1 text2 进入浏览界面后快捷键： 快捷键 含义 f(forward) 往后翻一页 b(backforword) 往前翻一页 :n(next) 查看下一个文件 :p(previous) 查看上一个文件 q(quiet) 退出查看模式 重定向直白点讲就是把文件中的内容代替键盘输入到输入缓冲区中，把本该输出到屏幕上的输出缓冲区的内容写到文件中去。 通常我们借助重定向符号来完成这一功能，以下是缓冲区和其对应的符号 “&gt;”,”2&gt;”和“&gt;&gt;”，“&gt;&gt;”的区别：单符号”&gt;”,”2&gt;”表示覆盖文件中的内容，双符号“&gt;&gt;”,”2&gt;&gt;表示追加到文件中”去。常见用法： 1$ ./isPrimes &lt; input.txt #将input.txt中的数字代替键盘输入的数字 1234567891011121314151617181920//这是判断素数的函数 1 #include &lt;cmath&gt; 2 #include &lt;iostream&gt; 3 using namespace std; 4 bool isPrime(long long n)&#123; 5 if(n == 2) return true; 6 for(int i = 2; i &lt; n; i++ )&#123; 7 if(n % i == 0) return false; 8 &#125; 9 return true; 10 &#125; 11 int main() 12 &#123; 13 long long n; 14 cin &gt;&gt; n; 15 if(isPrime(n)) cout&lt;&lt;n&lt;&lt; &quot;is Prime&quot;&lt;&lt;endl; 16 else 17 cout &lt;&lt; n &lt;&lt; &quot;is not a Prime&quot;&lt;&lt;endl; 18 return 0; 19 &#125; 结果如下： 1234yong@yongubuntu:~/桌面/code$ cat input.txt213yong@yongubuntu:~/桌面/code$ ./isPrimes &lt; input.txt213is not a Prime 其他常用方法： 12345678$ who &gt; users$ echo &quot;liu yi fei&quot; &gt;&gt; users$ cat users file1 &gt; text# 将liu yi fei追加到text，并提示“file1不存在”$ cat users file1 2&gt; text# 仅将错误信息“file1不存在”覆盖写入text$ cat users file1 &gt;&amp; text# 将liu yi fei和“file1不存在”都覆盖写入text grep-搜索文件内容grep(globally search for a regular expression)命令可以用于搜索文件内容，它的功能非常强大！grep 命令会按正则表达式去搜索文件，如果文件中某一行匹配指定的正则表达式，grep 命令则会显示这一行。 123456789101112131415$ man grep grep - 全面搜索正则表达式并把行打印出来格式： grep [选项] pattern [file]...常见选项： -E, --extended-regexp 使用扩展的正则表达式 -i, --ignore-case 忽略大小写 -v, --invert-match 显示不匹配正则表达式的行 -n, --line-number 显示行号 -c, --count 不显示匹配的行，统计匹配行的个数 常见用法： 12$ grep -nE &quot;God&quot; Bible.txt #显示Bible.txt中包含God的行，并显示行号$ grep -cvE &quot;God&quot; Bible.txt #统计Bible.txt中不包含God的行的个数 grep通常会搭配正则表达式使用，这里有关于正则表达式的讲解 linux下命令的组合1.先后顺序执行格式如下： 12cmd1;cmd2;cmd3 先执行cmd1，再执行cmd2，最后执行cmd3 示例： 1sudo mkdir dir;cd dir;touch file; 2.前一个命令的输出是下一个命令的输入格式如下： 12cmd1 | cmd2(管道) 将cmd1的输出缓冲区（stdout）重定向到管道，再从管道重定向到cmd2的输入缓冲区（stdin）中去 示例： 1234567$ history | tail -n 5 #显示最近5条命令 1796 which -a tldr 1797 which -a tldr | tail -n 2 1798 ls -lh 1799 ls -lh | grep -nEc &quot;9月&quot; 1800 history | tail -n 5 3.前一个命令的输出是下一个命令的参数xargs xargs:extended arguments,可以将标准输入里面的每一行转换成为命令的参数，通常搭配管道使用 使用方法格式如下： 12cmd1 | xargs cmd2 先执行cmd1，将cmd1的输出缓冲区（stdout）的每一行均作为cmd2的参数 示例1： 1$ ls -lh | xargs grep -nEc &quot;9月&quot; #统计当前目录下所有文件中包含“9月”的行数 示例2：快速找到一个大型项目中的所有.cpp文件，并且找到main函数所在的行 12345678$ find . -name &quot;*.cpp&quot; | xargs grep -nE &quot;\\&lt;main\\(&quot;# linux-5.17.4源码./tools/build/feature/test-cxx.cpp:10:int main()./tools/build/feature/test-llvm-version.cpp:6:#define pass int main() &#123;printf(&quot;%x\\n&quot;, NUM_VERSION); return 0;&#125;./tools/build/feature/test-clang.cpp:18:int main()./tools/build/feature/test-llvm.cpp:9:int main()./tools/testing/selftests/bpf/test_cpp.cpp:14:int main(int argc, char *argv[])","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://lyroom.github.io/tags/linux/"},{"name":"目录","slug":"目录","permalink":"https://lyroom.github.io/tags/%E7%9B%AE%E5%BD%95/"},{"name":"文件","slug":"文件","permalink":"https://lyroom.github.io/tags/%E6%96%87%E4%BB%B6/"}]},{"title":"C++学习","date":"2024-09-11T05:36:18.000Z","path":"2024/09/11/C-学习/","text":"这里主要记录了，我的 C++学习的一些书籍和资源。 c++学习路线数据库学习入门： 书籍： SQL必知必会：主要是SQL语句的书写","link":"","tags":[{"name":"book","slug":"book","permalink":"https://lyroom.github.io/tags/book/"},{"name":"C++","slug":"C","permalink":"https://lyroom.github.io/tags/C/"}]},{"title":"hexo如何打造个人书库","date":"2024-07-22T09:48:05.000Z","path":"2024/07/22/hexo如何打造个人书库/","text":"最近偶然发现可以在 hexo 中插入 pdf，就想着把自己看过的书都整理一下，做成电子书库。正好最近在整理书籍，就顺便做了这个事情。 下面是一些步骤和注意事项。 1. 安装插件1npm install hexo-pdf 2. 在 hexo 配置文件_config.yml 中添加如下配置1post_asset_folder: true 3. 使用方法一共有三种方法，如下： 123&#123;% pdf GitHub入门与践.pdf %&#125; #属于直接插入[text](GitHub入门与践.pdf) #属于链接方式插入&lt;embed src=&quot;GitHub入门与践.pdf&quot; width=&quot;100%&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot;&gt; #用html的方法插入 推荐第二方式，通过链接方式插入，不用占用太多的页面空间 4.示例展示GitHub 入门与实践","link":"","tags":[{"name":"pdf","slug":"pdf","permalink":"https://lyroom.github.io/tags/pdf/"}]},{"title":"vim","date":"2024-07-11T09:47:27.000Z","path":"2024/07/11/vim/","text":"Vim编辑器​ Vim(Vi improved) 是从 Vi 发展出来的一个文本编辑器。Vim 在程序员中使用地非常广泛，和 Emacs 并称为类 Unix 系统用户最喜欢的文本编辑器。事实上，这两大编辑神器之间的圣战一直没停歇过。 ​ 在这个蔚蓝色的星球上，流传着两大神器的传说： 据说 Emacs 是神的编辑器，而Vim 是编辑器之神… ​ 学习 vim 之前，先知道其设计理念是很重要的：不仅有助于记忆，而且还能举一反三。 Vim 的设计理念是 Composability ( 组合 ): ​ 例如在 Vim 中，”d” 表示删除，”j” 移动到下一行，组合 “dj” 表示删除当前行和下一行；”^” 代表行首，故组合 “d^” 表示删除到行首；”$” 代表行尾，”d$” 表示删除到行尾。而且我们还可以指定命令重复的次数：”dd” 表示删除光标所在行，”2dd” 或”d 2 d” 表示连续删除两行，效果和 “dj” 一致。 1 三大模式（视图）​ Vim 是一种模式编辑器，它与我们熟悉的”所见即所得”的编辑器不太一样。Vim 在不同模式下有不同的功能，这也是 Vim 之所有这么 NB 的原因之一。 ​ Vim 有多种模式，最常用的是：普通(命令)模式、插入(编辑)模式和视觉模式。 普通（命令）模式（common mode） ​ 刚进入vim编辑器时候的默认模式。在此模式下能输入的vim的合法指令（通常是一些字母，如h,j,k,l）来进行操作，更像是阅读模式 插入（编辑）模式(Insert mode) ​ 文本编辑模式，直接对文本内容进行编辑 视觉模式(Last-line mode) ​ 也叫底线（末行）模式，顾名思义，就是在输入窗口的最下方进项的操作，更偏向文件管理。比如显示行号等等 这些模式之间可以相互转换，如下图所示： 1.1 基础命令&amp;含义​ 以下是常见的vim快捷键的中文版速查图： 指令 含义 i 进入编辑模式并在光标前面插入 I 进入编辑模式并在行首插入 a 进入编辑模式并在光标后面插入 A 进入编辑模式并在行尾插入&lt; o 进入编辑模式并在下面另起一行，并在行首插入 O 进入编辑模式在上面另起一行，并在行首插入 v 进入行选模式 ctrl + v 进入竖选模式 i: 进入编辑模式并在光标前面插入 I: 进入编辑模式并在行首插入 a: 进入编辑模式并在光标后面插入 A: 进入编辑模式并在行尾插入 o: 进入编辑模式并在行首插入 O:进入编辑模式在上面另起一行，并在行首插入 1.2 普通模式普通模式又叫命令模式，顾名思义，这种模式就是用来执行各种命令的。命令可以分为长命令和短命令： 12长命令：以:开头，以[Enter]结尾的命令。比如，:wq[Enter]短命令：如a,o,i... 1.2.1 移动光标 命令 含义 h 往左移动一个字符 j 往下移动一个字符 k 往上移动一个字符 l 往右移动一个字符 [n]- 往上移动n行 [n]+ 往下移动n行 :n或者[n]G 移动到第n行 gg 移动到文本的第一行 G 移动到文本的最后一行 ^ 移动到行首 $ 移动到行尾 w 下一个词的词首 b 上一个词的词首 t [char] 向后查找，将光标移动到[char]的前一个字符 T[char] 向前查找，将光标移动到[char]的后一个字符 f[char] 向后查找，将光标移动到[char] F[char] 向前查找，将光标移动到[char] h :往左移动一个字符 j :往下移动一个字符 k :往上移动一个字符 l :往右移动一个字符 [n]- :往上移动n行 [n]+ :往下移动n行 :n 或 [n]G 移动到第n行 gg :移动到文件的第一行 G :移动到文件的最后一行 ^ :移动到到行首 $ :移动行尾 w :移动到下一个单词的词首（中文句子直接算一个单词了） b :移动到上一个单词的词首（中文句子直接算一个单词了） t[char] :向后查找，将光标移动到[char]的前一个字符 T[char] :向前查找，将光标移动到[char]的后一个字符 f[char] :向后查找，将光标移动到[char] F[char] :向前查找，将光标移动到[char] 1.2.2 删除(delete)文本​ vim中删除类似windows中的剪切，会将删除的内容复制到vim的”剪贴板”中，其中dt[char],df[char]等都可以类比上面的移动光标。 命令 含义 x 删除一个字符 dw 删除一个单词 [n]dw 或 d[n]w 删除n个单词 dd 删除一行 [n]dd 或 d[n]d 删除n行 :[m],[n]d 删除[m,n] d^ 删除到行首 d$ 删除到行尾 dt[char] 向后删除，删除到[char] dT[char] 向前删除，删除到[char] df[char] 向后删除，删除到[char]的下一个字符 dF[char] 向前删除，删除到[char]的前一个字符 1.2.3 复制(yank)文本类比上面的删除文本，把d换成y即可 命令 含义 yy 复制光标所在一行 [n]yy或者y[n]y 复制光标起的n行 :[m],[n]y 复制[m,n]行 yw 复制光标所在的一个单词（如果光标在单词内部，则复制光标所在位置到末尾的部分，汉语一个句子当为一个单词） [n]yw或y[n]w 复制n个单词（同上） yt[char] 向后复制，复制到[char] yT[char] 向前复制，复制到[char] yf[char] 向后复制，复制到[char]的下一个字符 yF[char] 向前复制，复制到[char]的前一个字符 1.2.4 粘贴,撤销和恢复 命令 含义 p或者P(paste) 粘贴（将上面复制的内容粘贴） u(undo) 撤销 ctrl + r(recovery) 恢复 1.2.5 修改文本​ 删除+进入编辑模式 命令 含义 cc或者S 删除当前行并进入插入（编辑）模式 [n]cc或[n]S 删除n行，并进入插入（编辑）模式 cw 删除一个单词，并进入插入（编辑）模式 [n]cw或c[n]w 删除n个单词，并进入插入（编辑）模式 c^ 删除到行首并进入插入模式 c$ 删除到行尾并进入插入模式 ct[char] 向后删除，删除到[char]，并进入插入模式 cT[char] 向前删除，删除到[char]，并进入插入模式 cf[char] 向后删除，删除到[char]的下一个字符，并进入插入模式 cF[char] 向前删除，删除到[char]的上一个字符，并进入插入模式 c[n]G 删除到第n行，并进入插入模式 cG 删除到文件末尾，并进入插入模式 cgg 删除到文件首行，并进入插入模式 1.2.6 查找 命令 含义 &#x2F;pattern 从光标的位置向后查找，查找匹配pattern的内容，pattern为正则表达式 ?pattern 从光标的位置向前查找，查找匹配pattern的内容，pattern为正则表达式内容 n 移动到下一个匹配项 N 移动到上一个匹配项 1.2.7 替换(substitute)文本 命令 含义 :s&#x2F;pattern&#x2F;substitute 只会替换光标所在的行的第一个匹配项 :s&#x2F;pattern&#x2F;substitute&#x2F;g 替换光标所在行的所有匹配项 :[m],[n]s&#x2F;pattern&#x2F;substitute&#x2F;g 替换[m,n]行的所有匹配项 :%s&#x2F;pattern&#x2F;substitute&#x2F;g 替换全文的所有匹配项 1234:w 将buffer里面的内容写入文件，即保存:q 退出:q! 不保存退出:wq 保存退出 1. 2 视图模式视图模式是用来选择内容的。选择内容之后，我们就可以对其进行复制或删除了。进 入视图模式有两种模式： 常见用法: 批量注释 12v: 行选模式[ctrl]+v: 竖选模式 1.2.1 多行注释1 ) [ctrl]+v 进入竖选模式2 ) 选择范围3 ) 输入I4 ) 输入&#x2F;&#x2F;5 ) 输入[ESC] 2 文件的操作 命令 含义 :w 将输入buffer里面的内容写入文件，即保存 :q 退出 :q! 强制不保存退出 :wq 保存退出 注意：[ctrl] + s 不表示保存，而是进入僵死状态；[ctrl] + q 可以退出僵死状态。 3 窗口裁剪 命令 含义 :split(:sp) 新文件名 水平分割，并在新窗口中打开新文件 :new 新文件名 水平分割，并在新窗口中打开新文件 :vsplit(:vsp) 新文件名 垂直分割，并在新窗口中打开新文件 :vnew 新文件名 垂直分割，并在新窗口中打开新文件 ctrl + ww 切换窗口 :wall(:wa) 保存所有修改过的窗口 :qall(:qa) 退出所有窗口 :only(:o) 保留当前窗口，关闭所有其它窗口 4 配置Vim我们可以在 ~&#x2F;.vimrc 文件中配置 Vim，让 Vim 的使用更加得心应手。 每次启动 Vim时，Vim 都会读取这个文件，然后将里面的命令执行一遍。 12341 ) rc是&quot;running command&quot;的意思。每次启动时，都会执行这个文件中的命令。2 ) 如果没有~/.vimrc文件，不要惊慌，自己创建一个即可。3 ) 作为初学者，不建议大家自己去配置Vim。我们只需要安装vimplus就好了，vimplus会帮我们配置好Vim。 5 vimplus安装可以参考这个视频 6 练习手册Vim 贴心地为大家提供了一个练习手册 vimtutor: 12$ vimtutor$ vimtutor zh_CN # 汉化版的vimtutor Advice: 建议不熟练的同学可以每天抽出一定的时间去练习vimtutor","link":"","tags":[{"name":"vim","slug":"vim","permalink":"https://lyroom.github.io/tags/vim/"}]},{"title":"hexo图片插入问题","date":"2024-05-11T02:57:44.000Z","path":"2024/05/11/hexo图片插入问题/","text":"​ 今天在迁移完博客之后，发现之前插入的图片都没了，这就很恼人了，于是就开始了我的bug解决之路。 一.普遍解决办法安装hexo-image-img插件在bolg根部目录下找到_config.yaml文件，将post_asset_folder选项设置为true，作用就是在hexo new “文章名字”的时候，在同一目录下自动生一个同名字的文件夹，用于存放当前文章所需要的图片。 在终端输入以下命令： 1npm install hexo-asset-image --save 安装完成之后每次按照以下格式插入图片 1{% asset_img \"span>\" \"tittle\" %} 可以看出还是不能正常显示图片，图片连接如下 1http://localhost:4000/.com//dilireba.jpg 路径多了一个”.com”，这就是这个插件的坑爹之处,虽然网上有修改的办法，但是不想修改源代码，果断卸载，再去git找一个能用的 12npm uninstall hexo-asset-imagenpm install git://github.com/yiyungent/hexo-asset-img.git#main 成功解决，但是目前遇到的问题是，迪丽热巴的图太大了，有什么办法将其缩小一点了？遇事不决，可问文档！ 官方图片插入方法方法在 官方文档中我们可以知道一种修改插入并图片大小的方法如下： 如图所示，图片大小已经修改成功了。 缺点这个方法我仍然觉得不算太满意，因为导入typora文档时不仅需要修改路径还需要修改文件夹，并且无法等比例缩放图片，只能手动跳整这点我是不满意的。 HTML在source目录下新建一个images文件夹，images里面存放需要的照片,文件结构目录如下 123456source ├─images │ dilireba.jpg │ └─_posts lystyle.md 使用html语法来插入图片，并使用zoom元素对图片缩放，如下： 123&lt;center&gt;&lt;img src=&quot;images/dilireba.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/center&gt; 效果如下： 二.我的解决办法安装hexo-image-link插件如果之前安装了hexo-image-img插件需要先卸载 1npm uninstall hexo-image-img 将根目录下的_config.yml中的post_asset_folder置为true，目的就是在hexo new ”文档名“的时候在同一目录下新建一个同名文件夹 1post_asset_folder: true 之后只要在同名文件夹（可以手动新建）中，存放需要插入的图片，便可以直接使用，文件目录如下： 12345678910source ├─images │ dilireba.jpg │ └─_posts │ hello-world.md │ lystyle.md │ └─lystyle dilireba.jpg 使用方法如下： 传统插入路径简化，本地和github都能预览图片了 1![dilireba](lystyle/dilireba.jpg) 效果图： html方法，可以缩放图片大小，和位置 1234567891011&lt;!-- 简约版本 --&gt;&lt;center&gt;&lt;img src=&quot;lystyle/dilireba.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;​ &lt;/center&gt;&lt;!-- 复杂版本 --&gt;&lt;center&gt;&lt;img src=&quot;lystyle/dilireba.jpg&quot; title=&quot;dilireba&quot; alt=&quot;图片好像走丢了&quot; style=&quot;zoom:50%&quot;&gt;&lt;!--alt:表示图片未加载时显示的文字--&gt;&lt;div class=&quot;img-alt is-center&quot; align=&quot;center&quot;&gt;dilireba~&lt;/div&gt; &lt;!--这里写的是图注--&gt;&lt;/center&gt; 效果图：","link":"","tags":[{"name":"hexo","slug":"hexo","permalink":"https://lyroom.github.io/tags/hexo/"},{"name":"bug解决日记","slug":"bug解决日记","permalink":"https://lyroom.github.io/tags/bug%E8%A7%A3%E5%86%B3%E6%97%A5%E8%AE%B0/"}]},{"title":"hexo博客的迁移","date":"2024-05-10T10:17:39.000Z","path":"2024/05/10/hexo博客的迁移/","text":"​ 最近重装了系统，hexo相关的环境都没了，但是老博客的文件夹还在，记录一下博客迁移的过程。 环境准备git一.下载 官网下载链接 (不推荐，太慢了) 阿里镜像源(推荐，以下为下载教程) ​ 往下滑，找到最新版安装包下载，选择64bit版本下载 二.安装与配置​ 安装教程(这个比较详细，就不展开讲了) ​ 配置教程(配置教程) node一.下载与安装windows​ 官方链接 linux使用apt安装的版本并不是最新版本，这可能导致之后的安装会有问题，所以下面是安装最新node.js的教程： 添加NodeSource仓库 可以先去查看以下node最新版本,目前最新是24.x12# 安装Node.js 24.x版本curl -fsSL https://deb.nodesource.com/setup_24.x | sudo -E bash - 安装node.js和npm1sudo apt-get install -y nodejs ​安装好后，检查是否安装成功，在cmd中输入以下命令，查看node.js和npm版本 12node -vnpm -v hexo一.安装与配置12npm install -g hexo-clihexo -v 迁移工作文件目录详解打开旧博客文件夹，目录结构如下 保留文件（夹） _config.yml：站点配置 _config.landscape.yml：Landscape 主题的配置文件，Landscape 是 Hexo 的默认主题。 package.json：说明使用那些包 package-lock.json：文件是一个自动生成的文件，记录了整个项目的完整依赖树的具体版本信息。这确保了，不论何时、何地运行 npm install，都将安装完全相同版本的依赖。它帮助开发者避免由于依赖版本不同而导致的潜在问题。 scaffolds：文章的模板 source：自己写的博客文件 themes：主题 .gitignore：限定在提交的时候哪些文件可以忽略 删除文件（夹） .git：无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。 node_modules：在用npm install会重新生成 public：hexo g会重新生成 .deploy_git：在使用hexo d时也会重新生成 db.json文件 参考链接1 参考链接2 安装依赖和组件进入博客文件夹（上图所示目录），依次输入以下指令 1234npm installnpm install hexo-deployer-git --save # 为了使用hexo d来部署到git上 npm install hexo-generator-feed --save # 为了建立RSS订阅npm install hexo-generator-sitemap --save # 为了建立站点地图 使用和验证123hexo cleanhexo ghexo s 先本地访问看看能不能打开，如果能打开，就部署一下吧 1hexo d ok了！！！遇到的问题1.unable to access在使用hexo d时，遇到以下错误： 1fatal: unable to access &#x27;https://github.com/lyroom/lyroom.github.io.git/&#x27;: GnuTLS recv error (-110): The TLS connection was non-properly terminated. 解决方案： 1apt-get upgrade openssh-client //升级ssh 2.fatal: unable to access … Failure when receiving data from the peer升级之后仍然报错： 12345678Username for &#x27;https://github.com&#x27;: codingfish@outlook.comPassword for &#x27;https://codingfish%40outlook.com@github.com&#x27;: fatal: unable to access &#x27;https://github.com/lyroom/lyroom.github.io.git/&#x27;: Failure when receiving data from the peerFATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess.&lt;anonymous&gt; (/root/Blog/Blog/node_modules/hexo-util/lib/spawn.js:51:21) at ChildProcess.emit (node:events:507:28) at ChildProcess._handle.onexit (node:internal/child_process:294:12) 解决方法：改用ssh来远程部署 生成ssh公钥，并添加到github中，上面教程中有提到 测试ssh连接： 12345# 测试 GitHub 连接ssh -T git@github.com# 应该看到成功消息：# Hi lyroom! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 修改_config.yml文件 1234deploy: type: git repo: git@github.com:lyroom/lyroom.github.io.git branch: master 配置本地Git仓库： 1234567891011121314# 进入项目目录cd /root/Blog/Blog# 初始化 Git 仓库git init# 设置远程仓库地址（SSH 格式）git remote add origin git@github.com:lyroom/lyroom.github.io.git# 验证远程仓库设置git remote -v# 应该显示：# origin git@github.com:lyroom/lyroom.github.io.git (fetch)# origin git@github.com:lyroom/lyroom.github.io.git (push)","link":"","tags":[{"name":"github","slug":"github","permalink":"https://lyroom.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://lyroom.github.io/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://lyroom.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"git","slug":"git","permalink":"https://lyroom.github.io/tags/git/"},{"name":"node","slug":"node","permalink":"https://lyroom.github.io/tags/node/"},{"name":"npm","slug":"npm","permalink":"https://lyroom.github.io/tags/npm/"}]},{"title":"文件流详解","date":"2024-04-11T11:23:00.000Z","path":"2024/04/11/文件详解/","text":"1.什么是文件 文件是以硬盘为载体的存储在计算机上的信息集合 文件可以是文本文档，图片，程序 用户进行的输入输出中，以文件为基本单位 文件分为有结构文件，无结构文件 2.打开关闭&#x2F;文件C语言通过指针对文件流进行访问，指针类型为FILE*，在&lt;stdio.h&gt;中默认提供了三个标准流，可以直接使用不用打开和关闭 文件指针 流 默认含义 stdin 标准输入 键盘 stdout 标准输出 屏幕 stderr 标准错误 屏幕 2.1 fopen1FILE* fopen(const char* filename, const char* mode);//以mode方式打开路径为filename的文件 filename：文件路径 mode：文件打开模式 返回值：如果打开成功，则返回文件句柄FILE类型的值，如果失败，则返回EOF 2.2 fclose1int fclose(FILE* stream);//关闭程序不再使用的文件，一般和fopen成对出现 stream：打开句柄指针（fopen的返回值） 返回值：如果成功关闭返回0，失败返回EOF 2.3 mode分类1.文本文件（有结构文件） mode分类 含义 “r”（read） 以只读的方式打开文件（文件必须存在，否则返回EOF） “w”（write） 打开文件用于写入（文件不存在则创建），清空文件再写入 “a”（append） 打开文件在末尾追加（文件不存在则创建） “r+” 打开文件用于读和写（文件必须存在），从文件头开始覆盖 “w+” 打开文件用于读和写（文件不存在则创建），清空文件再写入 “a+” 打开文件用于读和写（文件不存在则创建），末尾追加 2.二进制文件（流式文件） mode分类 含义 “rb”（read binary） 以只读的方式打开文件（文件必须存在，否则返回EOF） “wb”（write binary） 打开文件用于写入（文件不存在则创建），清空文件再写入 “ab”（append binary） 打开文件在末尾追加（文件不存在则创建） “rb+”&#x2F;“r+b” 打开文件用于读和写（文件必须存在），从文件头开始覆盖 “wb+”&#x2F;“w+b” 打开文件用于读和写（文件不存在则创建），清空文件再写入 “ab+”&#x2F;“a+b” 打开文件用于读和写（文件不存在则创建），末尾追加 3.结果对比 r1234567891011121314151617181920int main(int argc,char* argv[]) &#123; //打开文件 FILE* src = fopen(argv[1], &quot;r&quot;);//以只读的方式打开文件 if (src == NULL) &#123; printf(&quot;Error:open %s failed\\n&quot;, argv[1]); exit(1); &#125; //插入字符，之后的操作是相同的 fputc(&quot;Y&quot;, src); fputc(&quot;E&quot;, src); fputc(&quot;S&quot;, src); //关闭文件 fclose(src); return 0;&#125; w1FILE* src = fopen(argv[1], &quot;w&quot;);//以全覆盖写的方式打开文件 a1FILE* src = fopen(argv[1], &quot;a&quot;);//以后缀写的方式打开文件 r+1FILE* src = fopen(argv[1], &quot;r+&quot;);//以从头覆盖读和写的方式打开文件,文件必须存在 w+1FILE* src = fopen(argv[1], &quot;w+&quot;);//以全部覆盖读和写的方式打开文件,文件不存在则创建 a+1FILE* src = fopen(argv[1], &quot;r+&quot;);//以末尾追加写的方式打开文件,可读可写,文件不存在则新建 3.读写文件3.1 fgetc &amp; fputc(字符级的读写)1int fgetc(FILE* stream);//从输入流中读取一个字符 stream：文件句柄指针 返回值：如果读取成功返回字符，失败则返回EOF 和getchar()的区别：getchar()只能在标准流stdin中读取一个字符 1int fputc(int c,FILE* stream);//向输出流中写入一个字符 c：字符 stream：文件句柄指针 返回值：如果写入成功返回写入字符，失败返回EOF 12345678910111213141516171819202122232425262728293031323334#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main() &#123; //copy The_Holy_Bible.txt to Bible.txt //打开文件流 FILE* src = fopen(&quot;The_Holy_Bible.txt&quot;, &quot;r&quot;); if (src == NULL) &#123; cout &lt;&lt; &quot;open failed!&quot;; exit(1); &#125; FILE* dst = fopen(&quot;Bible.txt&quot;, &quot;w&quot;); if (dst == NULL) &#123; fclose(src); exit(1); &#125; //复制文件 char ch; while ((ch = fgetc(src)) != EOF) &#123; fputc(ch, dst); &#125; //关闭文件 fclose(dst); fclose(src); cout &lt;&lt; res; return 0;&#125; 结果如图： 对比结果： 3.2 fgets &amp; fputs（行级的读写）fgets从输入流 stream 中，最多读取 count - 1 个字符，并把读取的字符存入 str 指向的字 符数组中。 fgets 遇到换行符’\\n’，或者文件的末尾就会终止(也就是说，读取的字符数可能不足 count - 1 个)，并且会存储换行符’\\n’。 fgets **会在最后添加空字 符’\\0’**。 1char* fgets(char* str, int count, FILE* stream); 参数： str: 指向一个字符数组 count: 能够写入的最大字符数量(通常是str指向字符数组的长度) stream: 输入流 返回值： 成功：返回str 失败：NULL fgets 是 gets 的通用版本，它可以从任意输入流中读取数据，而 gets 只能从 stdin 中读取数据。 fgets 也比 gets 更为安全，因为它限制了读取字符的最大数目 (count - 1)。此外，如果 fgets 是因为读取了换行符而终止，那么它会存储换行 符’\\n’，而 gets 函数从来不会存储换行符。 fputs将 str 指向的字符串，写入输出流 stream 中。 1int fputs(const char* str, FILE* stream); 参数： str: 要写的字符串(以’\\0’结尾的字符串) stream: 输入流 返回值： 成功：返回一个非负值 失败：EOF fputs 是 puts 的通用版本，它可以将字符串写入到任意的输出流中，而 puts 只能 写入到 stdout 中。此外， fputs 是原样输出字符串，而 puts 会在字符串后面而外 输出一个换行符’\\n’。 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char* argv[]) &#123; FILE* src = fopen(argv[1], &quot;r&quot;); if (src == NULL) &#123; printf(&quot;ERROR:open s% failed\\n&quot;, argv[1]); fclose(src); exit(1); &#125; FILE* dst = fopen(argv[2], &quot;w&quot;); if (dst == NULL) &#123; printf(&quot;ERROR：open %s failed\\n&quot;, argv[2]); fclose(src); exit(1); &#125; char buffer[1024]; while (fgets(buffer, 1024, src) != NULL) &#123; fputs(buffer, dst); &#125; fclose(src); fclose(dst); return 0;&#125; 3.3 fscanf &amp; fwrite(序列化的读写) 序列化：将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。 依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。 fscanffscanf 和 scanf 类似，是用来进行格式化输入的。 1int fscanf(FILE* stream, const char* format, ...) scanf 是从标准输入(stdin)中读取数据，而 fscanf 可以从任何一个流中读取数据。也就是说，当 fscanf 的第一个参数为 stdin 时，它的效果等价于 scanf 。顺便提一下， sscanf 可以从字符串中读取数据。 fprintffprintf 和 printf 类似，是用来进行格式化输出的。 1int fprintf(FILE* stream, const char* format, ...); printf 始终是向标准输出(stdout)写入内容的，而 fprintf 可以向任何 一个输出流中写入内容。也就是说，当 fprintf 的第一个参数为 stdout 时，它的效 果等价于 printf 。 顺便提一下， sprintf 可以将内容写入到一个字符数组中。 格式化输入输出，可以用于序列化和反序列化过程中。 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct stduent_s &#123; int number; char name[25]; int chinese; int math; int english;&#125;Student;int main(void) &#123; //序列化 Student s1 = &#123; 1,&quot;lystyle&quot;,100,150,120 &#125;; FILE* fp = fopen(&quot;students.dat&quot;, &quot;a&quot;); if (fp == NULL) &#123; printf(&quot;Error: open %s failed&quot;, &quot;sudents.dat&quot;); exit(1); &#125; fprintf(fp, &quot;%d\\t%s\\t%d\\t%d\\t%d\\n&quot;, s1.number, s1.name, s1.chinese, s1.math, s1.english); //反序列化 Student s2; FILE* dst = fopen(&quot;students.dat&quot;, &quot;r&quot;); if (dst == NULL) &#123; printf(&quot;Error: open %s failed&quot;, &quot;sudents.dat&quot;); exit(1); &#125; fscanf(dst, &quot;%d%s%d%d%d&quot;, &amp;s2.number, s2.name, &amp;s2.chinese, &amp;s2.math, &amp;s2.english); fclose(fp); fclose(dst); return 0;&#125; 结果 3.4 fread &amp; fwrite(二进制文件的读写)fread 和 fwrite 主要是用来处理二进制文件的。 fread fread 可以每次读取一大块数据。 1size_t fread(void* buffer, size_t size, size_t count, FILE* stream); 参数： ​ buffer: 指向存放数据的数组（并非只能是数组，也可以是指向一片连续的内存空间的首地址，可以是结构体） ​ size: 每个元素的大小(以字节为单位) ​ count: 最多可以读取的元素个数 ​ stream: 输入流 返回值： ​ 成功读取元素的个数。当读到文件末尾，或者发生错误时，返回值可能小于count。 ​ 我们可以通过feof和ferror函数来判断，到底是读到了文件末尾，还是发生了错误。 fwrite将存放在 buffer 指向的数组中的 count 个元素写入到输出流 stream 中。 1size_t fwrite(const void* buffer, size_t size, size_t count, FILE*stream); 参数： buffer: 指向存放数据的数组。 size: 每个元素的大小(以字节为单位) *count: 要写入元素的个数 * stream: 输出流 返回值: 成功写入元素的个数。当发生错误时，这个值可能小于count。 示例 12345678910111213141516171819202122232425262728293031#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(int argc,char* argv[]) &#123; printf(&quot;%d\\n&quot;, argc); printf(&quot;%s\\n&quot;, argv[0]); FILE* src = fopen(argv[1], &quot;rb&quot;);//dilireba.jpg if (src == NULL) &#123; printf(&quot;Error: open %s failed\\n&quot;,argv[1]); exit(1); &#125; FILE* dst = fopen(argv[2], &quot;wb&quot;);//copy_of_dilireba.jpg if (dst == NULL) &#123; printf(&quot;Error: open %s failed\\n&quot;, argv[2]); fclose(src); exit(1); &#125; char buffer[1024]; int n; while ((n = fread(buffer, 1, 10240, src)) &gt; 0) //只要读到了数据字节数大于0，就写入 &#123; fwrite(buffer, 1, n, dst); &#125; fclose(src); fclose(dst); return 0;&#125; 序列化&#x2F;反序列化 12345678910111213141516171819202122232425262728293031323334#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct student_s &#123; int number; char name[25]; int chinese; int math; int english;&#125;Student;int main(void) &#123; Student s = &#123; 1,&quot;lystyle&quot;,100,130,120 &#125;; FILE* src = fopen(&quot;student.info&quot;, &quot;ab&quot;); if (src == NULL) &#123; printf(&quot;open student.info failed!&quot;); exit(1); &#125; /*fwrite/fread函数的第一个参数并不是直接要求是一个数组，而是要求是一个指向数据的指针。 这个数据可以是一个简单的变量、数组、结构体，甚至是结构体数组等。关键在于这个指针必须指向你想要写入文件的数据的首地址。 在这个例子中，尽管使用了结构体变量s，但通过&amp;s获取了该结构体变量的地址作为fwrite的第一个参数。 这里&amp;s不是“一个数组”，而是一个指向整个Student结构体的指针。 结构体本身可以被视为一个连续的内存区域，fwrite会根据你提供的结构体大小（sizeof(s)），将这块内存区域的内容写入文件。 简而言之，fwrite的第一参数是一个const void*类型的指针，这意味着它可以接受任何类型数据的地址， 只要后面指定的size和count参数能够正确描述如何根据这个地址读取并写入数据。 所以，它灵活地适用于多种数据类型和数据集合，包括但不限于数组。*/ fwrite(&amp;s, sizeof(s), 1, src); Student s1; FILE* fp = fopen(&quot;student.info&quot;, &quot;rb&quot;); fread(&amp;s1, sizeof(s1), 1, fp); return 0;&#125; 结果 4.文件定位每个流都有相关联的文件位置。在执行读写操作时，文件位置会自动推进，并按照顺序访问文件。顺序访问是很好的，但是有时候，我们可能需要跳跃地访问文件。为此，提供了几个函数来支持这种能力。 123int fseek(FILE* stream, long int offset, int whence);long int ftell(FILE* stream);void rewind(FILE* stream); fseekfseek 可以改变与 stream 相关联的文件位置。 1int fseek(FILE* stream, long int offset, int whence); 参数： stream：文件流 whence：表示参照点，参照点有 3 个选择： SEEK_SET：文件的起始位置。 SEEK_CUR：文件的当前位置。 SEEK_END：文件的末尾位置。 ​ offset：表示偏移量 (可能为负)，它是以字节进行计数的。 ​ 移动到文件的起始位置，可以这样写：fseek(fp, 0L, SEEK_SET); ​ 移到文件的末尾：fseek(fp,0L,SEEK_END); ​ 往回移动10个字节：fseek(fp,-10L,SEEK_CUR); 返回值： ​ 通常情况下会返回0，如果发生错误返回（如位置不存在）返回非0值 ftell以长整数形式返回当前文件位置，如果发生错误返回-1。 123long int filePos = ftell(fp);...fseek(fp, filePos, SEEK_SET); rewind会将文件位置设置为起始位置，类似于调用： 12rewind(fp);fseek(fp,0L,SEEK_SET); 示例 1234567891011121314151617181920212223#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;long textSize(char* name) &#123; FILE* src = fopen(name, &quot;r&quot;); if (src == NULL) &#123; printf(&quot;Error: open %s failed\\n&quot;, name); exit(1); &#125; fseek(src, 0L, SEEK_END);//将指针指向末尾 long fileSize = ftell(src);//获取末尾处的字节号，即该文件占用的字节数 rewind(src);//将指针回退到起点 fclose(src); return fileSize + 1;&#125;int main(int argc, char* argv[]) &#123; printf(&quot;%ld&quot;, textSize(argv[1])); return 0;&#125; 结果 字数统计 5.错误处理errno​ 错误的检测和处理并不是 C 语言的强项，C 语言没有其它高级语言 (C++, Java, C# 等) 所具有的异常处理机制。C 语言往往是通过函数的返回值，或者是测试 errno 变 量来检测错误的；并且需要程序员自己编写代码来处理错误。 ​ errno 是一个 int 类型的全局变量 (C11 修改为线程本地变量，即每个线程都有一个 独有的 errno 变量)，它定义在头文件中。标准库中有些函数 (比如与文件 相关的一些函数)，如果在调用过程中发生了错误，它会设置 errno 的值，以表明发生 了何种类型的错误。 ​ 程序启动时，会将 errno 的值设为 0，表示没有错误发生。其它非 0 值都表示发生了 某种类型的错误。我们可以通过 perror 和 strerror 来显示错误信息。其中， perror 定义在 头文件中， strerror 定义在 头文件中。 1234567891011121314#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;errno.h&gt;int main(void) &#123; printf(&quot;%d\\n&quot;, errno);//初始值设为0 FILE* fp = fopen(&quot;NO_SUCH_FILE.txt&quot;, &quot;r&quot;); printf(&quot;%d\\n&quot;, errno);//错误类型为2 printf(&quot;%s\\n&quot;,strerror(errno));//打印错误类型 if(errno != 0) perror(&quot;NO_SUCH_FILE.txt&quot;);//加上前缀打印错误类型 return 0; 结果","link":"","tags":[{"name":"c","slug":"c","permalink":"https://lyroom.github.io/tags/c/"},{"name":"文件操作","slug":"文件操作","permalink":"https://lyroom.github.io/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"}]},{"title":"细说浮点数","date":"2023-01-11T18:00:38.000Z","path":"2023/01/12/细说浮点数/","text":"一.什么是浮点数​ 浮点数能够表示带小数部分的数字，如我们小学常定义的Π值3.1415926，它们提供的值范围也更大也更为精准。当然如果数字很大，以至于无法表示为long类型，如人体的细菌数（估计超过100兆），则可以使用浮点类型来表示。 ​ 使用浮点类型可以表示诸如2.5、3.14159和122442.32这样的数字，即带小数部分的数字。计算机将这样的值分成两部分存储。一部分表示值，另一部分用于对值进行放大或缩小。下面打个比方。对于数字34.1245和34124.5，它们除了小数点的位置不同外，其他都是相同的。可以把第一个数表示为0.341245（基准值）和100（缩放因子），而将第二个数表示为0.341245（基准值相同）和10000（缩放因子更大）。缩放因子的作用是移动小数点的位置，术语浮点因此而得名。C++内部表示浮点数的方法与此相同，只不过它基于的是二进制数，因此缩放因子是2的幂，不是10的幂。幸运的是，初学计算的程序员不必详细了解内部表示（当你学过计组之后就会有详细的认识）。重要的是，浮点数能够表示小数值、非常大和非常小的值，它们的内部表示方法与整数有天壤之别。 二.浮点数的书写​ 在c++中浮点数分两种写法： 标准小数点的写法（我们常见的小数写法） 12343.14100.4599.11.0 E表示法（类似于我们常见的科学计数法） 1233.14e3//表示3.14*10^33.14e+3//表示3.14*10^39.11e-31//表示9.11*10^(-31)电子质量，单位千克 三.浮点数的分类​ 和ANSI C一样，C++也有3种浮点类型：float、double和long double。这些类型是按它们可以表示的有效数位和允许的指数最小范围来描述的。有效位（significant figure）是数字中有意义的位。例如，珠穆朗玛峰的高度是8,849米，该数字使用了4个有效位，指出了最接近的高度数。然而，将珠穆朗玛峰的高度写成约8800米时，有效位数为2位，因为结果经过四舍五入精确到了百位。在这种情况下，其余的2位只不过是占位符而已。有效位数不依赖于小数点的位置。例如，可以将高度写成8.849米。这样仍有4个有效位，因为这个值精确到了第4位。 ​ 事实上，C和C++对于有效位数的要求是，float至少32位，double至少48位，且不少于float，long double至少和double一样多。这三种类型的有效位数可以一样多。然而，通常，float为32位，double为64位，long double为80、96或128位。另外，这3种类型的指数范围至少是−37到37。可以从头文件cfloat或float.h中找到系统的限制。以下是float.h的部分代码，关键位置标有中文注 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180//// float.h//// Copyright (c) Microsoft Corporation. All rights reserved.//// Implementation-defined values commonly used by sophisticated numerical// (floating point) programs.// Define the floating point precision used.定义使用的浮点精度/*FLT_EVAL_METHOD 用来指明在表达式求值（尤其是数学运算）过程中是否需要提升浮点数的类型，可能的取值有： -1：未知的，不确定的。 0：不提升类型，使用当前的类型。 1：将浮点数提升到 double 类型，大于等于 double 类型的保持不变；也就是说，将 float 类型提升为 double 类型，double 和 long double 类型不变。 2：将浮点数提升到 long double；也就是说，将 float、double 提升到 long double 类型，long double 类型保持不变。 【注】FLT_EVAL_METHOD 对所有浮点数类型（float、double 和 long double）都有效，也就是说，所有浮点数类型都必须采用相同的类型提升。提升类型能够提高浮点数的精度，让表达式的结果更加精确。*/#ifdef _M_FP_FAST #define FLT_EVAL_METHOD -1#else #ifdef _M_IX86 #if _M_IX86_FP &gt;= 2 #define FLT_EVAL_METHOD 0 #else #define FLT_EVAL_METHOD 2 #endif #else #define FLT_EVAL_METHOD 0 #endif#endif//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+//// Constants 定义了各种类型的数据的精度，即小数点的位数////-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ //DBL开头的是double类型的#define DBL_DECIMAL_DIG 17 // # of decimal digits of rounding precision /* 从 float/double/long double 转换到至少有 FLT_DECIMAL_DIG/DBL_DECIMAL_DIG/LDBL_DECIMAL_DIG 位数字的十进制，再转换回原类型为恒等转换：这是序列化/反序列化浮点值所要求的十进制精度。分别定义为至少 6、10 和 10，对于 IEEE float 为 9，对于 IEEE double 为 17。 */#define DBL_DIG 15 // # 转换成十进制形式后，小数点后精确数字（能够保证精度的数字）的位数。#define DBL_EPSILON 2.2204460492503131e-016 // smallest such that 1.0+DBL_EPSILON != 1.0 1和大于1的最小浮点数的差值，可以表示最小的有效数字#define DBL_HAS_SUBNORM 1 //指明类型是否支持非正规数值 /* -1: 为不确定， 0: 为不支持， 1: 为支持。 */#define DBL_MANT_DIG 53 // # of bits in mantissa // 基数（进制）为 FLT_RADIX 时，尾数 mantissa 的最大长度（最大位数），也可以说是浮点数的精度。注意，这里所说的长度包含了整数部分和小数部分。#define DBL_MAX 1.7976931348623158e+308 // max value 基数（进制）为 FLT_RADIX 时，规格化浮点数的指数（也即 exponent）的最大值（为正数）。#define DBL_MAX_10_EXP 308 // max decimal exponent 转换为10进制后，规格化浮点数的的指数的最大值#define DBL_MAX_EXP 1024 // max binary exponent double指数最大二进制#define DBL_MIN 2.2250738585072014e-308 // 定义了双精度浮点数的最小值#define DBL_MIN_10_EXP (-307) // 转换成十进制形式后，规格化浮点数的指数的最小值（为负数）。#define DBL_MIN_EXP (-1021) // 基数（进制）为 FLT_RADIX(此时为2)时，规格化浮点数的指数(也即exponent)的最小值(为负数)#define _DBL_RADIX 2 // exponent radix 指数的进制#define DBL_TRUE_MIN 4.9406564584124654e-324 // min positive value 双精度浮点数的最小值 //FLT开头的是float类型的，各种变量的含义同double#define FLT_DECIMAL_DIG 9 // # of decimal digits of rounding precision#define FLT_DIG 6 // # of decimal digits of precision#define FLT_EPSILON 1.192092896e-07F // smallest such that 1.0+FLT_EPSILON != 1.0#define FLT_HAS_SUBNORM 1 // type does support subnormal numbers#define FLT_GUARD 0#define FLT_MANT_DIG 24 // # of bits in mantissa#define FLT_MAX 3.402823466e+38F // max value#define FLT_MAX_10_EXP 38 // max decimal exponent#define FLT_MAX_EXP 128 // max binary exponent#define FLT_MIN 1.175494351e-38F // min normalized positive value#define FLT_MIN_10_EXP (-37) // min decimal exponent#define FLT_MIN_EXP (-125) // min binary exponent#define FLT_NORMALIZE 0#define FLT_RADIX 2 // 定义了浮点数的进制，对所有的浮点数都有效，所有的浮点数都必须采用2进制#define FLT_TRUE_MIN 1.401298464e-45F // min positive value //开头的是double long类型的，各种变量的含义同double#define LDBL_DIG DBL_DIG // # of decimal digits of precision#define LDBL_EPSILON DBL_EPSILON // smallest such that 1.0+LDBL_EPSILON != 1.0#define LDBL_HAS_SUBNORM DBL_HAS_SUBNORM // type does support subnormal numbers#define LDBL_MANT_DIG DBL_MANT_DIG // # of bits in mantissa#define LDBL_MAX DBL_MAX // max value#define LDBL_MAX_10_EXP DBL_MAX_10_EXP // max decimal exponent#define LDBL_MAX_EXP DBL_MAX_EXP // max binary exponent#define LDBL_MIN DBL_MIN // min normalized positive value#define LDBL_MIN_10_EXP DBL_MIN_10_EXP // min decimal exponent#define LDBL_MIN_EXP DBL_MIN_EXP // min binary exponent#define _LDBL_RADIX _DBL_RADIX // exponent radix#define LDBL_TRUE_MIN DBL_TRUE_MIN // min positive value#define DECIMAL_DIG DBL_DECIMAL_DIG//定义了浮点数的舍入方式/*由下列代码可知，每种浮点数舍入方式是必须相同的，均是由__fpe_flt_rounds()函数确定的，不同的返回值，代表的含义如下-1、不确定：即舍入方式不确定1、就近舍入： 即十进制下的四舍五入。但是也会出现以下几种情况： 多余数字是1001，它大于0.5，故最低位进1。 多余数字是0111，它小于0.5，则直接舍掉多余数字。 多余数字是1000，正好是等于0.5的特殊情况；那么此时最低位为0则舍掉多余位，最低位为1则进位1。 注意这里说明的数位都是指二进制数。因为这是尾数，所以在计算这些二进制和0.5的关系的时候，也即转为10进制的时候，我们用每一位的权重乘以2^(-i)然后求和即可。2、朝0舍入：即朝数轴零点方向舍入，所以我们直接截尾即可。3、朝正无穷舍入：对正数而言，多余位全为0则直接截尾，不全为0则向最低有效位进1；负数的话不管多余位是多少直接截尾即可。4、朝负无穷舍入：对负数而言，多余位全为0则直接截尾，不全为0则向最低有效位进1；正数的话不管多余位是多少直接截尾即可。*/#define FLT_ROUNDS (__fpe_flt_rounds())#define _DBL_ROUNDS FLT_ROUNDS#define _LDBL_ROUNDS _DBL_ROUNDS//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+//// IEEE Recommended Functions IEEE(电气电子工程师学会) 推荐的一些浮点型的常用方法////-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+/*copysign()函数是cmath标头的库函数，用于获取带有第二个参数的符号的第一个参数的值，它接受两个参数( x，y )并以y的符号返回x的大小。*/_Check_return_ _ACRTIMP double __cdecl _copysign(_In_ double _Number, _In_ double _Sign);//返回一个与 _X 符号相反数值相同的数（正变为负，负变为正）；_Check_return_ _ACRTIMP double __cdecl _chgsign(_In_ double _X);//输出x乘以2的y次幂的结果；_Check_return_ _ACRTIMP double __cdecl _scalb(_In_ double _X, _In_ long _Y);// 求输入数是2的多少次幂，返回值对确切结果向0取整；_Check_return_ _ACRTIMP double __cdecl _logb(_In_ double _X);// 输出x对y方向在double精度上的下一个值；_Check_return_ _ACRTIMP double __cdecl _nextafter(_In_ double _X, _In_ double _Y);//检查输入是否有效，若为 INT 或 NaN 则返回0，有效数值返回1；_Check_return_ _ACRTIMP int __cdecl _finite(_In_ double _X);//返回输入是否为 NaN。_Check_return_ _ACRTIMP int __cdecl _isnan(_In_ double _X); /* 返回一个浮点数的分类，具体如下： _FPCLASS_SNAN 信号 NaN _FPCLASS_QNAN 安静的南 _FPCLASS_NINF 负无穷大 ( -INF) _FPCLASS_NN 负归一化非零 _FPCLASS_ND 负非规范化 _FPCLASS_NZ 负零 (-0) _FPCLASS_PZ 正 0 (+0) _FPCLASS_PD 正反规格化 _FPCLASS_PN 正归一化非零 _FPCLASS_PINF 正无穷大 ( +INF) */_Check_return_ _ACRTIMP int __cdecl _fpclass(_In_ double _X);#ifdef _M_X64 _Check_return_ _ACRTIMP float __cdecl _scalbf(_In_ float _X, _In_ long _Y);#endif_CRT_END_C_HEADER_UCRT_RESTORE_CLANG_WARNINGS#pragma warning(pop) // _UCRT_DISABLED_WARNINGS#endif // _INC_FLOAT 四.浮点数的“四舍五入”​ 在浮点数的舍入问题上，IEEE 浮点格式定义了 4 种不同的舍入方式，如下表所示。其中，默认的舍入方法是向偶数舍入，而其他三种可用于计算上界和下界。 下表是 4 种舍入方式的应用举例。这里需要特别说明的是，向偶数舍入（向最接近的值舍入）方式会试图找到一个最接近的匹配值。因此，它将 1.4 舍入成 1，将 1.6 舍入成 2，而将 1.5 和 2.5 都舍入成 2。 ​ 或许看了上面的内容你会问：为什么要采用向偶数舍入这样的舍入策略，而不直接使用我们已经习惯的“四舍五入”呢？ ​ 其原因我们可以这样来理解：在进行舍入的时候，最后一位数字从 1 到 9，舍去的有 1、2、3、4；它正好可以和进位的 9、8、7、6 相对应，而 5 却被单独留下。如果我们采用四舍五入每次都将 5 进位的话，在进行一些大量数据的统计时，就会累积比较大的偏差。而如果采用向偶数舍入的策略，在大多数情况下，5 舍去还是进位概率是差不多的，统计时产生的偏差也就相应要小一些。 ​ 同样，针对浮点数据，向偶数舍入方式只需要简单地考虑最低有效数字是奇数还是偶数即可。例如，假设我们想将十进制数舍入到最接近的百分位。不管用哪种舍入方式，我们都将把 1.2349999 舍入到 1.23，而将 1.2350001 舍入到 1.24，因为它们不是在 1.23 和 1.24 的正中间。另一方面我们将把两个数 1.2350000 和 1.2450000 都舍入到 1.24，因为 4 是偶数。 五.浮点数标准IEEE7541.IEEE浮点数标准简介​ IEEE 于 1987 年推出了与底数无关的二进制浮点运算标准 IEEE 854，并于同年被美国引用为 ANSI 标准。1989 年，国际标准组织 IEC 批准 IEEE 754&#x2F;854 为国际标准 IEC 559：1989。后来经修订后，标准号改为 IEC 60559。现在，几乎所有的浮点处理器完全或基本支持 IEC 60559。同时，C99 的浮点运算也支持 IEC 60559。 ​ IEEE 浮点数标准是从逻辑上用三元组{S，E，M}来表示一个数 V 的，即 V &#x3D;（-1)^S * M * 2^E，如下图所示： 符号位S（sign）:S &#x3D; 0: 表示该数为正数，S &#x3D; 1:表示该数为负数 指数位E（Exponent）:在计算机中用移码表示，表示2的多少次幂 有效位M（Significand）：在计算机中用补码表示，表示二进制小数，也称尾数 2.IEEE754标准下的浮点数的格式 补：原码，反码，补码，移码（以8位为例） 二进制整数都是以补码形式出现的。 正数的补码与反码、原码一致， 负数的补码是反码+1.这样使减法运算可以使用加法器实现，符号位也参与运算; 移码与补码就是符号位取反 十进制原码 二进制原码 反码 补码 移码 -128 无 无 1000 0000 0000 0000 -127 1111 1111 1000 0000 1000 0001 0000 0001 -126 1111 1110 1000 0001 1000 0010 0000 0010 …… …… …… …… …… -1 1000 0001 1111 1110 1111 1111 0111 1111 -0 1000 0000 1111 1111 无 无 +0 0000 0000 0000 0000 0000 0000 1000 0000 +1 0000 0001 0000 0001 0000 0001 1000 0001 …… …… …… …… …… +126 0111 1110 0111 1110 0111 1110 1111 1110 +127 0111 1111 0111 1111 0111 1111 1111 1111 移码的计算方法： ​ 移码 &#x3D; 真值+偏置值 偏置值的计算方法 偏置值 ieee754偏置值 普通偏置值 计算方法 2^(n-1) - 1 2^(n-1) n代表的含义 表示移码的位数 原码的位数 ​ 在IEEE754标准中，规格化的浮点数的尾数部分通常隐藏最高有效位1 数符 阶码部分，使用移码表示（阶码全1或全0特殊用途） 尾数部分，用原码表示（隐藏最高位为1） A E M（1.M） ​ 各类浮点数各部分占用位数及格式： 类型 大小（B) 数符 阶码 尾数 总位数（bit） 16位偏置 10位偏置 float 4 1 8 23 32 7FH 127 double 8 1 11 52 64 3FFH 1023 long double 10 1 15 64 80 3FFFH 16383 3.浮点数的规格化​ 对于一个小数段frac，可解释为描述小数值 f，其中 0≤f&lt;1，其二进制表示为 0.fn-1… f1f0，也就是二进制小数点在最高有效位的左边。有效数字定义为 M&#x3D;1+f。有时候，这种方式也叫作隐含的以 1 开头的表示法，因为我们可以把 M 看成一个二进制表达式为 1.fn-1fn-2…f0 的数字。既然我们总是能够调整指数 E，使得有效数字 M 的范围为 1≤M&lt;2（假设没有溢出），那么这种表示方法是一种轻松获得一个额外精度位的技巧。同时，由于第一位总是等于 1，因此我们就不需要显式地表示它。拿单精度数为例，按照上面所介绍的知识，实际上可以用 23 位长的有效数字来表达 24 位的有效数字。 ​ 比如，对单精度数而言，二进制的 1001.101（即十进制的 9.625）可以表达为 1.001101×2^3，所以实际保存在有效数字位中（即尾数部分）的值为： 100110100000000000000000 即，去掉小数点及其左边的1，并用0补齐尾数（涉及到了补码的位数扩展，详细细节请查阅相关资料） ​ 根据上述规则，下面是将-9.625转化为单精度浮点数的的具体过程： 1、首先，需要将 -9.625 用二进制浮点数表达出来，然后变换为相应的浮点数格式。即 -9.625 的二进制为 1001.101，用规范的浮点数表达应为 1.001101×2^3。 2、其次，因为 -9.625 是负数，所以符号段为 1。而这里的指数为 3，所以指数段为 3+127&#x3D;130，即二进制的 10000010。有效数字省略掉小数点左侧的 1 之后为 001101，然后在右侧用零补齐。因此所得的最终结果为： 3、最后，我们还可以将浮点数形式表示为十六进制的数据，如下所示： 即最终的十六进制结果为 0xC11A0000。 4.揭示特殊值​ IEEE 标准指定了以下特殊值：±0、反向规格化的数、±∞ 和 NaN（如下表所示）。这些特殊值都是使用 emax+1 或 emin-1 的指数进行编码的。 NaN​ NaN：当指数段 exp 全为 1 时，小数段为非零时，结果值就被称为“NaN”（Not any Number），如下图 所示。 ​ 一般情况下，我们将 0&#x2F;0 或: 视为导致计算终止的不可恢复错误。但是，一些示例表明在这样的情况下继续进行计算是有意义的。这时候就可以通过引入特殊值 NaN，并指定诸如 0&#x2F;0 或 之类的表达式计算来生成 NaN 而不是停止计算，从而避免此问题。下表中列出了一些可以导致 NaN 的情况。 无穷​ 无穷：当指数段 e全为 1，小数段全为 0 时，得到的值表示无穷。当 s&#x3D;0 时是 +∞，或者当 s&#x3D;1 时是 -∞。如下图所示。 无穷用于表达计算中产生的上溢问题。比如两个极大的数相乘时，尽管两个操作数本身可以保存为浮点数，但其结果可能大到无法保存为浮点数，必须进行舍入操作。根据IEEE标准，此时不能将结果舍入为可以保存的最大浮点数（因为这个数可能与实际的结果相差太远而毫无意义），而应将其舍入为无穷。对于结果为负数的情况也是如此，只不过此时会舍入为负无穷，也就是说符号域为1的无穷。 非格式化值当指数段 exp 全为 0 时，所表示的数就是非规格化形式，如图 5 所示。 在这种情况下，指数值 E&#x3D;1-Bias，而有效数字的值 M&#x3D;f，也就是说它是小数段的值，不包含隐含的开头的 1。 非规格化值有两个用途： 第一，它提供了一种表示数值 0 的方法。因为规格化数必须得使有效数字 M 在范围 1≤M&lt;2 之中，即 M≥1，因此它就不能表示 0。实际上，+0.0 的浮点表示的位模式为全 0（即符号位是 0，指数段全为 0，而小数段也全为 0），这就得到 M&#x3D;f&#x3D;0。令人奇怪的是，当符号位为 1，而其他段全为 0 时，就会得到值 -0.0。根据 IEEE 的浮点格式来看，值 +0.0 和 -0.0 在某些方面是不同的。 第二，它表示那些非常接近于 0.0 的数。它们提供了一种属性，称为逐渐下溢出。其中，可能的数值分布均匀地接近于 0.0。 下面的单精度浮点数就是一个非格式化的示例。 它被转换成十进制表示大约等于 1.4×10-45，实际上它就是单精度浮点数所能表达的最小非格式化数。以此类推，格式化值和非格式化值所能表达的非负数值范围如下表所示。 六.小小的总结​ 通过学习IEEE754标准后，再回顾float.h,相信对一些宏定义的值就有了比较好的理解了，例如 12#define FLT_DIG 6 // # of decimal digits of precision#define DBL_DIG 15 // # 转换成十进制形式后，小数点后精确数字（能够保证精度的数字）的位数。 因为单精度浮点数的尾数有23位，2^23 &#x3D; 8388608，一共七位十进制数，这意味着转化为十进制之后，最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为6~7位有效数字。双精度浮点数同理。","link":"","tags":[{"name":"c++","slug":"c","permalink":"https://lyroom.github.io/tags/c/"},{"name":"float","slug":"float","permalink":"https://lyroom.github.io/tags/float/"}]},{"title":"《千与千寻》我的路","date":"2023-01-11T17:12:02.000Z","path":"2023/01/12/《千与千寻》我的路/","text":"​ 不管前方的路有多苦，只要走的方向正确，不管多么崎岖不平，都比站在原地更接近幸福。 ​ —— 宫崎骏《千与千寻》 《千与千寻》 ​","link":"","tags":[{"name":"浮生六记","slug":"浮生六记","permalink":"https://lyroom.github.io/tags/%E6%B5%AE%E7%94%9F%E5%85%AD%E8%AE%B0/"}]},{"title":"八大排序算法","date":"2020-08-09T11:23:00.000Z","path":"2020/08/09/八大排序算法/","text":"1. 概述排序算法分为内部排序和外部排序 内部排序把数据记录放在内存中进行排序; 外部排序因排序的数据量大，内存不能一次容纳全部的排序记录，所以在排序过程中需要访问外存。 经常提及的八大排序算法指的就是内部排序的八种算法，分别是冒泡排序、快速排序、直接插入排序、希尔排序、简单选择排序、堆排序、归并排序和基数排序，如果按原理划分，冒泡排序和快速排序都属于交换排序，直接插入排序和希尔排序属于插入排序，而简单选择排序和堆排序属于选择排序，如上图所示。 2. 冒泡排序2.1 基本思想冒泡排序（Bubble Sort）是一种简单的排序算法。它重复访问要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。访问数列的工作是重复地进行直到没有再需要交换的数据，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端，像水中的气泡从水底浮到水面。 2.2 算法描述冒泡排序算法的算法过程如下： ①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 ②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 ③. 针对所有的元素重复以上的步骤，除了最后一个。 ④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。 12345678910111213141516171819//冒泡排序 public static int[] BubbleSort(int [] arrays)&#123; //外层：需要length-1次循环比较 for (int i=0;i&lt;arrays.length-1;i++)&#123; //内层：需要每两个相邻元素比较，如果前一个数据大于第二个，则交换。最终找出最大的元素 for (int j=0;j&lt;arrays.length-i-1;j++)&#123; if (arrays[j]&gt;=arrays[j+1]) swap(arrays , j, j+1); &#125; &#125; return arrays; &#125; public static void swap(int[] array, int i, int j) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125;&#125; 2.4 算法效率冒泡排序是稳定的排序算法，最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²&#x2F;2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1)。 2.5 交换数字的三种方法我们从冒泡排序的代码中看到了交换两个数字的方法 swap(int[] array, int i, int j)，这里使用了临时变量，而交换数字主要有三种方法，临时变量法、算术法、位运算法、面试中经常会问到，这里简单说一下，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839//swap的三种方法 //1.临时变量法 /** * 通过临时变量交换数组array的i和j位置的数据 * @param array 数组 * @param i 下标i * @param j 下标j */ public static void swap_temp(int[] array, int i, int j) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; //2.位运算法 /** * 通过位运算法交换数组array的i和j位置的数据 * @param array 数组 * @param i 下标i * @param j 下标j */ public static void swap_Operation(int[] array, int i, int j) &#123; array[i] = array[i] ^ array[j]; array[j] = array[i] ^ array[j]; //array[i]^array[j]^array[j]=array[i] array[i] = array[i] ^ array[j]; //array[i]^array[j]^array[i]=array[j] &#125; //3.Arithmetic /** * 通过算术法交换数组array的i和j位置的数据（有可能溢出） * @param array 数组 * @param i 下标i * @param j 下标j */ public static void swap_Arithmetic(int[] array, int i, int j) &#123; array[i] = array[i] + array[i + 1]; array[i + 1] = array[i] -array[i + 1]; //array[i]^array[j]^array[j]=array[i] array[i] = array[i] -array[i + 1]; //array[i]^array[j]^array[i]=array[j] &#125;&#125; 3. 快速排序3.1 基本思想快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想，由C. A. R. Hoare在1962年提出。 基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 3.2 算法描述快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为： ①. 从数列中挑出一个元素，称为”基准”（pivot）。 ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 ③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。 递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 3.3 代码实现①. 挖坑法 用伪代码描述如下： （1）low &#x3D; L; high &#x3D; R; 将基准数挖出形成第一个坑a[low]。 （2）high–，由后向前找比它小的数，找到后挖出此数填前一个坑a[low]中。 （3）low++，由前向后找比它大的数，找到后也挖出此数填到前一个坑a[high]中。 （4）再重复执行②，③二步，直到low&#x3D;&#x3D;high，将基准数填入a[low]中。 举例说明： 一个无序数组：[4, 3, 7, 5, 10, 9, 1, 6, 8, 2] （1）随便先挖个坑，就在第一个元素（基准元素）挖坑，挖出来的“萝卜”（第一个元素4）在“篮子”（临时变量）里备用。 挖完之后的数组是这样：[ 坑, 3, 7, 5, 10, 9, 1, 6, 8,2] （2）挖右坑填左坑：从右边开始，找个比“萝卜”（元素4）小的元素，挖出来，填到前一个坑里面。 填坑之后：[ 2, 3, 7, 5, 10, 9, 1, 6, 8,坑] （3）挖左坑填右坑：从左边开始，找个比“萝卜”（元素4）大的元素，挖出来，填到右边的坑里面。 填坑之后：[ 2, 3,坑, 5, 10, 9, 1, 6, 8, 7] （4）挖右坑填左坑：从右边开始，找个比“萝卜”（元素4）小的元素，挖出来，填到前一个坑里面。 填坑之后：[ 2, 3, 1, 5, 10, 9,坑, 6, 8, 7] （5）挖左坑填右坑：从左边开始，找个比“萝卜”（元素4）大的元素，挖出来，填到右边的坑里面。 填坑之后：[ 2, 3, 1,坑, 10, 9, 5, 6, 8, 7] （6）挖右坑填左坑：从右边开始，找个比“萝卜”（元素4）小的元素，挖出来，填到前一个坑里面，这一次找坑的过程中，找到了上一次挖的坑了，说明可以停了，用篮子里的的萝卜，把这个坑填了就行了，并且返回这个坑的位置，作为分而治之的中轴线。 填坑之后：[ 2, 3, 1, 4, 10, 9, 5, 6, 8, 7] 1234567891011121314151617181920212223242526272829303132333435363738/** * 快速排序（挖坑法递归） * @param arr 待排序数组 * @param low 左边界 * @param high 右边界 */public static void sort(int arr[], int low, int high) &#123; //递归需要一个结束点 if (arr == null || arr.length &lt;= 0) &#123; return; &#125; if (low &gt;= high) &#123; return; &#125; int left = low; int right = high; //挖坑1：保存基准的值 int temp = arr[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; arr[right] &gt;= temp) &#123; right--; &#125; //坑2：从后向前找到比基准小的元素，插入到基准位置坑1中 arr[left] = arr[right]; while (left &lt; right &amp;&amp; arr[left] &lt;= temp) &#123; left ++; &#125; //坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中 arr[right] = arr[left]; &#125; //基准值填补到坑3中，准备分治递归快排 arr[left] = temp; System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr)); sort(arr, low, left-1); sort(arr, left + 1, high);&#125; ②. 左右指针法 用伪代码描述如下： （1）low &#x3D; L; high &#x3D; R; 选取a[low]作为关键字记录为key。 （2）high–，由后向前找比它小的数 （3）low++，由前向后找比它大的数 （4）交换第（2）、（3）步找到的数 （5）重复（2）、（3），一直往后找，直到left和right相遇，这时将key和a[low]交换位置。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 快速排序（左右指针法） * @param arr 待排序数组 * @param low 左边界 * @param high 右边界 */public static void sort2(int arr[], int low, int high) &#123; if (arr == null || arr.length &lt;= 0) &#123; return; &#125; if (low &gt;= high) &#123; return; &#125; int left = low; int right = high; int key = arr[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; arr[right] &gt;= key) &#123; right--; &#125; while (left &lt; right &amp;&amp; arr[left] &lt;= key) &#123; left++; &#125; if (left &lt; right) &#123; swap(arr, left, right); &#125; &#125; swap(arr, low, left); System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr)); sort2(arr, low, left - 1); sort2(arr, left + 1, high);&#125;public static void swap(int arr[], int low, int high) &#123; int tmp = arr[low]; arr[low] = arr[high]; arr[high] = tmp;&#125; 3.4 算法效率快速排序并不稳定，快速排序每次交换的元素都有可能不是相邻的, 因此它有可能打破原来值为相同的元素之间的顺序。 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(nlogn) O(nlogn) O(n2) O(1) 4. 直接插入排序4.1 基本思想直接插入排序的基本思想是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。 4.2 算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： ①. 从第一个元素开始，该元素可以认为已经被排序 ②. 取出下一个元素，在已经排序的元素序列中从后向前扫描 ③. 如果该元素（已排序）大于新元素，将该元素移到下一位置 ④. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 ⑤. 将新元素插入到该位置后 ⑥. 重复步骤②~⑤ 4.3 代码实现提供两种写法，一种是移位法，一种是交换法。移位法是完全按照以上算法描述实，再插入过程中将有序序列中比待插入数字大的数据向后移动，由于移动时会覆盖待插入数据，所以需要额外的临时变量保存待插入数据，代码实现如下： ①. 移位法： 1234567891011121314 public static void sort(int[] a) &#123; if (a == null || a.length == 0) &#123; return; &#125; for (int i = 1; i &lt; a.length; i++) &#123; int j = i - 1; int temp = a[i]; // 先取出待插入数据保存，因为向后移位过程中会把覆盖掉待插入数 while (j &gt;= 0 &amp;&amp; a[j] &gt; temp) &#123; // 如果待是比待插入数据大，就后移 a[j+1] = a[j]; j--; &#125; a[j+1] = temp; // 找到比待插入数据小的位置，将待插入数据插入 &#125;&#125; 而交换法不需求额外的保存待插入数据，通过不停的向前交换带插入数据，类似冒泡法，直到找到比它小的值，也就是待插入数据找到了自己的位置。②. 交换法： 12345678910111213141516public static void sort2(int[] arr) &#123; if (arr == null || arr.length == 0) &#123; return; &#125; for (int i = 1; i &lt; arr.length; i ++) &#123; int j = i - 1; while (j &gt;= 0 &amp;&amp; arr[j] &gt; arr[i]) &#123; arr[j + 1] = arr[j] + arr[j+1]; //只要大就交换操作 arr[j] = arr[j + 1] - arr[j]; arr[j + 1] = arr[j + 1] - arr[j]; System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr)); &#125; &#125; &#125; 4.4 算法效率直接插入排序不是稳定的排序算法。 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(n2) O(n) O(n2) O(1) 5.希尔排序希尔排序，也称递减增量排序算法，1959年Shell发明。是插入排序的一种高速而稳定的改进版本。 希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 5.1 基本思想将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap&#x3D;1时，利用直接插入，完成排序。 可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是初次取数组长度的一半为增量，之后每次再减半，直到增量为1。更好的步长序列取值可以参考维基百科。 5.2 算法描述①. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；（一般初次取数组半长，之后每次再减半，直到增量为1） ②. 按增量序列个数k，对序列进行k 趟排序； ③. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 在上面这幅图中： 初始时，有一个大小为 10 的无序序列。 在第一趟排序中，我们不妨设 gap1 &#x3D; N &#x2F; 2 &#x3D; 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。 接下来，按照直接插入排序的方法对每个组进行排序。 在第二趟排序中，我们把上次的 gap 缩小一半，即 gap2 &#x3D; gap1 &#x2F; 2 &#x3D; 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为 2 组。 按照直接插入排序的方法对每个组进行排序。 在第三趟排序中，再次把 gap 缩小一半，即gap3 &#x3D; gap2 &#x2F; 2 &#x3D; 1。 这样相隔距离为 1 的元素组成一组，即只有一组。 按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。 需要注意一下的是，图中有两个相等数值的元素 5 和 5 。我们可以清楚的看到，在排序过程中，两个元素位置交换了。 所以，希尔排序是不稳定的算法。 public class ShellSort { 12345678910111213141516public static void sort(int[] arr) &#123; int gap = arr.length / 2; for (;gap &gt; 0; gap = gap/2) &#123; for (int j = 0; (j + gap) &lt; arr.length; j++) &#123; //不断缩小gap，直到1为止 for (int k = 0; (k + gap) &lt; arr.length; k+=gap) &#123; //使用当前gap进行组内插入排序 if (arr[k] &gt; arr[k+gap]) &#123; //交换操作 arr[k] = arr[k] + arr[k+gap]; arr[k+gap] = arr[k] - arr[k+gap]; arr[k] = arr[k] - arr[k+gap]; System.out.println(&quot; Sorting: &quot; + Arrays.toString(arr)); &#125; &#125; &#125; &#125;&#125;&#125; 5.4 算法效率不稳定排序算法，希尔排序第一个突破O(n2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素，直接插入排序是稳定的；而希尔排序是不稳定的，希尔排序的时间复杂度和步长的选择有关，常用的是Shell增量排序，也就是N&#x2F;2的序列，Shell增量序列不是最好的增量序列，其他还有Hibbard增量序列、Sedgewick 增量序列等，具体可以参考，希尔排序增量序列简介。 6.选择排序6.1 基本思想在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。 6.2 算法描述①. 从待排序序列中，找到关键字最小的元素； ②. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换； ③. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。 6.3 代码实现1234567891011121314151617public class SelectSort &#123; public static void sort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; for (int j = i+1; j &lt; arr.length; j ++) &#123; //选出之后待排序中值最小的位置 if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; if (min != i) &#123; arr[min] = arr[i] + arr[min]; arr[i] = arr[min] - arr[i]; arr[min] = arr[min] - arr[i]; &#125; &#125; &#125; 6.4 算法效率不稳定排序算法，选择排序的简单和直观名副其实，这也造就了它出了名的慢性子，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²&#x2F;2次遍历来确认一遍。 唯一值得高兴的是，它并不耗费额外的内存空间。 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(n2) O(n2) O(n2) O(1) 7.归并排序归并排序是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。 7.1 基本思想归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。 7.2 算法描述采用递归法： ①. 将序列每相邻两个数字进行归并操作，形成 floor(n&#x2F;2)个序列，排序后每个序列包含两个元素； ②. 将上述序列再次归并，形成 floor(n&#x2F;4)个序列，每个序列包含四个元素； ③. 重复步骤②，直到所有元素排序完毕 7.3 代码实现123456789101112131415161718192021222324252627282930313233343536373839public class MergeSort &#123; public static int[] sort(int [] a) &#123; if (a.length &lt;= 1) &#123; return a; &#125; int num = a.length &gt;&gt; 1; int[] left = Arrays.copyOfRange(a, 0, num); int[] right = Arrays.copyOfRange(a, num, a.length); return mergeTwoArray(sort(left), sort(right)); &#125; public static int[] mergeTwoArray(int[] a, int[] b) &#123; int i = 0, j = 0, k = 0; int[] result = new int[a.length + b.length]; // 申请额外空间保存归并之后数据 while (i &lt; a.length &amp;&amp; j &lt; b.length) &#123; //选取两个序列中的较小值放入新数组 if (a[i] &lt;= b[j]) &#123; result[k++] = a[i++]; &#125; else &#123; result[k++] = b[j++]; &#125; &#125; while (i &lt; a.length) &#123; //序列a中多余的元素移入新数组 result[k++] = a[i++]; &#125; while (j &lt; b.length) &#123;//序列b中多余的元素移入新数组 result[k++] = b[j++]; &#125; return result; &#125; public static void main(String[] args) &#123; int[] b = &#123;3, 1, 5, 4&#125;; System.out.println(Arrays.toString(sort(b))); &#125;&#125; 7.4 算法效率 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定排序算法，从效率上看，归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n，那么拆分数组共需logn, 又每步都是一个普通的合并子数组的过程，时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为O(n)。 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。 8.基数排序基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 8.1 基本思想将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。 基数排序按照优先从高位或低位来排序有两种实现方案： MSD（Most significant digital） 从最左侧高位开始进行排序。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。MSD方式适用于位数多的序列。 LSD（Least significant digital） 从最右侧低位开始进行排序。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。LSD方式适用于位数少的序列。 下图是LSD基数排序的示意图： 8.2 算法描述以LSD为例，从最低位开始，具体算法描述如下： ①. 取得数组中的最大数，并取得位数； ②. arr为原始数组，从最低位开始取每个位组成radix数组； ③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 8.3 代码实现基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。 分配：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中 收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]。对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.Arrays;/** * Created by zhoujunfu on 2018/9/11. * 基数排序LSD */public class RadixSort &#123; public static void main(String[] args) &#123; int[] array = &#123;10, 20, 5, 4, 100&#125;; sort(array); &#125; public static void sort(int[] a) &#123; if (a == null || a.length &lt; 0) &#123; return; &#125; int max = a[0]; for (int i = 0; i &lt;a.length; i++) &#123; if (a[i] &gt; max) &#123; max = a[i]; &#125; &#125; System.out.println(&quot;max, &quot; + max); int maxDigit = 0; while (max != 0) &#123; max = max / 10; maxDigit++; &#125; System.out.println(&quot;maxDigit, &quot; + maxDigit); int[][] buckets = new int[10][a.length]; int base = 10; //从低位到高位，对每一位遍历，将所有元素分配到桶中 for (int i = 0; i &lt; maxDigit; i++) &#123; int[] bucketLen = new int[10]; //存储各个桶中存储元素的数量 //收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞 for (int j = 0; j &lt; a.length; j++) &#123; int whichBucket = (a[j] % base) / (base / 10); buckets[whichBucket][bucketLen[whichBucket]] = a[j]; bucketLen[whichBucket]++; &#125; int k = 0; //收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞 for (int l = 0; l &lt; buckets.length; l++) &#123; for (int m =0; m &lt; bucketLen[l]; m++) &#123; a[k++] = buckets[l][m]; &#125; &#125; System.out.println(&quot;Sorting: &quot; + Arrays.toString(a)); base *= 10; &#125; &#125;&#125; 8.4 算法效率基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法，以下是基数排序算法复杂度： 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(d*(n+r)) O(d*(n+r)) O(d*(n+r)) O(n+r) 其中，d 为位数，r 为基数，n 为原数组个数。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 O(d*(n + r))。 基数排序更适合用于对时间, 字符串等这些整体权值未知的数据进行排序，适用于。 (1)数据范围较小，建议在小于1000 (2)每个数值都要大于等于0 基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶 计数排序：每个桶只存储单一键值 桶排序：每个桶存储一定范围的数值 计数排序和桶排序在这篇文章里具体就不写了，有需要的可以自行百度。 9.堆排序看堆排序之前先介绍一下面几个概念： 完全二叉树： 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树，很好理解如下图所示。 堆： 堆是具有以下性质的完全二叉树，每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图： 同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子： 该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是： 大顶堆：arr[i] &gt;&#x3D; arr[2i+1] &amp;&amp; arr[i] &gt;&#x3D; arr[2i+2] 小顶堆：arr[i] &lt;&#x3D; arr[2i+1] &amp;&amp; arr[i] &lt;&#x3D; arr[2i+2] ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤： 9.1 基本思想堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。 9.2 算法描述步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。 1.假设给定无序序列结构如下 2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length&#x2F;2-1&#x3D;5&#x2F;2-1&#x3D;1，也就是下面的6结点），从左至右，从下至上进行调整。 3.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6 此时，我们就将一个无需序列构造成了一个大根堆。 步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。 b.重新调整结构，使其继续满足堆定义 c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8. 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序 再简单总结下堆排序的基本思路： a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆; b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端; c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 9.3 算法实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.Arrays;public class HeapSort &#123; public static void main(String []args)&#123; int []arr = &#123;4,6,8,5,9&#125;; sort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void sort(int []arr)&#123; //1.构建大顶堆 for(int i=arr.length/2-1;i&gt;=0;i--)&#123; //从第一个非叶子结点从下至上，从右至左调整结构 adjustHeap(arr,i,arr.length); &#125; //2.调整堆结构+交换堆顶元素与末尾元素 for(int j=arr.length-1;j&gt;0;j--)&#123; swap(arr,0,j);//将堆顶元素与末尾元素进行交换 adjustHeap(arr,0,j);//重新对堆进行调整 &#125; &#125; /** * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上） * @param arr * @param i * @param length */ public static void adjustHeap(int []arr,int i,int length)&#123; int temp = arr[i];//先取出当前元素i for(int k=i*2+1;k&lt;length;k=k*2+1)&#123;//从i结点的左子结点开始，也就是2i+1处开始 if(k+1&lt;length &amp;&amp; arr[k]&lt;arr[k+1])&#123;//如果左子结点小于右子结点，k指向右子结点 k++; &#125; if(arr[k] &gt;temp)&#123;//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换） arr[i] = arr[k]; i = k; &#125;else&#123; break; &#125; &#125; arr[i] = temp;//将temp值放到最终的位置 &#125; /** * 交换元素 * @param arr * @param a * @param b */ public static void swap(int []arr,int a ,int b)&#123; int temp=arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125;&#125; 9.4 算法效率由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列。同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序。 ①. 建立堆的过程, 从length&#x2F;2 一直处理到0, 时间复杂度为O(n); ②. 调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn); ③. 堆排序的过程由n次第②步完成, 时间复杂度为O(nlgn). 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(nlogn) O(nlogn) O(nlogn) O(1) 从时间复杂度来说： (1). 平方阶O(n²)排序：各类简单排序：直接插入、直接选择和冒泡排序； (2). 线性对数阶O(nlog₂n)排序：快速排序、堆排序和归并排序； (3). O(n1+§))排序，§是介于0和1之间的常数：希尔排序 (4). 线性阶O(n)排序：基数排序，此外还有桶、箱排序。 时间复杂度极限： 当被排序的数有一些性质的时候（比如是整数，比如有一定的范围），排序算法的复杂度是可以小于O(nlgn)的。比如： 计数排序 复杂度O( k+n) 要求：被排序的数是0~k范围内的整数 基数排序 复杂度O( d(k+n) ) 要求：d位数，每个数位有k个取值 桶排序 复杂度 O( n ) （平均） 要求：被排序数在某个范围内，并且服从均匀分布 但是，当被排序的数不具有任何性质的时候，一般使用基于比较的排序算法，而基于比较的排序算法时间复杂度的下限必须是O( nlgn) 。参考很多高效排序算法的代价是 nlogn，难道这是排序算法的极限了吗？ 说明 当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）； 而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）； 原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。 11.参考资料 八大排序算法总结与java实现 图解排序算法(三)之堆排序","link":"","tags":[{"name":"java","slug":"java","permalink":"https://lyroom.github.io/tags/java/"},{"name":"排序算法","slug":"排序算法","permalink":"https://lyroom.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"VMware+Centos静态ip配置","date":"2020-07-15T06:27:55.000Z","path":"2020/07/15/VMware-Centos静态ip配置/","text":"前提是你的Centos7安装时，网络适配器选择的是Net模式 第一步：VMware开启后，我们点击头部菜单中的“编辑”，在下拉菜单中点击“虚拟网络编辑器(N)…”，然后点击更改设置，如下图所示 第二步：点击上图的”更改设置”之后，我们会看到如下图所示的界面，我们先点击VMnet8那一行，然后把下面“使用本地DHCP服务将IP地址分配给虚拟机(D)”前面的勾选状态变为未勾选状态。初始状态VMnet8的子网IP不是这个地址的，我们参考VMnet1的IP，也以192.168开头，至于第三个，这里我使用的是98，第四个则是0（注意：下图的配置刚开始是最好是初始配置，如果你曾经乱配过，可能会有问题，如果想要恢复到初始化配置，则点击”还原默认设置(R)”按钮来恢复初始化的配置，然后重新开始），然后我们点击”NAT 设置 我们点击上图的“NAT 设置(S)…”按钮后，会弹出如下图所示的界面，我们把网关IP(G)修改为”192.168.98.2“，这个IP在后面的配置中会用到。记下这个IP后，点击“确定”按钮关闭当前界面，然后点击上图的“确定”按钮关闭父界面。 第三步：启动CentOS7虚拟机，启动后，我们需要修改一个文件，（管理员模式下）输入 1vim /etc/sysconfig/network-scripts/ifcfg-ens33 回车进入网卡信息编辑，如下图 最后输入 1ystemctl restart network.service 回车，保存，ping一下百度试试 大功告成！！！","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://lyroom.github.io/tags/Linux/"},{"name":"VMware","slug":"VMware","permalink":"https://lyroom.github.io/tags/VMware/"}]}]