<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Henry&#39;Blog</title>
  
  <subtitle>宇宙很大，生活更大</subtitle>
  <link href="https://lyroom.github.io/atom.xml" rel="self"/>
  
  <link href="https://lyroom.github.io/"/>
  <updated>2025-09-26T08:19:24.000Z</updated>
  <id>https://lyroom.github.io/</id>
  
  <author>
    <name>迪丽惹Bug</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++朝花夕拾-模板详解</title>
    <link href="https://lyroom.github.io/2025/09/26/C-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%E6%A8%A1%E6%9D%BF%E8%AF%A6%E8%A7%A3/"/>
    <id>https://lyroom.github.io/2025/09/26/C-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%E6%A8%A1%E6%9D%BF%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-09-26T08:19:24.000Z</published>
    <updated>2025-09-26T08:19:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板详解"><a href="#模板详解" class="headerlink" title="模板详解"></a>模板详解</h1><h2 id="模板基础"><a href="#模板基础" class="headerlink" title="模板基础"></a>模板基础</h2><p>C++ 模板（Templates）是现代 C++ 中强大而灵活的特性，支持泛型编程，使得代码更具复用性和类型安全性。模板不仅包括基本的函数模板和类模板，还涵盖了模板特化（全特化与偏特化）、模板参数种类、变参模板（Variadic Templates）、模板元编程（Template Metaprogramming）、SFINAE（Substitution Failure Is Not An Error）等高级内容。</p><span id="more"></span><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>函数模板允许编写通用的函数，通过类型参数化，使其能够处理不同的数据类型。它通过模板参数定义与类型无关的函数。</p><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">functionName</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例：最大值函数"><a href="#示例：最大值函数" class="headerlink" title="示例：最大值函数"></a>示例：最大值函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">maxValue</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">maxValue</span>(<span class="number">3</span>, <span class="number">7</span>) &lt;&lt; std::endl;         <span class="comment">// int 类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">maxValue</span>(<span class="number">3.14</span>, <span class="number">2.72</span>) &lt;&lt; std::endl;  <span class="comment">// double 类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">maxValue</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;z&#x27;</span>) &lt;&lt; std::endl;    <span class="comment">// char 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">3.14</span><br><span class="line">z</span><br></pre></td></tr></table></figure><h4 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h4><ul><li>模板参数列表以 <code>template &lt;typename T&gt;</code> 或 <code>template &lt;class T&gt;</code> 开头，两者等价。</li><li>类型推导：编译器根据函数参数自动推导模板参数类型。</li></ul><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板允许定义通用的类，通过类型参数化，实现不同类型的对象。</p><h4 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T memberVariable;</span><br><span class="line">    <span class="comment">// 构造函数、成员函数等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="示例：简单的-Pair-类"><a href="#示例：简单的-Pair-类" class="headerlink" title="示例：简单的 Pair 类"></a>示例：简单的 Pair 类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T first;</span><br><span class="line">    U second;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Pair</span>(T a, U b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pair: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">print</span>(); <span class="comment">// 输出：Pair: 1, 2.5</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Pair&lt;std::string, std::string&gt; <span class="title">p2</span><span class="params">(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">    p2.<span class="built_in">print</span>(); <span class="comment">// 输出：Pair: Hello, World</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Pair&lt;std::string, <span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="string">&quot;Age&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    p3.<span class="built_in">print</span>(); <span class="comment">// 输出：Pair: Age, 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a><strong>输出：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair: 1, 2.5</span><br><span class="line">Pair: Hello, World</span><br><span class="line">Pair: Age, 30</span><br></pre></td></tr></table></figure><h4 id="要点：-1"><a href="#要点：-1" class="headerlink" title="要点："></a>要点：</h4><ul><li>类模板可以有多个类型参数。</li><li>模板参数可以被用于成员变量和成员函数中。</li><li>类模板实例化时指定具体类型，如 <code>Pair&lt;int, double&gt;</code>。</li></ul><h2 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h2><p>模板参数决定了模板的泛用性与灵活性。C++ 模板参数种类主要包括类型参数、非类型参数和模板模板参数。</p><h3 id="类型参数（Type-Parameters）"><a href="#类型参数（Type-Parameters）" class="headerlink" title="类型参数（Type Parameters）"></a>类型参数（Type Parameters）</h3><p>类型参数用于表示任意类型，在模板实例化时被具体的类型替代。</p><h3 id="非类型参数（Non-Type-Parameters）"><a href="#非类型参数（Non-Type-Parameters）" class="headerlink" title="非类型参数（Non-Type Parameters）"></a>非类型参数（Non-Type Parameters）</h3><p>非类型参数允许模板接受非类型的值，如整数、指针或引用。C++17 支持更多非类型参数类型，如 auto。</p><h4 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> Size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="示例：固定大小的数组类"><a href="#示例：固定大小的数组类" class="headerlink" title="示例：固定大小的数组类"></a>示例：固定大小的数组类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) &#123; <span class="keyword">return</span> data[index]; &#125;</span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span> &#123; <span class="keyword">return</span> data[index]; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            data[i] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Array&lt;<span class="type">int</span>, <span class="number">5</span>&gt; arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 10 20 30 40 </span><br></pre></td></tr></table></figure><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul><li>非类型参数必须是编译期常量。</li><li>允许的类型包括整型、枚举、指针、引用等，但不包括浮点数和类类型。</li></ul><h3 id="模板模板参数（Template-Template-Parameters）"><a href="#模板模板参数（Template-Template-Parameters）" class="headerlink" title="模板模板参数（Template Template Parameters）"></a>模板模板参数（Template Template Parameters）</h3><p>模板模板参数允许模板接受另一个模板作为参数。这对于抽象容器和策略模式等场景非常有用。</p><h4 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="示例：容器适配器"><a href="#示例：容器适配器" class="headerlink" title="示例：容器适配器"></a>示例：容器适配器</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;<span class="type">int</span>&gt; elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; elements.<span class="built_in">push_back</span>(value); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; elements.<span class="built_in">pop_back</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> elements.<span class="built_in">back</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack&lt;std::vector&gt; stack1;</span><br><span class="line">    Stack&lt;std::deque&gt; stack2;</span><br><span class="line">    </span><br><span class="line">    stack1.<span class="built_in">push</span>(<span class="number">1</span>); stack1.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    stack2.<span class="built_in">push</span>(<span class="number">3</span>); stack2.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; stack1.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; stack2.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 4</span><br></pre></td></tr></table></figure><h4 id="要点：-2"><a href="#要点：-2" class="headerlink" title="要点："></a>要点：</h4><ul><li>模板模板参数需要完全匹配被接受模板的参数列表。</li><li>可通过默认模板参数增强灵活性。</li></ul><h2 id="模板特化（Template-Specialization）"><a href="#模板特化（Template-Specialization）" class="headerlink" title="模板特化（Template Specialization）"></a>模板特化（Template Specialization）</h2><p>模板特化允许开发者为特定类型或类型组合提供专门的实现。当通用模板无法满足特定需求时，特化模板可以调整行为以处理特定的情况。C++ 支持全特化（Full Specialization）<em>和</em>偏特化（Partial Specialization），但需要注意的是，函数模板不支持偏特化，只能进行全特化。</p><h3 id="全特化（Full-Specialization）"><a href="#全特化（Full-Specialization）" class="headerlink" title="全特化（Full Specialization）"></a>全特化（Full Specialization）</h3><p>全特化是针对模板参数的完全特定类型组合。它提供了模板的一个特定版本，当模板参数完全匹配特化类型时，编译器将优先使用该特化版本。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&lt;SpecificType&gt; &#123;</span><br><span class="line">    <span class="comment">// 特化实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="示例：类模板全特化"><a href="#示例：类模板全特化" class="headerlink" title="示例：类模板全特化"></a>示例：类模板全特化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;General Printer: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>&lt;std::string&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String Printer: \&quot;&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Printer&lt;<span class="type">int</span>&gt; intPrinter;</span><br><span class="line">    Printer&lt;std::string&gt; stringPrinter;</span><br><span class="line">    </span><br><span class="line">    intPrinter.<span class="built_in">print</span>(<span class="number">42</span>);</span><br><span class="line">    stringPrinter.<span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">General Printer: 42</span><br><span class="line">String Printer: &quot;Hello World&quot;</span><br></pre></td></tr></table></figure><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ul><li>通用模板适用于所有类型，在print函数中以通用方式输出值。</li><li>全特化模板针对std::string类型进行了专门化，实现了不同的print函数。</li><li>当实例化<code>Printer&lt;std::string&gt;</code>时，编译器选择全特化版本而非通用模板。</li></ul><h3 id="偏特化（Partial-Specialization）"><a href="#偏特化（Partial-Specialization）" class="headerlink" title="偏特化（Partial Specialization）"></a>偏特化（Partial Specialization）</h3><p>偏特化允许模板对部分参数进行特定类型的处理，同时保持其他参数的通用性。对于类模板而言，可以针对模板参数的某些特性进行偏特化；对于函数模板，则仅支持全特化，不支持偏特化。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&lt;T, U*&gt; &#123;  <span class="comment">// 偏特化：当U是指针类型时</span></span><br><span class="line">    <span class="comment">// 特化实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="示例：类模板偏特化"><a href="#示例：类模板偏特化" class="headerlink" title="示例：类模板偏特化"></a>示例：类模板偏特化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T first;</span><br><span class="line">    U second;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;General Pair: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化版本：当第二个类型是指针时</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T, U*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T first;</span><br><span class="line">    U* second;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pointer Pair: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (second) &#123;</span><br><span class="line">            std::cout &lt;&lt; *second;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;nullptr&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line">    <span class="function">Pair&lt;<span class="type">int</span>, <span class="type">int</span>*&gt; <span class="title">p2</span><span class="params">(<span class="number">20</span>, &amp;value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    p1.<span class="built_in">print</span>();</span><br><span class="line">    p2.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">General Pair: 10, 3.14</span><br><span class="line">Pointer Pair: 20, 100</span><br></pre></td></tr></table></figure><h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><ul><li>通用模板处理非指针类型对。</li><li>偏特化模板处理第二个类型为指针的情况，打印指针指向的值。</li><li>使用偏特化提升了模板的灵活性，使其能够根据部分参数类型进行不同处理。</li></ul><h3 id="函数模板的特化"><a href="#函数模板的特化" class="headerlink" title="函数模板的特化"></a>函数模板的特化</h3><p>与类模板不同，函数模板不支持偏特化，只能进行全特化。当对函数模板进行全特化时，需要显式指定类型。</p><h4 id="示例：函数模板全特化"><a href="#示例：函数模板全特化" class="headerlink" title="示例：函数模板全特化"></a>示例：函数模板全特化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;General value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">printValue</span>&lt;std::string&gt;(<span class="type">const</span> std::string&amp; value) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;String value: \&quot;&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">printValue</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">General value: 42</span><br><span class="line">General value: 3.14</span><br><span class="line">String value: &quot;Hello&quot;</span><br></pre></td></tr></table></figure><h4 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h4><ul><li>通用函数模板适用于所有类型，提供通用的printValue实现。</li><li>全特化函数模板专门处理std::string类型，提供不同的输出格式。</li><li>调用printValue时，编译器根据实参类型选择适当的模板版本。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>优先级</strong>：全特化版本的优先级高于通用模板，因此当特化条件满足时，总是选择特化版本。</li><li><strong>显式指定类型</strong>：函数模板特化需要在调用时显式指定类型，或者确保类型推导可以正确匹配特化版本。</li><li><strong>不支持偏特化</strong>：无法通过偏特化对函数模板进行部分特化，需要通过其他方法（如重载）实现类似功能。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>全特化适用于为具体类型或类型组合提供专门实现，适用于类模板和函数模板。</li><li>偏特化仅适用于类模板，允许针对部分参数进行特定处理，同时保持其他参数的通用性。</li><li>函数模板仅支持全特化，不支持偏特化；类模板支持全特化和偏特化。</li><li>特化模板提升了模板的灵活性和适应性，使其能够根据不同类型需求调整行为。</li></ul><h2 id="变参模板（Variadic-Templates）"><a href="#变参模板（Variadic-Templates）" class="headerlink" title="变参模板（Variadic Templates）"></a>变参模板（Variadic Templates）</h2><p>变参模板允许模板接受可变数量的参数，提供极高的灵活性，是实现诸如 std::tuple、std::variant 等模板库组件的基础。</p><h3 id="定义与语法"><a href="#定义与语法" class="headerlink" title="定义与语法"></a>定义与语法</h3><p>变参模板使用 参数包（Parameter Pack），通过 <code>...</code> 语法来表示。</p><h4 id="语法：-4"><a href="#语法：-4" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionName</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归与展开（Recursion-and-Expansion）"><a href="#递归与展开（Recursion-and-Expansion）" class="headerlink" title="递归与展开（Recursion and Expansion）"></a>递归与展开（Recursion and Expansion）</h3><p>变参模板通常与递归相结合，通过递归地处理参数包，或者使用 折叠表达式（Fold Expressions） 来展开发参数包。</p><h4 id="递归示例：打印所有参数"><a href="#递归示例：打印所有参数" class="headerlink" title="递归示例：打印所有参数"></a>递归示例：打印所有参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T first, Args... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2.5 Hello A </span><br></pre></td></tr></table></figure><h4 id="折叠表达式版本"><a href="#折叠表达式版本" class="headerlink" title="折叠表达式版本"></a>折叠表达式版本</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;  <span class="comment">// C++17 折叠表达式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折叠表达式示例：计算总和"><a href="#折叠表达式示例：计算总和" class="headerlink" title="折叠表达式示例：计算总和"></a>折叠表达式示例：计算总和</h3><p>C++17 引入了折叠表达式，简化了参数包的处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...);  <span class="comment">// 二元右折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><h4 id="示例：日志记录器"><a href="#示例：日志记录器" class="headerlink" title="示例：日志记录器"></a>示例：日志记录器</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[LOG] &quot;</span>;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;User&quot;</span>, <span class="string">&quot; logged in at &quot;</span>, <span class="number">14</span>, <span class="string">&quot;:30&quot;</span>);</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;Error code: &quot;</span>, <span class="number">404</span>, <span class="string">&quot;, Message: &quot;</span>, <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[LOG] User logged in at 14:30</span><br><span class="line">[LOG] Error code: 404, Message: Not Found</span><br></pre></td></tr></table></figure><h3 id="要点：-3"><a href="#要点：-3" class="headerlink" title="要点："></a>要点：</h3><ul><li>变参模板极大地提升了模板的灵活性。</li><li>使用递归或折叠表达式处理参数包。</li><li>常用于实现通用函数、容器类和元编程工具。</li></ul><h2 id="模板折叠（Fold-Expressions）"><a href="#模板折叠（Fold-Expressions）" class="headerlink" title="模板折叠（Fold Expressions）"></a>模板折叠（Fold Expressions）</h2><h3 id="1-折叠表达式的概念与背景"><a href="#1-折叠表达式的概念与背景" class="headerlink" title="1. 折叠表达式的概念与背景"></a>1. 折叠表达式的概念与背景</h3><p>在C++中，可变参数模板允许函数或类模板接受任意数量的模板参数。这在编写灵活且通用的代码时非常有用。然而，处理参数包中的每个参数往往需要递归模板技巧，这样的代码通常复杂且难以维护。</p><p>折叠表达式的引入显著简化了这一过程。它们允许开发者直接对参数包应用操作符，而无需手动展开或递归处理参数。这不仅使代码更加简洁，还提高了可读性和可维护性。</p><p>折叠表达式可分为：</p><ul><li><strong>一元折叠表达式（Unary Fold）</strong>：对参数包中的每个参数应用一个一元操作符。</li><li><strong>二元折叠表达式（Binary Fold）</strong>：对参数包中的每个参数应用一个二元操作符。</li></ul><p>此外，二元折叠表达式可进一步细分为<strong>左折叠（Left Fold）</strong>和<strong>右折叠（Right Fold）</strong>，取决于操作符的结合方向。</p><h3 id="2-一元折叠表达式（Unary-Fold）"><a href="#2-一元折叠表达式（Unary-Fold）" class="headerlink" title="2. 一元折叠表达式（Unary Fold）"></a>2. 一元折叠表达式（Unary Fold）</h3><p>一元折叠表达式用于在参数包的每个参数前或后应用一元操作符。语法形式如下：</p><h4 id="前置一元折叠（Unary-Prefix-Fold）"><a href="#前置一元折叠（Unary-Prefix-Fold）" class="headerlink" title="前置一元折叠（Unary Prefix Fold）"></a>前置一元折叠（Unary Prefix Fold）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(op ... pack)</span><br></pre></td></tr></table></figure><h4 id="后置一元折叠（Unary-Postfix-Fold）"><a href="#后置一元折叠（Unary-Postfix-Fold）" class="headerlink" title="后置一元折叠（Unary Postfix Fold）"></a>后置一元折叠（Unary Postfix Fold）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pack ... op)</span><br></pre></td></tr></table></figure><p>其中，<code>op</code> 是一元操作符，如<code>!</code>（逻辑非）、<code>~</code>（按位取反）等。</p><h4 id="示例1：逻辑非操作"><a href="#示例1：逻辑非操作" class="headerlink" title="示例1：逻辑非操作"></a>示例1：逻辑非操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">allFalse</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (!args &amp;&amp; ...);  <span class="comment">// 一元左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">allFalse</span>(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>) &lt;&lt; std::endl;  <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">allFalse</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>) &lt;&lt; std::endl;   <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-二元折叠表达式（Binary-Fold）"><a href="#3-二元折叠表达式（Binary-Fold）" class="headerlink" title="3. 二元折叠表达式（Binary Fold）"></a>3. 二元折叠表达式（Binary Fold）</h3><p>二元折叠表达式用于在参数包的每个参数之间应用一个二元操作符。它们可以分为二元左折叠（Binary Left Fold）和二元右折叠（Binary Right Fold），取决于操作符的结合方向。</p><h4 id="二元折叠表达式语法"><a href="#二元折叠表达式语法" class="headerlink" title="二元折叠表达式语法"></a>二元折叠表达式语法</h4><p><strong>二元左折叠（Left Fold）</strong>：</p><ul><li><code>(init op ... op pack)</code></li><li>或者简化为：<code>(pack1 op ... op packN)</code></li></ul><p><strong>二元右折叠（Right Fold）</strong>：</p><ul><li><code>(pack1 op ... op init op ...)</code></li><li>或者简化为：<code>(pack1 op ... op packN)</code></li></ul><p>其中，<code>op</code> 是二元操作符，如<code>+</code>、<code>*</code>、<code>&amp;&amp;</code>、<code>||</code>、<code>&lt;&lt;</code> 等。</p><h4 id="左折叠与右折叠的区别"><a href="#左折叠与右折叠的区别" class="headerlink" title="左折叠与右折叠的区别"></a>左折叠与右折叠的区别</h4><ul><li><strong>二元左折叠（Binary Left Fold）</strong>：操作符从左至右结合，等价于 <code>(((a op b) op c) op d)</code>。</li><li><strong>二元右折叠（Binary Right Fold）</strong>：操作符从右至左结合，等价于 <code>(a op (b op (c op d)))</code>。</li></ul><h4 id="示例1：求和（Binary-Left-Fold）"><a href="#示例1：求和（Binary-Left-Fold）" class="headerlink" title="示例1：求和（Binary Left Fold）"></a>示例1：求和（Binary Left Fold）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...);  <span class="comment">// 二元左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;  <span class="comment">// 输出：10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>(args + ...)</code> 是一个二元左折叠表达式。</li><li>它将<code>+</code>操作符逐个应用于参数，按照左折叠顺序。</li><li>即，<code>((1 + 2) + 3) + 4 = 10</code>。</li></ul><h4 id="示例2：乘积（Binary-Right-Fold）"><a href="#示例2：乘积（Binary-Right-Fold）" class="headerlink" title="示例2：乘积（Binary Right Fold）"></a>示例2：乘积（Binary Right Fold）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">product</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (... * args);  <span class="comment">// 二元右折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">product</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;  <span class="comment">// 输出：24</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>(... * args)</code> 是一个二元右折叠表达式。</li><li>它将<code>*</code>操作符逐个应用于参数，按照右折叠顺序。</li><li>即，<code>2 * (3 * 4) = 2 * 12 = 24</code>。</li></ul><h4 id="示例3：逻辑与（Binary-Left-Fold）"><a href="#示例3：逻辑与（Binary-Left-Fold）" class="headerlink" title="示例3：逻辑与（Binary Left Fold）"></a>示例3：逻辑与（Binary Left Fold）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">allTrue</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args &amp;&amp; ...);  <span class="comment">// 二元左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">allTrue</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>) &lt;&lt; std::endl;   <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">allTrue</span>(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>) &lt;&lt; std::endl;  <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>(args &amp;&amp; ...)</code> 是一个二元左折叠表达式。</li><li>用于检查所有参数是否为true。</li><li>类似于链式的逻辑与运算。</li></ul><h3 id="4-左折叠与右折叠（Left-and-Right-Folds）"><a href="#4-左折叠与右折叠（Left-and-Right-Folds）" class="headerlink" title="4. 左折叠与右折叠（Left and Right Folds）"></a>4. 左折叠与右折叠（Left and Right Folds）</h3><p>了解左折叠和右折叠的区别，对于正确选择折叠表达式的形式至关重要。</p><h4 id="二元左折叠（Binary-Left-Fold）"><a href="#二元左折叠（Binary-Left-Fold）" class="headerlink" title="二元左折叠（Binary Left Fold）"></a>二元左折叠（Binary Left Fold）</h4><p><strong>语法：</strong></p><ul><li><code>(args op ...)</code></li></ul><p><strong>展开方式：</strong></p><ul><li><code>((arg1 op arg2) op arg3) op ... op argN</code></li></ul><p><strong>适用场景：</strong></p><ul><li>当操作符是结合性的且从左侧开始累积操作时（如<code>+</code>、<code>*</code>）。</li><li>需要严格的顺序执行时，确保从左到右依次处理参数。</li></ul><p><strong>示例：</strong></p><ul><li><code>(args + ...)</code> &#x2F;&#x2F; 左折叠求和</li></ul><h4 id="二元右折叠（Binary-Right-Fold）"><a href="#二元右折叠（Binary-Right-Fold）" class="headerlink" title="二元右折叠（Binary Right Fold）"></a>二元右折叠（Binary Right Fold）</h4><p><strong>语法：</strong></p><ul><li><code>(... op args)</code></li></ul><p><strong>展开方式：</strong></p><ul><li><code>arg1 op (arg2 op (arg3 op ... op argN))</code></li></ul><p><strong>适用场景：</strong></p><ul><li>当操作符是右结合的，或当需要从右侧开始累积操作时。</li><li>某些特定的逻辑和数据结构可能需要右侧先处理。</li></ul><p><strong>示例：</strong></p><ul><li><code>(... + args)</code> &#x2F;&#x2F; 右折叠求和</li></ul><h3 id="5-op-在折叠表达式中的作用"><a href="#5-op-在折叠表达式中的作用" class="headerlink" title="5. op 在折叠表达式中的作用"></a>5. op 在折叠表达式中的作用</h3><p>在折叠表达式中，<code>op</code> 代表二元操作符，用于定义如何将参数包中的各个参数相互结合。<code>op</code> 可以是任何合法的二元操作符，包括但不限于：</p><ul><li><strong>算术操作符</strong>：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code> 等。</li><li><strong>逻辑操作符</strong>：<code>&amp;&amp;</code>、<code>||</code> 等。</li><li><strong>按位操作符</strong>：<code>&amp;</code>、<code>|</code>、<code>^</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code> 等。</li><li><strong>比较操作符</strong>：<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code> 等。</li><li><strong>自定义操作符</strong>：如果定义了自定义类型并重载了特定的操作符，也可以使用这些操作符。</li></ul><p><code>op</code> 的选择直接影响折叠表达式的行为和结果。选择适当的操作符是实现特定功能的关键。</p><h4 id="示例1：使用加法操作符"><a href="#示例1：使用加法操作符" class="headerlink" title="示例1：使用加法操作符"></a>示例1：使用加法操作符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例2：使用逻辑与操作符"><a href="#示例2：使用逻辑与操作符" class="headerlink" title="示例2：使用逻辑与操作符"></a>示例2：使用逻辑与操作符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">all</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args &amp;&amp; ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例3：使用左移操作符（流插入）"><a href="#示例3：使用左移操作符（流插入）" class="headerlink" title="示例3：使用左移操作符（流插入）"></a>示例3：使用左移操作符（流插入）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>在上述示例中，<code>op</code> 分别为 <code>+</code>、<code>&amp;&amp;</code>、<code>&lt;&lt;</code>。</li><li>每个操作符定义了如何将参数包中的元素相互结合。</li></ul><h4 id="示例4：使用自定义操作符"><a href="#示例4：使用自定义操作符" class="headerlink" title="示例4：使用自定义操作符"></a>示例4：使用自定义操作符</h4><p>假设有一个自定义类型<code>Point</code>，并重载了<code>+</code>操作符以支持点的相加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x + other.x, y + other.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Point&amp; p) &#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sumPoints</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">p2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span>, <span class="title">p3</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    Point result = <span class="built_in">sumPoints</span>(p1, p2, p3);</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;  <span class="comment">// 输出：(9, 12)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>通过重载<code>+</code>操作符，<code>sumPoints</code>函数能够将多个<code>Point</code>对象相加，得到累积的结果。</li></ul><h3 id="6-示例代码与应用"><a href="#6-示例代码与应用" class="headerlink" title="6. 示例代码与应用"></a>6. 示例代码与应用</h3><p>为了全面理解折叠表达式的应用，以下提供多个具体示例，涵盖不同类型的折叠表达式。</p><h4 id="示例1：字符串拼接"><a href="#示例1：字符串拼接" class="headerlink" title="示例1：字符串拼接"></a>示例1：字符串拼接</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">std::string <span class="title">concatenate</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (std::string&#123;&#125; + ... + args);  <span class="comment">// 二元左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string result = <span class="built_in">concatenate</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;  <span class="comment">// 输出：Hello World!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例2：计算逻辑与"><a href="#示例2：计算逻辑与" class="headerlink" title="示例2：计算逻辑与"></a>示例2：计算逻辑与</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">all</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args &amp;&amp; ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">all</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>) &lt;&lt; std::endl;    <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">all</span>(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>) &lt;&lt; std::endl;   <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例3：计算最大值"><a href="#示例3：计算最大值" class="headerlink" title="示例3：计算最大值"></a>示例3：计算最大值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T <span class="title">maxValue</span><span class="params">(T first, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(args) == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T restMax = <span class="built_in">maxValue</span>(args...);</span><br><span class="line">        <span class="keyword">return</span> (first &gt; restMax) ? first : restMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">maxValue</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>) &lt;&lt; std::endl;  <span class="comment">// 输出：9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 上述示例中的<code>(std::max)(first, ... , args)</code>是一个非标准用法，需要根据具体情况调整。通常，<code>std::max</code>不支持直接的折叠表达式，因此此例更适合作为概念性说明。在实际应用中，可以使用<code>std::initializer_list</code>或其他方法实现多参数的最大值计算。</p><h4 id="示例4：筛选逻辑"><a href="#示例4：筛选逻辑" class="headerlink" title="示例4：筛选逻辑"></a>示例4：筛选逻辑</h4><p>假设需要检查多个条件是否满足，且每个条件之间使用逻辑或操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Conditions&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">anyCondition</span><span class="params">(Conditions... conds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (conds || ...);  <span class="comment">// 二元左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> a = <span class="literal">false</span>, b = <span class="literal">true</span>, c = <span class="literal">false</span>;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">anyCondition</span>(a, b, c) &lt;&lt; std::endl;  <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-注意事项与最佳实践"><a href="#7-注意事项与最佳实践" class="headerlink" title="7. 注意事项与最佳实践"></a>7. 注意事项与最佳实践</h3><ol><li><p><strong>操作符的选择</strong><br>选择合适的操作符（<code>op</code>）对于实现正确的折叠行为至关重要。确保所选的操作符符合所需的逻辑和计算需求。</p></li><li><p><strong>操作符的结合性</strong><br>不同的操作符具有不同的结合性（左结合、右结合）。了解操作符的结合性有助于选择正确的折叠方向（左折叠或右折叠）。</p></li><li><p><strong>参数包的初始化</strong><br>在二元折叠表达式中，有时需要一个初始值（<code>init</code>）。这主要用于确保折叠的正确性，尤其在参数包可能为空的情况下。</p></li></ol><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sumWithInit</span><span class="params">(<span class="type">int</span> init, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (init + ... + args);  <span class="comment">// 带初始值的左折叠</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>参数包为空的情况</strong><br>如果参数包为空，折叠表达式的结果取决于折叠的类型和初始值。合理设置初始值可以避免潜在的错误。</li></ol><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">safeSum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> + ... + args);  <span class="comment">// 空包时返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p><strong>与递归模板的比较</strong><br>折叠表达式在处理可变参数模板时，比传统的递归模板方法更简洁、易读且易于维护。然而，理解折叠表达式的基本原理和语法对于充分利用其优势至关重要。</p></li><li><p><strong>编译器支持</strong><br>确保所使用的编译器支持C++17或更高标准，因为折叠表达式是在C++17中引入的。常见的支持C++17的编译器包括：</p><ul><li><strong>GCC</strong>：从版本7开始支持C++17，其中完整支持在后续版本中得到增强。</li><li><strong>Clang</strong>：从版本5开始支持C++17。</li><li><strong>MSVC（Visual Studio）</strong>：从Visual Studio 2017版本15.7开始提供较全面的C++17支持。</li></ul></li><li><p><strong>性能考虑</strong><br>折叠表达式本身并不引入额外的性能开销。它们是在编译时展开的，生成的代码与手动展开参数包时的代码几乎相同。然而，编写高效的折叠表达式仍然需要理解所应用操作符的性能特性。</p></li></ol><h2 id="SFINAE（Substitution-Failure-Is-Not-An-Error）"><a href="#SFINAE（Substitution-Failure-Is-Not-An-Error）" class="headerlink" title="SFINAE（Substitution Failure Is Not An Error）"></a>SFINAE（Substitution Failure Is Not An Error）</h2><h3 id="一、什么是SFINAE？"><a href="#一、什么是SFINAE？" class="headerlink" title="一、什么是SFINAE？"></a>一、什么是SFINAE？</h3><p>SFINAE 是 “Substitution Failure Is Not An Error”（替换失败不是错误）的缩写，是C++模板编程中的一个重要概念。它允许编译器在模板实例化过程中，如果在替换模板参数时失败（即不满足某些条件），不会将其视为编译错误，而是继续寻找其他可能的模板或重载。这一机制为条件编译、类型特性检测、函数重载等提供了强大的支持。</p><h3 id="二、SFINAE的工作原理"><a href="#二、SFINAE的工作原理" class="headerlink" title="二、SFINAE的工作原理"></a>二、SFINAE的工作原理</h3><p>在模板实例化过程中，编译器会尝试将模板参数替换为具体类型。如果在替换过程中出现不合法的表达式或类型，编译器不会报错，而是将该模板视为不可行的，继续尝试其他模板或重载。这一特性允许开发者根据类型特性选择不同的模板实现。</p><h3 id="三、SFINAE的应用场景"><a href="#三、SFINAE的应用场景" class="headerlink" title="三、SFINAE的应用场景"></a>三、SFINAE的应用场景</h3><ol><li><strong>函数重载选择</strong>：根据参数类型的不同选择不同的函数实现。</li><li><strong>类型特性检测</strong>：检测类型是否具有某些成员或特性，从而决定是否启用某些功能。</li><li><strong>条件编译</strong>：根据模板参数的特性决定是否编译某些代码段。</li></ol><h3 id="四、SFINAE的基本用法"><a href="#四、SFINAE的基本用法" class="headerlink" title="四、SFINAE的基本用法"></a>四、SFINAE的基本用法</h3><p>SFINAE通常与<code>std::enable_if</code>、模板特化、以及类型萃取等技术结合使用。以下通过几个例子来说明SFINAE的应用。</p><h4 id="示例一：通过std-enable-if实现函数重载"><a href="#示例一：通过std-enable-if实现函数重载" class="headerlink" title="示例一：通过std::enable_if实现函数重载"></a>示例一：通过<code>std::enable_if</code>实现函数重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing integral: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, T&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing floating point: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(<span class="number">42</span>);      <span class="comment">// 调用整数版本</span></span><br><span class="line">    <span class="built_in">process</span>(<span class="number">3.14</span>);    <span class="comment">// 调用浮点数版本</span></span><br><span class="line">    <span class="comment">// process(&quot;hello&quot;); // 编译错误：没有匹配的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>std::enable_if</code> 根据条件 <code>std::is_integral&lt;T&gt;::value</code> 或 <code>std::is_floating_point&lt;T&gt;::value</code> 决定是否启用对应的函数模板。</li><li>当条件不满足时，该模板实例化失败，但由于SFINAE规则，编译器不会报错，而是忽略该模板，从而实现函数重载选择。</li></ul><h4 id="示例二：检测类型是否具有特定成员"><a href="#示例二：检测类型是否具有特定成员" class="headerlink" title="示例二：检测类型是否具有特定成员"></a>示例二：检测类型是否具有特定成员</h4><p>假设我们需要实现一个函数，仅当类型 T 具有成员函数 <code>foo</code> 时才启用该函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测类型T是否有foo成员函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">has_foo</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">test</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">decltype</span><span class="params">(std::declval&lt;U&gt;().foo(), std::true_type&#123;&#125;)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::false_type <span class="title">test</span><span class="params">(...)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="keyword">decltype</span>(<span class="built_in">test</span>&lt;T&gt;(<span class="number">0</span>))::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅当T有foo成员时才启用的函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;has_foo&lt;T&gt;::value&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">call_foo</span><span class="params">(T&amp; obj)</span> </span>&#123;</span><br><span class="line">    obj.<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithFoo</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;WithFoo::foo() called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithoutFoo</span> &#123;</span><br><span class="line">    <span class="comment">// 没有foo成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WithFoo wf;</span><br><span class="line">    WithoutFoo wof;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">call_foo</span>(wf);   <span class="comment">// 正常调用</span></span><br><span class="line">    <span class="comment">// call_foo(wof); // 编译错误：没有匹配的函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>has_foo</code> 是一个类型萃取类，用于检测类型 T 是否具有成员函数 <code>foo</code>。</li><li><code>call_foo</code> 函数模板仅在 T 具有 <code>foo</code> 成员时启用。</li><li>对于不具有 <code>foo</code> 成员的类型，编译器会忽略 <code>call_foo</code>，从而避免编译错误。</li></ul><h4 id="示例三：通过模板特化实现不同的行为"><a href="#示例三：通过模板特化实现不同的行为" class="headerlink" title="示例三：通过模板特化实现不同的行为"></a>示例三：通过模板特化实现不同的行为</h4><p>以下是完整的、正确实现 <code>TypePrinter</code> 的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测类型T是否有非void的value_type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> has_non_void_value_type : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_non_void_value_type</span>&lt;T, </span><br><span class="line">    std::<span class="type">void_t</span>&lt;<span class="keyword">typename</span> T::value_type&gt;&gt; : </span><br><span class="line">    std::negation&lt;std::is_void&lt;<span class="keyword">typename</span> T::value_type&gt;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">bool</span> HasValueType = has_non_void_value_type&lt;T&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> TypePrinter &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="built_in">print</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Type without value_type or value_type is void&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化版本：当T有非void的value_type时</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypePrinter</span>&lt;T, <span class="literal">true</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Type with value_type: &quot;</span> </span><br><span class="line">                  &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">typename</span> T::value_type).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithValueType</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithoutValueType</span> &#123;</span><br><span class="line">    <span class="comment">// 没有value_type</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithVoidValueType</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="type">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TypePrinter&lt;WithValueType&gt;::<span class="built_in">print</span>();      <span class="comment">// 有value_type</span></span><br><span class="line">    TypePrinter&lt;WithoutValueType&gt;::<span class="built_in">print</span>();   <span class="comment">// 没有value_type</span></span><br><span class="line">    TypePrinter&lt;WithVoidValueType&gt;::<span class="built_in">print</span>();  <span class="comment">// value_type是void</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释</strong></p><ol><li><p><strong>Trait <code>has_non_void_value_type</code></strong>:</p><ul><li>主模板：默认情况下，<code>has_non_void_value_type&lt;T&gt;</code> 继承自 <code>std::false_type</code>，表示 T 没有 <code>value_type</code> 或 <code>value_type</code> 是 <code>void</code>。</li><li>特化模板：仅当 T 有 <code>value_type</code> 且 <code>value_type</code> 不是 <code>void</code> 时，<code>has_non_void_value_type&lt;T&gt;</code> 继承自 <code>std::true_type</code>。</li></ul></li><li><p><strong><code>TypePrinter</code> 模板</strong>:</p><ul><li>主模板：接受一个类型 T 和一个布尔模板参数 <code>HasValueType</code>，默认为 <code>has_non_void_value_type&lt;T&gt;::value</code>。</li><li>特化版本 <code>TypePrinter&lt;T, true&gt;</code>：当 <code>HasValueType</code> 为 true 时，表示 T 有非 void 的 <code>value_type</code>，提供相应的 <code>print</code> 实现。</li><li>特化版本 <code>TypePrinter&lt;T, false&gt;</code>：当 <code>HasValueType</code> 为 false 时，表示 T 没有 <code>value_type</code> 或 <code>value_type</code> 是 <code>void</code>，提供默认的 <code>print</code> 实现。</li></ul></li><li><p><strong>测试结构体</strong>：</p><ul><li><code>WithValueType</code>：有一个非 void 的 <code>value_type</code>。</li><li><code>WithoutValueType</code>：没有 <code>value_type</code>。</li><li><code>WithVoidValueType</code>：有一个 <code>value_type</code>，但它是 <code>void</code>。</li></ul></li><li><p><strong>main 函数</strong>：</p><ul><li>分别测试了三种情况，验证 <code>TypePrinter</code> 的行为是否符合预期。</li></ul></li></ol><h3 id="五、SFINAE的优缺点"><a href="#五、SFINAE的优缺点" class="headerlink" title="五、SFINAE的优缺点"></a>五、SFINAE的优缺点</h3><p><strong>优点：</strong></p><ol><li><strong>灵活性高</strong>：能够根据类型特性选择不同的实现，提升代码的泛化能力。</li><li><strong>类型安全</strong>：通过编译期检测，避免了运行时错误。</li><li><strong>无需额外的运行时开销</strong>：所有的类型筛选都在编译期完成。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>复杂性高</strong>：SFINAE相关的代码往往较为复杂，阅读和维护难度较大。</li><li><strong>编译器错误信息难以理解</strong>：SFINAE失败时，编译器可能给出晦涩的错误信息，调试困难。</li><li><strong>模板实例化深度限制</strong>：过度使用SFINAE可能导致编译时间增加和模板实例化深度限制问题。</li></ol><h3 id="六、现代C-中的替代方案"><a href="#六、现代C-中的替代方案" class="headerlink" title="六、现代C++中的替代方案"></a>六、现代C++中的替代方案</h3><p>随着C++11及后续标准的发展，引入了诸如<code>decltype</code>、<code>constexpr</code>、<code>if constexpr</code>、概念（C++20）等新的特性，部分情况下可以替代传统的SFINAE，提高代码的可读性和可维护性。例如，C++20引入的概念（Concepts）提供了更为简洁和直观的方式来约束模板参数，减少了SFINAE的复杂性。</p><h4 id="示例：使用概念替代SFINAE"><a href="#示例：使用概念替代SFINAE" class="headerlink" title="示例：使用概念替代SFINAE"></a>示例：使用概念替代SFINAE</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Integral = std::is_integral_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;Integral T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing integral: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> std::floating_point&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing floating point: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(<span class="number">42</span>);      <span class="comment">// 调用整数版本</span></span><br><span class="line">    <span class="built_in">process</span>(<span class="number">3.14</span>);    <span class="comment">// 调用浮点数版本</span></span><br><span class="line">    <span class="comment">// process(&quot;hello&quot;); // 编译错误：没有匹配的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>使用概念<code>Integral</code>代替<code>std::enable_if</code>，语法更简洁，代码更易读。</li><li>当类型不满足概念时，编译器会给出明确的错误信息，便于调试。</li></ul><p>虽然上述方法经典且有效，但在C++11及以后版本，存在更简洁和易读的方式来实现相同的功能。例如，使用<code>std::void_t</code>和更现代的检测技巧，或者直接使用C++20的概念（Concepts），使代码更加清晰。</p><h4 id="示例：使用std-void-t简化has-foo"><a href="#示例：使用std-void-t简化has-foo" class="headerlink" title="示例：使用std::void_t简化has_foo"></a>示例：使用<code>std::void_t</code>简化<code>has_foo</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> has_foo : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_foo</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">foo</span>())&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;has_foo&lt;T&gt;::value&gt; <span class="built_in">call_foo</span>(T&amp; obj) &#123;</span><br><span class="line">    obj.<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithFoo</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;WithFoo::foo() called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WithFoo wf;</span><br><span class="line">    <span class="built_in">call_foo</span>(wf);  <span class="comment">// 正常调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>利用<code>std::void_t</code>，<code>has_foo</code>结构更为简洁。</li><li><code>decltype(std::declval&lt;T&gt;().foo())</code>尝试在不实例化T对象的情况下检测<code>foo()</code>成员函数。</li><li>如果<code>foo()</code>存在，<code>has_foo&lt;T&gt;</code>继承自<code>std::true_type</code>，否则继承自<code>std::false_type</code>。</li></ul><h4 id="使用C-20概念"><a href="#使用C-20概念" class="headerlink" title="使用C++20概念"></a>使用C++20概念</h4><p>如果你使用的是支持C++20的编译器，可以利用概念（Concepts）进一步简化和增强可读性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> HasFoo = <span class="built_in">requires</span>(T t) &#123;</span><br><span class="line">    t.<span class="built_in">foo</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;HasFoo T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_foo</span><span class="params">(T&amp; obj)</span> </span>&#123;</span><br><span class="line">    obj.<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithFoo</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;WithFoo::foo() called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WithFoo wf;</span><br><span class="line">    <span class="built_in">call_foo</span>(wf);  <span class="comment">// 正常调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>HasFoo</code>概念：使用<code>requires</code>表达式检测类型T是否具有<code>void foo()</code>成员函数。</li><li><code>call_foo</code>函数模板：仅当T满足<code>HasFoo</code>概念时，模板被启用。</li><li>这种方式更直观，易于理解和维护。</li></ul><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>SFINAE作为C++模板编程中的一项强大功能，通过在模板实例化过程中允许替换失败而不报错，实现了基于类型特性的编程。然而，SFINAE的语法复杂且难以维护，现代C++引入的新特性如概念等在某些情况下已经能够更简洁地实现类似的功能。尽管如此，理解SFINAE的工作机制依然对于掌握高级模板技术和阅读老旧代码具有重要意义。</p><h2 id="综合案例：结合模板特化与折叠表达式"><a href="#综合案例：结合模板特化与折叠表达式" class="headerlink" title="综合案例：结合模板特化与折叠表达式"></a>综合案例：结合模板特化与折叠表达式</h2><p>为了进一步巩固对模板特化和折叠表达式的理解，本节将通过一个综合案例展示如何将两者结合使用。</p><h3 id="案例描述"><a href="#案例描述" class="headerlink" title="案例描述"></a>案例描述</h3><p>实现一个通用的日志记录器<code>Logger</code>，能够处理任意数量和类型的参数，并根据不同的类型组合调整输出格式。具体需求包括：</p><ol><li>对于普通类型，使用通用的打印格式。</li><li>对于指针类型，打印指针地址或指向的值。</li><li>对于<code>std::string</code>类型，使用专门的格式。</li><li>支持可变数量的参数，通过折叠表达式实现参数的逐一打印。</li></ol><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li>定义通用类模板<code>Logger</code>，使用模板特化和偏特化处理不同类型。</li><li>实现<code>log</code>函数，使用模板折叠表达式逐一打印参数。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Enable = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Logger &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="built_in">log</span>(<span class="type">const</span> T&amp; value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;General Logger: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型的偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>&lt;T*, <span class="type">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(T* value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Pointer Logger: &quot;</span> &lt;&lt; *value &lt;&lt; <span class="string">&quot; (address: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Pointer Logger: nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::string类型的全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>&lt;std::string, <span class="type">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String Logger: \&quot;&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：记录单个值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logOne</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    Logger&lt;T&gt;::<span class="built_in">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用折叠表达式记录所有参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAll</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    (<span class="built_in">logOne</span>(args), ...);  <span class="comment">// C++17 折叠表达式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">3.14</span>;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line">    <span class="type">int</span>* nullPtr = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">logAll</span>(x, y, str, ptr, nullPtr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">General Logger: 42</span><br><span class="line">General Logger: 3.14</span><br><span class="line">String Logger: &quot;Hello World&quot;</span><br><span class="line">Pointer Logger: 42 (address: 0x7ffd...)</span><br><span class="line">Pointer Logger: nullptr</span><br></pre></td></tr></table></figure><h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><ol><li><p>**通用模板<code>Logger&lt;T, Enable&gt;</code>**：</p><ul><li>使用第二个模板参数<code>Enable</code>与SFINAE（Substitution Failure Is Not An Error）结合，控制模板特化。</li><li>对于非指针类型和非<code>std::string</code>类型，使用通用实现，打印”General Logger: value”。</li></ul></li><li><p>**类模板偏特化<code>Logger&lt;T, Enable&gt;</code>**：</p><ul><li>使用<code>std::enable_if</code>和<code>std::is_pointer</code>，当T是指针类型时，特化模板。</li><li>实现指针类型的特殊日志处理，打印指针指向的值或<code>nullptr</code>。</li></ul></li><li><p>**类模板全特化<code>Logger&lt;std::string&gt;</code>**：</p><ul><li>为<code>std::string</code>类型提供全特化版本，使用不同的输出格式。</li></ul></li><li><p><strong><code>logOne</code>函数模板</strong>：</p><ul><li>简化调用过程，调用相应的<code>Logger&lt;T&gt;::log</code>方法。</li></ul></li><li><p><strong><code>logAll</code>函数模板</strong>：</p><ul><li>使用模板折叠表达式<code>(logOne(args), ...)</code>，实现对所有参数的逐一日志记录。</li><li>通过左折叠的逗号表达式，确保每个<code>logOne</code>调用依次执行。</li></ul></li><li><p><strong>main函数</strong>：</p><ul><li>测试不同类型的日志记录，包括普通类型、指针类型和<code>std::string</code>类型。</li><li>调用<code>logAll</code>函数，实现多参数的综合日志记录。</li></ul></li></ol><h2 id="模板元编程（Template-Metaprogramming）"><a href="#模板元编程（Template-Metaprogramming）" class="headerlink" title="模板元编程（Template Metaprogramming）"></a>模板元编程（Template Metaprogramming）</h2><h3 id="什么是模板元编程"><a href="#什么是模板元编程" class="headerlink" title="什么是模板元编程"></a>什么是模板元编程</h3><p>模板元编程（Template Metaprogramming）是一种在编译期通过模板机制进行代码生成和计算的编程技术。它利用编译器的模板实例化机制，在编译期间执行代码逻辑，以提高程序的性能和灵活性。</p><h3 id="模板元编程的优势"><a href="#模板元编程的优势" class="headerlink" title="模板元编程的优势"></a>模板元编程的优势</h3><ul><li>提高代码的可重用性和泛化能力。</li><li>在编译期进行复杂计算，减少运行时开销。</li><li>实现类型安全的高级抽象。</li></ul><h3 id="模板元编程基础"><a href="#模板元编程基础" class="headerlink" title="模板元编程基础"></a>模板元编程基础</h3><ul><li><strong>模板特化（Template Specialization）</strong>：<ul><li>全特化（Full Specialization）：为特定类型提供特定实现。</li><li>偏特化（Partial Specialization）：为部分模板参数特定的情况提供实现。</li></ul></li><li><strong>递归模板（Recursive Templates）</strong>：利用模板的递归实例化机制，实现编译期计算。</li></ul><h3 id="编译期计算"><a href="#编译期计算" class="headerlink" title="编译期计算"></a>编译期计算</h3><p>模板元编程允许在编译时执行计算，如计算阶乘、斐波那契数列等。</p><h4 id="示例：编译期阶乘"><a href="#示例：编译期阶乘" class="headerlink" title="示例：编译期阶乘"></a>示例：编译期阶乘</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化模板：递归终止条件</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Factorial of 5: &quot;</span> &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Factorial of 5: 120</span><br></pre></td></tr></table></figure><p><strong>讲解：</strong></p><ol><li>基本模板<code>Factorial</code>定义了一个静态常量<code>value</code>，其值为<code>N * Factorial&lt;N - 1&gt;::value</code>，实现递归计算。</li><li>特化模板<code>Factorial&lt;0&gt;</code>定义递归终止条件，当N&#x3D;0时，<code>value</code>为1。</li><li>在main函数中，通过<code>Factorial&lt;5&gt;::value</code>获取5的阶乘结果，编译期即生成其值。</li></ol><h3 id="静态成员变量的基本规则"><a href="#静态成员变量的基本规则" class="headerlink" title="静态成员变量的基本规则"></a>静态成员变量的基本规则</h3><p>在 C++ 中，静态成员变量的声明与定义有以下基本规则：</p><ol><li><strong>声明（Declaration）</strong>：在类内部声明静态成员变量，告诉编译器该类包含这个静态成员。</li><li><strong>定义（Definition）</strong>：在类外部对静态成员变量进行定义，分配存储空间。</li></ol><p>通常，对于非 <code>constexpr</code> 或非 <code>inline</code> 的静态成员变量，必须 在类外进行定义，否则会导致链接器错误（undefined reference）。</p><h3 id="特殊情况：static-const-整数成员"><a href="#特殊情况：static-const-整数成员" class="headerlink" title="特殊情况：static const 整数成员"></a>特殊情况：static const 整数成员</h3><p>对于 <code>static const</code>整数类型 的静态成员变量，C++ 标准做了一些特殊的处理：</p><ul><li><strong>类内初始化</strong>：你可以在类内部初始化 <code>static const</code> 整数成员变量，例如 <code>static const int value = 42;</code>。</li><li><strong>使用场景</strong>：<ul><li>不需要类外定义：在某些情况下，编译器在编译阶段可以直接使用类内的初始化值，无需类外定义。</li><li>需要类外定义：如果你在程序中对该静态成员变量进行取址（例如，<code>&amp;Factorial&lt;5&gt;::value</code>），或者在其他需要该变量的存储位置时，就需要在类外进行定义。</li></ul></li></ul><h4 id="C-11-及之前的标准"><a href="#C-11-及之前的标准" class="headerlink" title="C++11 及之前的标准"></a>C++11 及之前的标准</h4><p>在 C++11 及更早的标准中，对于 <code>static const</code> 整数成员变量：</p><ul><li><strong>不需要类外定义的情况</strong>：<ul><li>仅在作为编译期常量使用时，不需要类外定义。例如，用于数组大小、模板参数等。</li></ul></li><li><strong>需要类外定义的情况</strong>：<ul><li>当你需要对变量进行取址，或者在需要其存储位置时，必须在类外定义。例如：</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类内声明</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义（如果需要进行取址操作）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ClassName::value;</span><br></pre></td></tr></table></figure><h4 id="C-17-及更新标准"><a href="#C-17-及更新标准" class="headerlink" title="C++17 及更新标准"></a>C++17 及更新标准</h4><p>从 C++17 开始，引入了 <strong>内联变量（inline variables）</strong>，使得在类内定义静态成员变量变得更加灵活：</p><ul><li><strong>内联静态成员变量</strong>：<ul><li>使用 <code>inline</code> 关键字，可以在类内对静态成员变量进行定义，无需在类外进行单独定义。</li><li>这适用于 C++17 及更高版本。</li></ul></li></ul><p>例如，你可以这样编写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种情况下，无需在类外进行定义，因为 <code>inline</code> 确保了该变量在每个翻译单元中都只有一个实例。</p><h3 id="在-C-11-及之前的标准"><a href="#在-C-11-及之前的标准" class="headerlink" title="在 C++11 及之前的标准"></a>在 C++11 及之前的标准</h3><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要取址，需要在类外定义</span></span><br><span class="line"><span class="comment">// const int Factorial&lt;5&gt;::value;</span></span><br></pre></td></tr></table></figure><ul><li><strong>作为编译期常量使用</strong>：<ul><li>例如，用于其他模板参数或编译期常量计算时，不需要类外定义。</li></ul></li><li><strong>取址或需要存储位置时</strong>：<ul><li>需要在类外进行定义。例如：</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl;  <span class="comment">// 不需要定义</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ptr = &amp;Factorial&lt;<span class="number">5</span>&gt;::value;          <span class="comment">// 需要定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-C-17-及更高标准"><a href="#在-C-17-及更高标准" class="headerlink" title="在 C++17 及更高标准"></a>在 C++17 及更高标准</h3><p>如果你使用 C++17 及更高版本，可以使用 <code>inline</code> 关键字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>无需类外定义</strong>：<ul><li><code>inline</code> 使得在类内的定义成为唯一的定义，即使在多个翻译单元中使用，也不会导致重复定义错误。</li></ul></li></ul><h3 id="实际示例与测试"><a href="#实际示例与测试" class="headerlink" title="实际示例与测试"></a>实际示例与测试</h3><h4 id="示例-1：仅作为编译期常量使用"><a href="#示例-1：仅作为编译期常量使用" class="headerlink" title="示例 1：仅作为编译期常量使用"></a>示例 1：仅作为编译期常量使用</h4><ul><li>C++11 及之前：无需类外定义。</li><li>C++17 及更新：同样无需类外定义，且可以使用 <code>inline</code> 进一步优化。</li></ul><h4 id="示例-2：取址"><a href="#示例-2：取址" class="headerlink" title="示例 2：取址"></a>示例 2：取址</h4><ul><li>C++11 及之前：必须提供类外定义，否则会在链接时出现错误。</li><li>C++17 及更新：若未使用 <code>inline</code>，仍需提供类外定义；使用 <code>inline</code> 则无需。</li></ul><h4 id="示例-3：使用-inline（C-17-及更高）"><a href="#示例-3：使用-inline（C-17-及更高）" class="headerlink" title="示例 3：使用 inline（C++17 及更高）"></a>示例 3：使用 inline（C++17 及更高）</h4><ul><li>C++17 及以上：<ul><li>无需类外定义。</li><li><code>inline</code> 保证了多重定义的合法性。</li></ul></li></ul><h3 id="详细解析"><a href="#详细解析" class="headerlink" title="详细解析"></a>详细解析</h3><h4 id="为什么有这样的特殊处理？"><a href="#为什么有这样的特殊处理？" class="headerlink" title="为什么有这样的特殊处理？"></a>为什么有这样的特殊处理？</h4><ul><li><strong>优化与性能</strong>：<ul><li>在编译期常量的情况下，不需要在运行时分配存储空间，编译器可以优化掉相关代码。</li></ul></li><li><strong>兼容性</strong>：<ul><li>早期 C++ 标准遵循这种规则，允许在类内初始化静态常量成员变量，便于模板元编程和常量表达式的使用。</li></ul></li><li><strong>inline 变量</strong>：<ul><li>C++17 引入 <code>inline</code> 关键字用于变量，解决了静态成员变量在多个翻译单元中的定义问题，使得代码更简洁。</li></ul></li></ul><h4 id="是否总是需要定义？"><a href="#是否总是需要定义？" class="headerlink" title="是否总是需要定义？"></a>是否总是需要定义？</h4><p>并非总是需要。关键在于 <strong>如何使用</strong> 这个静态成员变量：</p><ul><li><strong>仅作为编译期常量使用</strong>：无需类外定义。</li><li><strong>需要存储位置或取址</strong>：需要类外定义，除非使用 <code>inline</code>（C++17 及以上）。</li></ul><h4 id="编译器与链接器的行为"><a href="#编译器与链接器的行为" class="headerlink" title="编译器与链接器的行为"></a>编译器与链接器的行为</h4><ul><li><strong>编译阶段</strong>：<ul><li>类内的初始化用于编译期常量计算，不涉及存储分配。</li></ul></li><li><strong>链接阶段</strong>：<ul><li>如果没有类外定义，且静态成员被 odr-used（可能需要存储位置），链接器会报错，提示找不到符号定义。</li><li>使用 <code>inline</code> 关键字后，编译器处理为内联变量，避免了多重定义问题。</li></ul></li></ul><h4 id="示例：编译期斐波那契数列"><a href="#示例：编译期斐波那契数列" class="headerlink" title="示例：编译期斐波那契数列"></a>示例：编译期斐波那契数列</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = Fibonacci&lt;N - <span class="number">1</span>&gt;::value + Fibonacci&lt;N - <span class="number">2</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">1</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fibonacci(10): &quot;</span> &lt;&lt; Fibonacci&lt;<span class="number">10</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fibonacci(10): 55</span><br></pre></td></tr></table></figure><h3 id="要点：-4"><a href="#要点：-4" class="headerlink" title="要点："></a>要点：</h3><ul><li>模板元编程利用编译期计算提升程序性能。</li><li>需要理解模板递归与终止条件。</li><li>常与类型特性和模板特化结合使用。</li></ul><h2 id="类型计算与SFINAE"><a href="#类型计算与SFINAE" class="headerlink" title="类型计算与SFINAE"></a>类型计算与SFINAE</h2><ul><li><strong>类型计算</strong>：在编译期进行类型的推导和转换。</li><li><strong>SFINAE（Substitution Failure Is Not An Error）</strong>：模板实例化过程中，如果某个替换失败，编译器不会报错，而是忽略该模板，并尝试其他匹配。</li></ul><h3 id="示例：检测类型是否可加"><a href="#示例：检测类型是否可加" class="headerlink" title="示例：检测类型是否可加"></a>示例：检测类型是否可加</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> is_addable : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_addable</span>&lt;T, <span class="keyword">decltype</span>(<span class="built_in">void</span>(std::<span class="built_in">declval</span>&lt;T&gt;() + std::<span class="built_in">declval</span>&lt;T&gt;()))&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;is_addable&lt;T&gt;::value, T&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int is addable: &quot;</span> &lt;&lt; is_addable&lt;<span class="type">int</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::string is addable: &quot;</span> &lt;&lt; is_addable&lt;std::string&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>), std::<span class="built_in">string</span>(<span class="string">&quot; World&quot;</span>)) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>讲解：</strong></p><ol><li><p><code>struct is_addable&lt;...&gt; : std::true_type &#123;&#125;</code></p><ul><li>目的：定义一个名为 <code>is_addable</code> 的结构体模板，它继承自 <code>std::true_type</code>。</li><li>作用：当特定的模板参数满足条件时，这个特化版本将被选中，表示 T 类型是可加的，即支持 <code>+</code> 操作符。</li></ul></li><li><p>模板参数解释：<code>&lt;T, decltype(void(std::declval&lt;T&gt;() + std::declval&lt;T&gt;()))&gt;</code></p><ul><li><code>T</code>：这是要检查的类型。</li><li><code>std::declval&lt;T&gt;()</code>：<ul><li>用途：<code>std::declval&lt;T&gt;()</code> 是一个用于在不实际创建 T 类型对象的情况下，生成一个 T 类型的右值引用。</li><li>作用：它允许我们在编译时模拟 T 类型的对象，以便用于表达式的检测。</li></ul></li><li><code>std::declval&lt;T&gt;() + std::declval&lt;T&gt;()</code>：<ul><li>表达式：尝试对两个 T 类型的右值引用进行加法运算。</li><li>目的：检查 T 类型是否支持 <code>+</code> 操作符。</li></ul></li><li><code>void(...)</code>：<ul><li>将加法表达式的结果转换为 <code>void</code> 类型。这是为了在 <code>decltype</code> 中仅关心表达式是否有效，而不关心其具体类型。</li></ul></li><li><code>decltype(void(std::declval&lt;T&gt;() + std::declval&lt;T&gt;()))</code>：<ul><li>作用：如果 T 类型支持加法运算，则该 <code>decltype</code> 表达式的类型为 <code>void</code>，否则会导致替换失败。</li></ul></li></ul></li></ol><h2 id="高级模板元编程技巧"><a href="#高级模板元编程技巧" class="headerlink" title="高级模板元编程技巧"></a>高级模板元编程技巧</h2><ul><li><strong>变参模板（Variadic Templates）</strong>：支持模板参数包，实现更加灵活的模板定义。</li></ul><h3 id="示例：求和模板"><a href="#示例：求和模板" class="headerlink" title="示例：求和模板"></a>示例：求和模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span>... Ns&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span>&lt;&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N, <span class="type">int</span>... Ns&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span>&lt;N, Ns...&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N + Sum&lt;Ns...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; Sum&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>讲解：</strong></p><ol><li>基本模板<code>Sum</code>接受一个整数参数包<code>Ns...</code>。</li><li>特化模板<code>Sum&lt;&gt;</code>定义递归终止条件，<code>value</code>为0。</li><li>递归定义<code>Sum&lt;N, Ns...&gt;</code>将第一个参数<code>N</code>与剩余参数的和相加。</li><li>在main函数中，通过<code>Sum&lt;1, 2, 3, 4, 5&gt;::value</code>计算1+2+3+4+5&#x3D;15。</li></ol><ul><li><strong>类型列表（Type Lists）</strong>：通过模板参数包管理类型的集合。</li></ul><h3 id="示例：类型列表和元素访问"><a href="#示例：类型列表和元素访问" class="headerlink" title="示例：类型列表和元素访问"></a>示例：类型列表和元素访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeList</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> List, <span class="type">unsigned</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeAt</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeAt</span>&lt;TypeList&lt;Head, Tail...&gt;, <span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = Head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail, <span class="type">unsigned</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeAt</span>&lt;TypeList&lt;Head, Tail...&gt;, N&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> TypeAt&lt;TypeList&lt;Tail...&gt;, N - <span class="number">1</span>&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> list = TypeList&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">char</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> third_type = TypeAt&lt;list, <span class="number">2</span>&gt;::type;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Third type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(third_type).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>讲解：</strong></p><ol><li><code>TypeList</code>：定义一个包含多个类型的类型列表。</li><li><code>TypeAt</code>：通过递归模板，从<code>TypeList</code>中获取第N个类型。<ul><li>当N为0时，类型为<code>Head</code>。</li><li>否则，递归获取<code>Tail...</code>中第N-1个类型。</li></ul></li><li>使用：定义<code>list</code>为<code>TypeList&lt;int, double, char&gt;</code>，<code>third_type</code>为第2个类型，即<code>char</code>。</li></ol><h2 id="实际应用案例"><a href="#实际应用案例" class="headerlink" title="实际应用案例"></a>实际应用案例</h2><h3 id="案例1：静态断言与类型检查"><a href="#案例1：静态断言与类型检查" class="headerlink" title="案例1：静态断言与类型检查"></a>案例1：静态断言与类型检查</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_arithmetic&lt;T&gt;::value, <span class="string">&quot;T must be arithmetic type&quot;</span>);</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(<span class="number">42</span>);      <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">process</span>(<span class="number">3.14</span>);    <span class="comment">// OK</span></span><br><span class="line">    <span class="comment">// process(&quot;hello&quot;); // 编译错误：静态断言失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例2：编译期字符串"><a href="#案例2：编译期字符串" class="headerlink" title="案例2：编译期字符串"></a>案例2：编译期字符串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> String&lt;Cs...&gt;::value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>] = &#123;Cs..., <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Hello = String&lt;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&gt;;</span><br><span class="line">    std::cout &lt;&lt; Hello::value &lt;&lt; std::endl;  <span class="comment">// 输出：Hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么需要外部定义-value"><a href="#为什么需要外部定义-value" class="headerlink" title="为什么需要外部定义 value"></a>为什么需要外部定义 value</h3><p>在 C++ 中，静态成员变量与类的实例无关，它们存在于全局命名空间中。然而，静态成员变量的声明和定义是不同的：</p><ol><li><strong>声明</strong>：告诉编译器类中存在这个变量。</li><li><strong>定义</strong>：为这个变量分配存储空间。</li></ol><p>对于非 <code>inline</code> 的静态成员变量，即使是 <code>constexpr</code>，都需要在类外部进行定义。否则，链接器在处理多个翻译单元时会因为找不到变量的定义而报错。</p><h4 id="具体原因"><a href="#具体原因" class="headerlink" title="具体原因"></a>具体原因</h4><ol><li><p><strong>模板类的静态成员变量</strong>：</p><ul><li>每当模板实例化时，都会产生一个新的类类型，每个类类型都有自己的一组静态成员变量。</li><li>因此，编译器需要知道这些静态成员变量在所有翻译单元中都唯一对应一个定义。</li></ul></li><li><p><strong>constexpr 静态成员变量</strong>：</p><ul><li>从 C++17 开始，<code>inline</code> 关键字引入，使得 <code>constexpr</code> 静态成员变量可以在类内定义，并且隐式地具有 <code>inline</code> 属性。这意味着不需要在类外定义它们，因为 <code>inline</code> 确保了在多个翻译单元中有同一份定义。</li><li>但在 C++17 之前或不使用 <code>inline</code> 的情况下，即使是 <code>constexpr</code>，仍需在类外定义。</li></ul></li></ol><ul><li><strong>类内声明</strong>：<code>static constexpr char value[...]</code> 声明了 <code>value</code> 并给予了初始值。</li><li><strong>类外定义</strong>：<code>constexpr char String&lt;Cs...&gt;::value[...]</code> 为 <code>value</code> 分配了存储空间。</li></ul><p>如果省略类外定义，编译器会在链接阶段找不到 <code>value</code> 的定义，导致链接错误。这尤其适用于 C++14 及更早版本，以及 C++17 中未使用 <code>inline</code> 的情形。</p><h3 id="如何避免外部定义"><a href="#如何避免外部定义" class="headerlink" title="如何避免外部定义"></a>如何避免外部定义</h3><p>如果你使用的是 C++17 或更高版本，可以通过 <code>inline</code> 关键字将静态成员变量声明为 <code>inline</code>，从而在类内完成定义，无需再在外部定义。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span> value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>] = &#123;Cs..., <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个版本中，<code>inline</code> 关键字告诉编译器这是一个内联变量，允许在多个翻译单元中存在同一份定义，而不会导致重复定义错误。因此，无需在类外再次定义 <code>value</code>。</p><h3 id="完整示例对比"><a href="#完整示例对比" class="headerlink" title="完整示例对比"></a>完整示例对比</h3><h4 id="不使用-inline（需要类外定义）"><a href="#不使用-inline（需要类外定义）" class="headerlink" title="不使用 inline（需要类外定义）"></a>不使用 inline（需要类外定义）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++14 及更早版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> String&lt;Cs...&gt;::value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>] = &#123;Cs..., <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="使用-inline（无需类外定义，C-17-起）"><a href="#使用-inline（无需类外定义，C-17-起）" class="headerlink" title="使用 inline（无需类外定义，C++17 起）"></a>使用 inline（无需类外定义，C++17 起）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++17 及更高版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">char</span>... Cs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span> value[<span class="keyword">sizeof</span>...(Cs) + <span class="number">1</span>] = &#123;Cs..., <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="C-20-Concepts"><a href="#C-20-Concepts" class="headerlink" title="C++20 Concepts"></a>C++20 Concepts</h2><p>C++20 引入了 Concepts，它们为模板参数提供了更强的约束和表达能力，使模板的使用更简洁、错误信息更友好。</p><h3 id="定义与使用"><a href="#定义与使用" class="headerlink" title="定义与使用"></a>定义与使用</h3><h4 id="定义一个-Concept"><a href="#定义一个-Concept" class="headerlink" title="定义一个 Concept"></a>定义一个 Concept</h4><p>Concepts 使用 <code>concept</code> 关键字定义，并作为函数或类模板的约束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Arithmetic = std::integral&lt;T&gt; || std::floating_point&lt;T&gt;;</span><br></pre></td></tr></table></figure><h4 id="使用-Concept-约束模板"><a href="#使用-Concept-约束模板" class="headerlink" title="使用 Concept 约束模板"></a>使用 Concept 约束模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;Arithmetic T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 requires 子句</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> Arithmetic&lt;T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">multiply</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="限制与约束"><a href="#限制与约束" class="headerlink" title="限制与约束"></a>限制与约束</h3><p>Concepts 允许为模板参数定义复杂的约束，使得模板更具表达性，同时提升编译器错误信息的可理解性。</p><h4 id="示例：排序函数中的-Concepts"><a href="#示例：排序函数中的-Concepts" class="headerlink" title="示例：排序函数中的 Concepts"></a>示例：排序函数中的 Concepts</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Sortable = <span class="built_in">requires</span>(T a, T b) &#123;</span><br><span class="line">    &#123; a &lt; b &#125; -&gt; std::convertible_to&lt;<span class="type">bool</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;Sortable T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortAndPrint</span><span class="params">(std::vector&lt;T&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">sortAndPrint</span>(numbers);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::vector&lt;std::vector&lt;int&gt;&gt; nested; // 不会满足 Sortable 概念</span></span><br><span class="line">    <span class="comment">// sortAndPrint(nested); // 编译错误</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 3 4 5 </span><br></pre></td></tr></table></figure><h3 id="要点：-5"><a href="#要点：-5" class="headerlink" title="要点："></a>要点：</h3><ul><li>Concepts 提供了模板参数的语义约束。</li><li>使用 Concepts 提高模板的可读性和可维护性。</li><li>生成更友好的编译错误信息，易于调试。</li></ul><h2 id="模板实例化与编译器行为"><a href="#模板实例化与编译器行为" class="headerlink" title="模板实例化与编译器行为"></a>模板实例化与编译器行为</h2><p>理解模板实例化的过程有助于进行有效的模板设计与优化，尤其是在涉及链接和编译时间时。</p><h3 id="显式实例化（Explicit-Instantiation）"><a href="#显式实例化（Explicit-Instantiation）" class="headerlink" title="显式实例化（Explicit Instantiation）"></a>显式实例化（Explicit Instantiation）</h3><p>显式实例化告诉编译器生成特定类型下的模板代码，主要用于分离模板的声明与定义，减少编译时间。</p><h4 id="语法：-5"><a href="#语法：-5" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&lt;Type&gt;;      <span class="comment">// 类模板显式实例化</span></span><br><span class="line"><span class="keyword">template</span> returnType <span class="built_in">functionName</span>&lt;Type&gt;(parameters); <span class="comment">// 函数模板显式实例化</span></span><br></pre></td></tr></table></figure><h4 id="示例：分离类模板的声明与定义"><a href="#示例：分离类模板的声明与定义" class="headerlink" title="示例：分离类模板的声明与定义"></a>示例：分离类模板的声明与定义</h4><p><strong>MyClass.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(T v);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>MyClass.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyClass&lt;T&gt;::<span class="built_in">MyClass</span>(T v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> MyClass&lt;T&gt;::<span class="built_in">print</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">double</span>&gt;;</span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">int</span>&gt; <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">double</span>&gt; <span class="title">obj2</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    obj1.<span class="built_in">print</span>();</span><br><span class="line">    obj2.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value: 42</span><br><span class="line">Value: 3.14</span><br></pre></td></tr></table></figure><h4 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h4><ul><li>显式实例化需要在模板定义后进行。</li><li>只有显式实例化的类型在未实例化时可用于模板分离。</li><li>未显式实例化的类型可能导致链接错误。</li></ul><h3 id="隐式实例化（Implicit-Instantiation）"><a href="#隐式实例化（Implicit-Instantiation）" class="headerlink" title="隐式实例化（Implicit Instantiation）"></a>隐式实例化（Implicit Instantiation）</h3><p>隐式实例化是编译器在模板被实际使用时自动生成对应实例代码的过程。通常，模板定义与使用都在头文件中完成。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p><strong>MyClass.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(T v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">int</span>&gt; <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">double</span>&gt; <span class="title">obj2</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    obj1.<span class="built_in">print</span>();</span><br><span class="line">    obj2.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value: 42</span><br><span class="line">Value: 3.14</span><br></pre></td></tr></table></figure><h4 id="要点：-6"><a href="#要点：-6" class="headerlink" title="要点："></a>要点：</h4><ul><li>隐式实例化不需要显式声明或定义。</li><li>模板定义必须在使用前可见，通常通过头文件实现。</li><li>容易导致编译时间增加，尤其是大型模板库。</li></ul><h3 id="链接时问题与解决方案"><a href="#链接时问题与解决方案" class="headerlink" title="链接时问题与解决方案"></a>链接时问题与解决方案</h3><p>由于模板是在使用时被实例化，跨源文件使用模板可能导致链接时问题，如重复定义或未定义引用。</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ol><li><strong>内联实现</strong>：将模板的定义与声明一起放在头文件中，避免链接时重复定义。</li><li><strong>显式实例化</strong>：将常用的模板实例化放在源文件中，其他源文件通过 <code>extern</code> 或头文件引用已有实例。</li><li><strong>使用 extern template</strong>：告知编译器某些模板实例已在其他源文件中显式实例化。</li></ol><h4 id="示例：使用-extern-template"><a href="#示例：使用-extern-template" class="headerlink" title="示例：使用 extern template"></a>示例：使用 extern template</h4><p><strong>MyClass.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// ... 声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明外部实例化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">double</span>&gt;;</span><br></pre></td></tr></table></figure><p><strong>MyClass.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义（实例化）</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">double</span>&gt;;</span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">int</span>&gt; <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;    <span class="comment">// 使用外部实例化</span></span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">double</span>&gt; <span class="title">obj2</span><span class="params">(<span class="number">3.14</span>)</span></span>; <span class="comment">// 使用外部实例化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="要点：-7"><a href="#要点：-7" class="headerlink" title="要点："></a>要点：</h4><ul><li>使用 <code>extern template</code> 声明已在其他源文件中实例化的模板。</li><li>减少编译时间和链接大小，防止重复定义。</li></ul><h2 id="最佳实践与注意事项"><a href="#最佳实践与注意事项" class="headerlink" title="最佳实践与注意事项"></a>最佳实践与注意事项</h2><p>掌握模板的最佳实践有助于编写高效、可维护的代码，同时避免常见的陷阱和问题。</p><h3 id="模板定义与实现分离"><a href="#模板定义与实现分离" class="headerlink" title="模板定义与实现分离"></a>模板定义与实现分离</h3><p>对于类模板，通常将模板的声明和定义放在同一头文件中，以确保编译器在实例化模板时能够看到完整的定义。尽管可以尝试将模板定义分离到源文件，但需要结合显式实例化，这会增加复杂性，且不适用于广泛使用的模板。</p><h4 id="推荐做法："><a href="#推荐做法：" class="headerlink" title="推荐做法："></a>推荐做法：</h4><ul><li><strong>类模板</strong>：将声明和实现统一在头文件中。</li><li><strong>函数模板</strong>：同样将声明和实现统一在头文件中，或使用显式实例化。</li></ul><h3 id="避免过度模板化"><a href="#避免过度模板化" class="headerlink" title="避免过度模板化"></a>避免过度模板化</h3><p>虽然模板提供了极大的灵活性，但过度复杂的模板会导致代码难以理解、维护和编译时间增加。</p><h4 id="建议："><a href="#建议：" class="headerlink" title="建议："></a>建议：</h4><ul><li>只在必要时使用模板。</li><li>保持模板的简单性和可读性，避免过度嵌套和复杂的特化。</li><li>合理使用类型特性和 Concepts 进行约束。</li></ul><h3 id="提高编译速度的方法"><a href="#提高编译速度的方法" class="headerlink" title="提高编译速度的方法"></a>提高编译速度的方法</h3><p>模板的广泛使用可能导致编译时间显著增加。以下方法有助于优化编译速度：</p><ol><li><strong>预编译头文件（Precompiled Headers）</strong>：将频繁使用的模板库放入预编译头中，加速编译。</li><li><strong>显式实例化</strong>：通过显式实例化减少模板的重复编译。</li><li><strong>模块化编程（C++20 Modules）</strong>：利用模块化将模板库进行编译和链接，减少编译时间。</li><li><strong>合理分割头文件</strong>：避免头文件中的模板定义过大，分割成较小的模块。</li></ol><h3 id="代码复用与库设计"><a href="#代码复用与库设计" class="headerlink" title="代码复用与库设计"></a>代码复用与库设计</h3><p>模板是实现高度复用库组件的有效手段，如标准库（<code>std::vector</code>、<code>std::map</code> 等）广泛使用模板。设计模板库时，需考虑以下因素：</p><ul><li><strong>接口的一致性</strong>：保持模板库的接口简洁、一致，便于使用者理解和使用。</li><li><strong>文档与示例</strong>：提供详细的文档和示例代码，帮助使用者理解模板库的用法。</li><li><strong>错误信息友好</strong>：通过 Concepts、SFINAE 等机制提供清晰的错误信息，降低使用门槛。</li><li><strong>性能优化</strong>：利用模板的编译期计算和内联等特性，提高库组件的性能。</li></ul><h3 id="避免模板错误的困惑"><a href="#避免模板错误的困惑" class="headerlink" title="避免模板错误的困惑"></a>避免模板错误的困惑</h3><p>模板错误通常复杂且难以理解，以下方法有助于减少模板错误的困惑：</p><ul><li><strong>逐步调试</strong>：从简单的模板开始，逐步增加复杂性，便于定位错误。</li><li><strong>使用编译器警告与工具</strong>：开启编译器的警告选项，使用静态分析工具检测模板代码中的问题。</li><li><strong>代码注释与文档</strong>：详细注释复杂的模板代码，提供文档说明其设计和用途。</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>C++ 模板机制是实现泛型编程的核心工具，通过类型参数化和编译期计算，极大地提升了代码的复用性、灵活性和性能。从基础的函数模板和类模板，到高级的模板特化、变参模板、模板元编程、SFINAE 和 Concepts，掌握模板的各个方面能够帮助开发者编写更高效、更加通用的 C++ 代码。</p><p>在实际应用中，合理运用模板不仅可以简化代码结构，还可以提高代码的可维护性和可扩展性。然而，模板的复杂性也要求开发者具备扎实的 C++ 基础和良好的编程习惯，以避免过度复杂化和难以调试的问题。</p><p>通过本教案的系统学习，相信您已经具备了全面理解和运用 C++ 模板的能力，能够在实际项目中高效地利用模板特性，编写出更为优秀的代码。</p><h2 id="练习与习题"><a href="#练习与习题" class="headerlink" title="练习与习题"></a>练习与习题</h2><h3 id="练习-1：实现一个通用的-Swap-函数模板"><a href="#练习-1：实现一个通用的-Swap-函数模板" class="headerlink" title="练习 1：实现一个通用的 Swap 函数模板"></a>练习 1：实现一个通用的 Swap 函数模板</h3><p><strong>要求：</strong></p><ul><li>编写一个函数模板 <code>swapValues</code>，可以交换任意类型的两个变量。</li><li>在 main 函数中测试 int、double、std::string 类型的交换。</li></ul><p><strong>提示：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapValues</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现交换逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习-2：实现一个模板类-Triple，存储三个相同类型的值，并提供获取各个成员的函数。"><a href="#练习-2：实现一个模板类-Triple，存储三个相同类型的值，并提供获取各个成员的函数。" class="headerlink" title="练习 2：实现一个模板类 Triple，存储三个相同类型的值，并提供获取各个成员的函数。"></a>练习 2：实现一个模板类 Triple，存储三个相同类型的值，并提供获取各个成员的函数。</h3><p><strong>要求：</strong></p><ul><li>模板参数为类型 T。</li><li>提供构造函数、成员变量及访问函数。</li><li>在 main 中实例化 <code>Triple&lt;int&gt;</code> 和 <code>Triple&lt;std::string&gt;</code>，进行测试。</li></ul><h3 id="练习-3：使用模板特化，为类模板-Printer-提供针对-bool-类型的全特化，实现专门的输出格式。"><a href="#练习-3：使用模板特化，为类模板-Printer-提供针对-bool-类型的全特化，实现专门的输出格式。" class="headerlink" title="练习 3：使用模板特化，为类模板 Printer 提供针对 bool 类型的全特化，实现专门的输出格式。"></a>练习 3：使用模板特化，为类模板 Printer 提供针对 bool 类型的全特化，实现专门的输出格式。</h3><p><strong>要求：</strong></p><ul><li>通用模板类 Printer，具有 print 函数，输出 “General Printer: value”。</li><li>全特化 <code>Printer&lt;bool&gt;</code>，输出 “Boolean Printer: true” 或 “Boolean Printer: false”。</li></ul><h3 id="练习-4：实现一个变参模板函数-logMessages，可以接受任意数量和类型的参数，并依次打印它们。"><a href="#练习-4：实现一个变参模板函数-logMessages，可以接受任意数量和类型的参数，并依次打印它们。" class="headerlink" title="练习 4：实现一个变参模板函数 logMessages，可以接受任意数量和类型的参数，并依次打印它们。"></a>练习 4：实现一个变参模板函数 logMessages，可以接受任意数量和类型的参数，并依次打印它们。</h3><p><strong>要求：</strong></p><ul><li>使用递归方法实现。</li><li>在 main 中测试不同参数组合的调用。</li></ul><h3 id="练习-5：编写模板元编程结构-IsPointer-用于在编译期判断一个类型是否为指针类型。"><a href="#练习-5：编写模板元编程结构-IsPointer-用于在编译期判断一个类型是否为指针类型。" class="headerlink" title="练习 5：编写模板元编程结构 IsPointer, 用于在编译期判断一个类型是否为指针类型。"></a>练习 5：编写模板元编程结构 IsPointer, 用于在编译期判断一个类型是否为指针类型。</h3><p><strong>要求：</strong></p><ul><li>定义 <code>IsPointer&lt;T&gt;</code>，包含 value 静态常量成员，值为 true 或 false。</li><li>使用特化进行实现。</li><li>在 main 中使用 static_assert 进行测试。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(IsPointer&lt;<span class="type">int</span>*&gt;::value, <span class="string">&quot;int* should be a pointer&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(!IsPointer&lt;<span class="type">int</span>&gt;::value, <span class="string">&quot;int should not be a pointer&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="练习-6：使用-SFINAE，编写一个函数模板-enableIfExample，只有当类型-T-具有-size-成员函数时才启用。"><a href="#练习-6：使用-SFINAE，编写一个函数模板-enableIfExample，只有当类型-T-具有-size-成员函数时才启用。" class="headerlink" title="练习 6：使用 SFINAE，编写一个函数模板 enableIfExample，只有当类型 T 具有 size() 成员函数时才启用。"></a>练习 6：使用 SFINAE，编写一个函数模板 enableIfExample，只有当类型 T 具有 size() 成员函数时才启用。</h3><p><strong>要求：</strong></p><ul><li>使用 std::enable_if 和类型特性检测 size() 成员。</li><li>在 main 中测试 std::vector<int>（应启用）和 int（不应启用）。</li></ul><p><strong>提示：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;has_size&lt;T&gt;::value&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">enableIfExample</span><span class="params">(<span class="type">const</span> T&amp; container)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size: &quot;</span> &lt;&lt; container.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习-7：使用-C-20-Concepts，定义一个-Concept-Integral，要求类型必须是整型，并使用该-Concept-约束一个函数模板-isEven，判断传入的整数是否为偶数。"><a href="#练习-7：使用-C-20-Concepts，定义一个-Concept-Integral，要求类型必须是整型，并使用该-Concept-约束一个函数模板-isEven，判断传入的整数是否为偶数。" class="headerlink" title="练习 7：使用 C++20 Concepts，定义一个 Concept Integral，要求类型必须是整型，并使用该 Concept 约束一个函数模板 isEven，判断传入的整数是否为偶数。"></a>练习 7：使用 C++20 Concepts，定义一个 Concept Integral，要求类型必须是整型，并使用该 Concept 约束一个函数模板 isEven，判断传入的整数是否为偶数。</h3><p><strong>要求：</strong></p><ul><li>定义 Integral Concept。</li><li>编写函数模板 isEven(u)，仅接受满足 Integral 的类型。</li><li>在 main 中测试不同类型的调用。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;Integral T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEven</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习-8：实现一个固定大小的栈（FixedStack）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。"><a href="#练习-8：实现一个固定大小的栈（FixedStack）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。" class="headerlink" title="练习 8：实现一个固定大小的栈（FixedStack）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。"></a>练习 8：实现一个固定大小的栈（FixedStack）类模板，支持多种数据类型和指定大小。使用非类型模板参数指定栈的大小。</h3><p><strong>要求：</strong></p><ul><li>模板参数为类型 T 和 std::size_t N。</li><li>提供 push, pop, top 等成员函数。</li><li>在 main 中测试 <code>FixedStack&lt;int, 5&gt;</code> 和 <code>FixedStack&lt;std::string, 3&gt;</code>。</li></ul><h3 id="练习-9：实现一个模板类-TypeIdentity，其成员类型-type-等同于模板参数-T。并使用-static-assert-检查类型关系。"><a href="#练习-9：实现一个模板类-TypeIdentity，其成员类型-type-等同于模板参数-T。并使用-static-assert-检查类型关系。" class="headerlink" title="练习 9：实现一个模板类 TypeIdentity，其成员类型 type 等同于模板参数 T。并使用 static_assert 检查类型关系。"></a>练习 9：实现一个模板类 TypeIdentity，其成员类型 type 等同于模板参数 T。并使用 static_assert 检查类型关系。</h3><p><strong>要求：</strong></p><ul><li>定义 <code>TypeIdentity&lt;T&gt;</code>，包含类型成员 type。</li><li>使用 std::is_same 与 static_assert 验证。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(std::is_same&lt;TypeIdentity&lt;<span class="type">int</span>&gt;::type, <span class="type">int</span>&gt;::value, <span class="string">&quot;TypeIdentity&lt;int&gt; should be int&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="练习-10：编写一个模板元编程结构-LengthOf-用于在编译期计算类型列表的长度。"><a href="#练习-10：编写一个模板元编程结构-LengthOf-用于在编译期计算类型列表的长度。" class="headerlink" title="练习 10：编写一个模板元编程结构 LengthOf, 用于在编译期计算类型列表的长度。"></a>练习 10：编写一个模板元编程结构 LengthOf, 用于在编译期计算类型列表的长度。</h3><p><strong>要求：</strong></p><ul><li>使用 TypeList 模板定义类型列表。</li><li>定义 <code>LengthOf&lt;TypeList&lt;...&gt;&gt;::value</code> 表示类型列表的长度。</li><li>在 main 中使用 static_assert 进行测试。</li></ul><p><strong>提示：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeList</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LengthOf</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LengthOf</span>&lt;TypeList&lt;Types...&gt;&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> std::<span class="type">size_t</span> value = <span class="keyword">sizeof</span>...(Types);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过上述内容及练习，相信您已全面掌握了 C++ 模板的各个方面。从基础概念到高级技术，模板为 C++ 编程提供了强大的工具。持续练习与应用，将进一步巩固您的模板编程能力。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;模板详解&quot;&gt;&lt;a href=&quot;#模板详解&quot; class=&quot;headerlink&quot; title=&quot;模板详解&quot;&gt;&lt;/a&gt;模板详解&lt;/h1&gt;&lt;h2 id=&quot;模板基础&quot;&gt;&lt;a href=&quot;#模板基础&quot; class=&quot;headerlink&quot; title=&quot;模板基础&quot;&gt;&lt;/a&gt;模板基础&lt;/h2&gt;&lt;p&gt;C++ 模板（Templates）是现代 C++ 中强大而灵活的特性，支持泛型编程，使得代码更具复用性和类型安全性。模板不仅包括基本的函数模板和类模板，还涵盖了模板特化（全特化与偏特化）、模板参数种类、变参模板（Variadic Templates）、模板元编程（Template Metaprogramming）、SFINAE（Substitution Failure Is Not An Error）等高级内容。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C++ 智能指针详解：shared_ptr, auto_ptr 和 weak_ptr</title>
    <link href="https://lyroom.github.io/2025/09/23/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3%EF%BC%9Ashared-ptr-auto-ptr-%E5%92%8C-weak-ptr/"/>
    <id>https://lyroom.github.io/2025/09/23/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3%EF%BC%9Ashared-ptr-auto-ptr-%E5%92%8C-weak-ptr/</id>
    <published>2025-09-23T02:44:23.000Z</published>
    <updated>2025-09-23T02:44:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-智能指针详解：shared-ptr-auto-ptr-和-weak-ptr"><a href="#C-智能指针详解：shared-ptr-auto-ptr-和-weak-ptr" class="headerlink" title="C++ 智能指针详解：shared_ptr, auto_ptr 和 weak_ptr"></a>C++ 智能指针详解：shared_ptr, auto_ptr 和 weak_ptr</h1><h2 id="1-shared-ptr：共享所有权智能指针"><a href="#1-shared-ptr：共享所有权智能指针" class="headerlink" title="1. shared_ptr：共享所有权智能指针"></a>1. shared_ptr：共享所有权智能指针</h2><h3 id="1-1-核心概念与定义"><a href="#1-1-核心概念与定义" class="headerlink" title="1.1 核心概念与定义"></a>1.1 核心概念与定义</h3><h4 id="1-1-1-什么是-shared-ptr"><a href="#1-1-1-什么是-shared-ptr" class="headerlink" title="1.1.1 什么是 shared_ptr"></a>1.1.1 什么是 shared_ptr</h4><p><code>std::shared_ptr</code> 是 C++11 引入的共享所有权智能指针，它通过<strong>引用计数（Reference Counting）</strong> 机制实现多个智能指针共享同一个对象的所有权。与 <code>unique_ptr</code> 的独占所有权不同，<code>shared_ptr</code> 允许多个指针实例共同管理同一个动态分配的对象。</p><span id="more"></span>                           <p>&#x3D;、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、<br>当最后一个指向对象的 <code>shared_ptr</code> 被销毁或重置时，对象才会被自动删除。这种机制使得 <code>shared_ptr</code> 在需要共享资源的场景下非常有用。</p><h4 id="1-1-2-共享所有权语义"><a href="#1-1-2-共享所有权语义" class="headerlink" title="1.1.2 共享所有权语义"></a>1.1.2 共享所有权语义</h4><p><code>shared_ptr</code> 的核心是共享所有权模型。多个 <code>shared_ptr</code> 实例可以指向同一个对象，它们通过内部的引用计数器来跟踪有多少个 <code>shared_ptr</code> 正在共享该对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 引用计数变为 2</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr2; <span class="comment">// 引用计数变为 3</span></span><br><span class="line"><span class="comment">// 当 ptr1, ptr2, ptr3 都被销毁时，对象才会被删除</span></span><br></pre></td></tr></table></figure><h4 id="1-1-3-引用计数机制"><a href="#1-1-3-引用计数机制" class="headerlink" title="1.1.3 引用计数机制"></a>1.1.3 引用计数机制</h4><p>引用计数是 <code>shared_ptr</code> 的核心实现机制：</p><ul><li>当新的 <code>shared_ptr</code> 指向现有对象时，引用计数增加</li><li>当 <code>shared_ptr</code> 被销毁或指向新对象时，引用计数减少</li><li>当引用计数降为 0 时，对象被自动删除</li></ul><h3 id="1-2-内部实现与控制块"><a href="#1-2-内部实现与控制块" class="headerlink" title="1.2 内部实现与控制块"></a>1.2 内部实现与控制块</h3><h4 id="1-2-1-控制块（Control-Block）结构"><a href="#1-2-1-控制块（Control-Block）结构" class="headerlink" title="1.2.1 控制块（Control Block）结构"></a>1.2.1 控制块（Control Block）结构</h4><p><code>shared_ptr</code> 的内部实现比 <code>unique_ptr</code> 复杂，它包含两个指针：</p><ol><li><strong>指向管理对象的指针</strong></li><li><strong>指向控制块的指针</strong></li></ol><p>控制块包含：</p><ul><li>引用计数器（use count）</li><li>弱引用计数器（weak count）</li><li>删除器（deleter）</li><li>分配器（allocator）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">control_block</span> &#123;</span><br><span class="line">    std::atomic&lt;<span class="type">long</span>&gt; use_count;</span><br><span class="line">    std::atomic&lt;<span class="type">long</span>&gt; weak_count;</span><br><span class="line">    <span class="built_in">void</span>(*deleter)(T*);</span><br><span class="line">    T* managed_object;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-引用计数的原子操作"><a href="#1-2-2-引用计数的原子操作" class="headerlink" title="1.2.2 引用计数的原子操作"></a>1.2.2 引用计数的原子操作</h4><p>为了保证线程安全，<code>shared_ptr</code> 的引用计数操作必须是原子的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 近似实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_ref_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    use_count.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrement_ref_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (use_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_acq_rel) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 最后一个 shared_ptr，删除对象</span></span><br><span class="line">        <span class="built_in">deleter</span>(managed_object);</span><br><span class="line">        <span class="comment">// 如果 weak_count 也为 0，删除控制块</span></span><br><span class="line">        <span class="keyword">if</span> (weak_count.<span class="built_in">load</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-常用接口与用法"><a href="#1-3-常用接口与用法" class="headerlink" title="1.3 常用接口与用法"></a>1.3 常用接口与用法</h3><h4 id="1-3-1-构造与析构"><a href="#1-3-1-构造与析构" class="headerlink" title="1.3.1 构造与析构"></a>1.3.1 构造与析构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多种构造方式</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 推荐方式</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p3 = p1; <span class="comment">// 拷贝构造，引用计数+1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义删除器</span></span><br><span class="line"><span class="keyword">auto</span> deleter = [](<span class="type">int</span>* p) &#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Deleting int\n&quot;</span>; </span><br><span class="line">    <span class="keyword">delete</span> p; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>), deleter)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-所有权管理接口"><a href="#1-3-2-所有权管理接口" class="headerlink" title="1.3.2 所有权管理接口"></a>1.3.2 所有权管理接口</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;MyClass&gt; ptr = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取原始指针（不增加引用计数）</span></span><br><span class="line">MyClass* raw_ptr = ptr.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置指针</span></span><br><span class="line">ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">MyClass</span>()); <span class="comment">// 原对象引用计数-1，管理新对象</span></span><br><span class="line">ptr.<span class="built_in">reset</span>(); <span class="comment">// 变为空指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个 shared_ptr</span></span><br><span class="line">std::shared_ptr&lt;MyClass&gt; ptr2 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line">ptr.<span class="built_in">swap</span>(ptr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取引用计数</span></span><br><span class="line"><span class="type">long</span> count = ptr.<span class="built_in">use_count</span>(); <span class="comment">// 注意：多线程环境下仅供参考</span></span><br></pre></td></tr></table></figure><h4 id="1-3-3-操作符重载"><a href="#1-3-3-操作符重载" class="headerlink" title="1.3.3 操作符重载"></a>1.3.3 操作符重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;MyClass&gt; ptr = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解引用操作</span></span><br><span class="line">(*ptr).<span class="built_in">member_function</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">member_function</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔转换</span></span><br><span class="line"><span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">    <span class="comment">// ptr 不为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较操作</span></span><br><span class="line"><span class="keyword">if</span> (ptr == ptr2) &#123;</span><br><span class="line">    <span class="comment">// 指向同一对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-性能特点与开销"><a href="#1-4-性能特点与开销" class="headerlink" title="1.4 性能特点与开销"></a>1.4 性能特点与开销</h3><h4 id="1-4-1-内存开销"><a href="#1-4-1-内存开销" class="headerlink" title="1.4.1 内存开销"></a>1.4.1 内存开销</h4><ul><li><strong>控制块开销</strong>：每个被管理的对象都有一个控制块</li><li><strong>指针开销</strong>：<code>shared_ptr</code> 本身包含两个指针（对象指针和控制块指针）</li><li><strong>总大小</strong>：通常是原始指针的两倍大小</li></ul><h4 id="1-4-2-运行时开销"><a href="#1-4-2-运行时开销" class="headerlink" title="1.4.2 运行时开销"></a>1.4.2 运行时开销</h4><ul><li><strong>原子操作</strong>：引用计数的增减需要原子操作，有性能开销</li><li><strong>控制块分配</strong>：需要额外的内存分配（除非使用 <code>make_shared</code>）</li></ul><h4 id="1-4-3-make-shared-的优势"><a href="#1-4-3-make-shared-的优势" class="headerlink" title="1.4.3 make_shared 的优势"></a>1.4.3 make_shared 的优势</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式：两次内存分配（对象 + 控制块）</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make_shared：一次内存分配（对象和控制块在一起）</span></span><br><span class="line">std::shared_ptr&lt;MyClass&gt; p2 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br></pre></td></tr></table></figure><p><code>make_shared</code> 将对象和控制块分配在连续内存中，提高了缓存局部性并减少了一次内存分配。</p><h3 id="1-5-实际应用场景"><a href="#1-5-实际应用场景" class="headerlink" title="1.5 实际应用场景"></a>1.5 实际应用场景</h3><h4 id="1-5-1-共享资源管理"><a href="#1-5-1-共享资源管理" class="headerlink" title="1.5.1 共享资源管理"></a>1.5.1 共享资源管理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Using resource\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Resource&gt; resource_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">User</span>(std::shared_ptr&lt;Resource&gt; res) : <span class="built_in">resource_</span>(res) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; resource_-&gt;<span class="built_in">use</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个用户共享同一资源</span></span><br><span class="line"><span class="keyword">auto</span> resource = std::<span class="built_in">make_shared</span>&lt;Resource&gt;();</span><br><span class="line"><span class="function">User <span class="title">user1</span><span class="params">(resource)</span></span>;</span><br><span class="line"><span class="function">User <span class="title">user2</span><span class="params">(resource)</span></span>; <span class="comment">// 共享同一资源</span></span><br></pre></td></tr></table></figure><h4 id="1-5-2-缓存系统"><a href="#1-5-2-缓存系统" class="headerlink" title="1.5.2 缓存系统"></a>1.5.2 缓存系统</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, std::shared_ptr&lt;Data&gt;&gt; cache_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Data&gt; <span class="title">get</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = cache_.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it != cache_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;second; <span class="comment">// 返回共享指针，延长生命周期</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">const</span> std::string&amp; key, std::shared_ptr&lt;Data&gt; data)</span> </span>&#123;</span><br><span class="line">        cache_[key] = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-weak-ptr：弱引用智能指针"><a href="#2-weak-ptr：弱引用智能指针" class="headerlink" title="2. weak_ptr：弱引用智能指针"></a>2. weak_ptr：弱引用智能指针</h2><h3 id="2-1-核心概念与定义"><a href="#2-1-核心概念与定义" class="headerlink" title="2.1 核心概念与定义"></a>2.1 核心概念与定义</h3><h4 id="2-1-1-什么是-weak-ptr"><a href="#2-1-1-什么是-weak-ptr" class="headerlink" title="2.1.1 什么是 weak_ptr"></a>2.1.1 什么是 weak_ptr</h4><p><code>std::weak_ptr</code> 是一种不控制对象生命周期的智能指针，它是对由 <code>shared_ptr</code> 管理的对象的<strong>弱引用</strong>。<code>weak_ptr</code> 不会增加对象的引用计数，因此不会阻止对象的销毁。</p><h4 id="2-1-2-弱引用语义"><a href="#2-1-2-弱引用语义" class="headerlink" title="2.1.2 弱引用语义"></a>2.1.2 弱引用语义</h4><p><code>weak_ptr</code> 的主要用途是打破 <code>shared_ptr</code> 的循环引用问题。它允许观察一个对象而不影响其生命周期。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;MyClass&gt; shared = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line">std::weak_ptr&lt;MyClass&gt; weak = shared; <span class="comment">// 不增加引用计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象可能已被销毁，需要检查</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> locked = weak.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">    <span class="comment">// 对象还存在，可以安全使用</span></span><br><span class="line">    locked-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-内部实现机制"><a href="#2-2-内部实现机制" class="headerlink" title="2.2 内部实现机制"></a>2.2 内部实现机制</h3><h4 id="2-2-1-与控制块的交互"><a href="#2-2-1-与控制块的交互" class="headerlink" title="2.2.1 与控制块的交互"></a>2.2.1 与控制块的交互</h4><p><code>weak_ptr</code> 内部也包含指向控制块的指针，但它只操作弱引用计数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">weak_ptr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_;</span><br><span class="line">    control_block* cb_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造时增加弱引用计数</span></span><br><span class="line">    <span class="built_in">weak_ptr</span>(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; other) : <span class="built_in">ptr_</span>(other.ptr_), <span class="built_in">cb_</span>(other.cb_) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cb_) cb_-&gt;weak_count.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构时减少弱引用计数</span></span><br><span class="line">    ~<span class="built_in">weak_ptr</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (cb_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cb_-&gt;weak_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 弱引用计数为0，但强引用计数可能不为0</span></span><br><span class="line">                <span class="keyword">if</span> (cb_-&gt;use_count.<span class="built_in">load</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">delete</span> cb_; <span class="comment">// 强引用和弱引用都为0，删除控制块</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-3-常用接口与用法"><a href="#2-3-常用接口与用法" class="headerlink" title="2.3 常用接口与用法"></a>2.3 常用接口与用法</h3><h4 id="2-3-1-基本操作"><a href="#2-3-1-基本操作" class="headerlink" title="2.3.1 基本操作"></a>2.3.1 基本操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;MyClass&gt; shared = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line">std::weak_ptr&lt;MyClass&gt; weak = shared;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查对象是否还存在</span></span><br><span class="line"><span class="keyword">if</span> (!weak.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">    <span class="comment">// 尝试获取 shared_ptr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> locked = weak.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">        locked-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接获取 shared_ptr（如果对象已销毁则返回空）</span></span><br><span class="line">std::shared_ptr&lt;MyClass&gt; locked = weak.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (locked) &#123;</span><br><span class="line">    <span class="comment">// 安全使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-解决循环引用问题"><a href="#2-3-2-解决循环引用问题" class="headerlink" title="2.3.2 解决循环引用问题"></a>2.3.2 解决循环引用问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="comment">// 使用 weak_ptr 避免循环引用</span></span><br><span class="line">    std::weak_ptr&lt;Node&gt; parent;</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;Node&gt;&gt; children;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">const</span> std::string&amp; n) : <span class="built_in">name</span>(n) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addChild</span><span class="params">(std::shared_ptr&lt;Node&gt; child)</span> </span>&#123;</span><br><span class="line">        children.<span class="built_in">push_back</span>(child);</span><br><span class="line">        child-&gt;parent = <span class="built_in">weak_from_this</span>(); <span class="comment">// C++17 新增</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> node1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;(<span class="string">&quot;parent&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> node2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;(<span class="string">&quot;child&quot;</span>);</span><br><span class="line">node1-&gt;<span class="built_in">addChild</span>(node2); <span class="comment">// 不会造成循环引用</span></span><br></pre></td></tr></table></figure><h3 id="2-4-实际应用场景"><a href="#2-4-实际应用场景" class="headerlink" title="2.4 实际应用场景"></a>2.4 实际应用场景</h3><h4 id="2-4-1-观察者模式"><a href="#2-4-1-观察者模式" class="headerlink" title="2.4.1 观察者模式"></a>2.4.1 观察者模式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(std::weak_ptr&lt;Subject&gt; subject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::weak_ptr&lt;Observer&gt;&gt; observers_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(std::weak_ptr&lt;Observer&gt; observer)</span> </span>&#123;</span><br><span class="line">        observers_.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = observers_.<span class="built_in">begin</span>(); it != observers_.<span class="built_in">end</span>();) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> observer = it-&gt;<span class="built_in">lock</span>()) &#123;</span><br><span class="line">                observer-&gt;<span class="built_in">update</span>(<span class="built_in">weak_from_this</span>());</span><br><span class="line">                ++it;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 观察者已被销毁，移除</span></span><br><span class="line">                it = observers_.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-4-2-缓存系统优化"><a href="#2-4-2-缓存系统优化" class="headerlink" title="2.4.2 缓存系统优化"></a>2.4.2 缓存系统优化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CacheWithWeakPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, std::weak_ptr&lt;Data&gt;&gt; cache_;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mutex_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Data&gt; <span class="title">get</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> it = cache_.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it != cache_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> data = it-&gt;second.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> data; <span class="comment">// 对象还存在</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cache_.<span class="built_in">erase</span>(it); <span class="comment">// 对象已被销毁，清理缓存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-auto-ptr：已废弃的智能指针"><a href="#3-auto-ptr：已废弃的智能指针" class="headerlink" title="3. auto_ptr：已废弃的智能指针"></a>3. auto_ptr：已废弃的智能指针</h2><h3 id="3-1-历史背景与设计缺陷"><a href="#3-1-历史背景与设计缺陷" class="headerlink" title="3.1 历史背景与设计缺陷"></a>3.1 历史背景与设计缺陷</h3><h4 id="3-1-1-auto-ptr-的起源"><a href="#3-1-1-auto-ptr-的起源" class="headerlink" title="3.1.1 auto_ptr 的起源"></a>3.1.1 auto_ptr 的起源</h4><p><code>std::auto_ptr</code> 是 C++98 标准中引入的第一个智能指针，旨在提供基本的自动内存管理功能。它在当时是一个重要的创新，但后来被发现存在严重的设计缺陷。</p><h4 id="3-1-2-主要设计缺陷"><a href="#3-1-2-主要设计缺陷" class="headerlink" title="3.1.2 主要设计缺陷"></a>3.1.2 主要设计缺陷</h4><ol><li><strong>有问题的拷贝语义</strong>：<code>auto_ptr</code> 的拷贝操作会转移所有权</li><li><strong>不适用于标准库容器</strong>：由于非常规的拷贝语义，不能安全地在 STL 容器中使用</li><li><strong>缺乏移动语义支持</strong>：在 C++11 之前，没有移动语义，导致 awkward 的所有权转移</li></ol><h3 id="3-2-问题示例与缺陷分析"><a href="#3-2-问题示例与缺陷分析" class="headerlink" title="3.2 问题示例与缺陷分析"></a>3.2 问题示例与缺陷分析</h3><h4 id="3-2-1-危险的所有权转移"><a href="#3-2-1-危险的所有权转移" class="headerlink" title="3.2.1 危险的所有权转移"></a>3.2.1 危险的所有权转移</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98/03 中的 auto_ptr（已废弃）</span></span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">std::auto_ptr&lt;<span class="type">int</span>&gt; p2 = p1; <span class="comment">// p1 变为空，所有权转移到 p2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 意外行为：p1 现在为空，但代码可能继续使用它</span></span><br><span class="line"><span class="keyword">if</span> (p1.<span class="built_in">get</span>()) &#123; <span class="comment">// 这个条件为 false</span></span><br><span class="line">    *p1 = <span class="number">100</span>; <span class="comment">// 未定义行为！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-与-STL-容器的不兼容"><a href="#3-2-2-与-STL-容器的不兼容" class="headerlink" title="3.2.2 与 STL 容器的不兼容"></a>3.2.2 与 STL 容器的不兼容</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::auto_ptr&lt;<span class="type">int</span>&gt;&gt; vec; <span class="comment">// 危险的用法！</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">vec.<span class="built_in">push_back</span>(p); <span class="comment">// p 的所有权转移到 vector 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 p 为空，但代码可能不知道</span></span><br><span class="line"><span class="keyword">if</span> (p.<span class="built_in">get</span>()) &#123; <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// 永远不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-从-auto-ptr-到-unique-ptr-的演进"><a href="#3-3-从-auto-ptr-到-unique-ptr-的演进" class="headerlink" title="3.3 从 auto_ptr 到 unique_ptr 的演进"></a>3.3 从 auto_ptr 到 unique_ptr 的演进</h3><h4 id="3-3-1-为什么-unique-ptr-更好"><a href="#3-3-1-为什么-unique-ptr-更好" class="headerlink" title="3.3.1 为什么 unique_ptr 更好"></a>3.3.1 为什么 unique_ptr 更好</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unique_ptr 的明确语义</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="comment">// std::unique_ptr&lt;int&gt; p2 = p1; // 编译错误！防止意外拷贝</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p2 = std::<span class="built_in">move</span>(p1); <span class="comment">// 明确的移动语义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以安全地在容器中使用</span></span><br><span class="line">std::vector&lt;std::unique_ptr&lt;<span class="type">int</span>&gt;&gt; vec;</span><br><span class="line">vec.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>)); <span class="comment">// 必须显式移动</span></span><br></pre></td></tr></table></figure><h4 id="3-3-2-迁移指南"><a href="#3-3-2-迁移指南" class="headerlink" title="3.3.2 迁移指南"></a>3.3.2 迁移指南</h4><p>如果遇到旧的 <code>auto_ptr</code> 代码，应该迁移到 <code>unique_ptr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧的 auto_ptr 代码</span></span><br><span class="line"><span class="function">std::auto_ptr&lt;MyClass&gt; <span class="title">old_ptr</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迁移到 unique_ptr</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;MyClass&gt; <span class="title">new_ptr</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于函数参数和返回值</span></span><br><span class="line"><span class="function">std::auto_ptr&lt;MyClass&gt; <span class="title">create_old</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">auto_ptr</span>&lt;MyClass&gt;(<span class="keyword">new</span> <span class="built_in">MyClass</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;MyClass&gt; <span class="title">create_new</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MyClass&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-现代替代方案总结"><a href="#3-4-现代替代方案总结" class="headerlink" title="3.4 现代替代方案总结"></a>3.4 现代替代方案总结</h3><table><thead><tr><th>特性</th><th>auto_ptr (已废弃)</th><th>unique_ptr</th><th>shared_ptr</th><th>weak_ptr</th></tr></thead><tbody><tr><td>所有权模型</td><td>转移所有权</td><td>独占所有权</td><td>共享所有权</td><td>弱引用</td></tr><tr><td>拷贝语义</td><td>转移所有权（危险）</td><td>禁止拷贝</td><td>共享所有权</td><td>不增加引用计数</td></tr><tr><td>移动语义</td><td>无（C++98）</td><td>支持移动</td><td>支持移动</td><td>支持移动</td></tr><tr><td>容器兼容性</td><td>不兼容</td><td>兼容（需移动）</td><td>兼容</td><td>兼容</td></tr><tr><td>线程安全</td><td>无</td><td>无（但可单独保护）</td><td>引用计数原子操作</td><td>原子操作</td></tr><tr><td>推荐使用</td><td>不应使用</td><td>独占资源</td><td>共享资源</td><td>打破循环引用</td></tr></tbody></table><h2 id="4-智能指针的最佳实践与陷阱"><a href="#4-智能指针的最佳实践与陷阱" class="headerlink" title="4. 智能指针的最佳实践与陷阱"></a>4. 智能指针的最佳实践与陷阱</h2><h3 id="4-1-选择正确的智能指针"><a href="#4-1-选择正确的智能指针" class="headerlink" title="4.1 选择正确的智能指针"></a>4.1 选择正确的智能指针</h3><h4 id="4-1-1-决策流程"><a href="#4-1-1-决策流程" class="headerlink" title="4.1.1 决策流程"></a>4.1.1 决策流程</h4><ol><li><p><strong>是否需要共享所有权？</strong></p><ul><li>否 → 使用 <code>unique_ptr</code></li><li>是 → 使用 <code>shared_ptr</code></li></ul></li><li><p><strong>是否需要观察而不拥有？</strong></p><ul><li>是 → 配合使用 <code>weak_ptr</code></li></ul></li><li><p><strong>是否有循环引用风险？</strong></p><ul><li>是 → 使用 <code>weak_ptr</code> 打破循环</li></ul></li></ol><h4 id="4-1-2-使用场景总结"><a href="#4-1-2-使用场景总结" class="headerlink" title="4.1.2 使用场景总结"></a>4.1.2 使用场景总结</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 独占资源 - unique_ptr</span></span><br><span class="line">std::unique_ptr&lt;File&gt; file = <span class="built_in">openFile</span>(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 共享资源 - shared_ptr</span></span><br><span class="line">std::shared_ptr&lt;Database&gt; db = std::<span class="built_in">make_shared</span>&lt;Database&gt;();</span><br><span class="line"><span class="keyword">auto</span> user1 = <span class="built_in">User</span>(db);</span><br><span class="line"><span class="keyword">auto</span> user2 = <span class="built_in">User</span>(db); <span class="comment">// 共享数据库连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 观察资源 - weak_ptr</span></span><br><span class="line">std::shared_ptr&lt;Subject&gt; subject = std::<span class="built_in">make_shared</span>&lt;Subject&gt;();</span><br><span class="line">std::weak_ptr&lt;Subject&gt; observer = subject;</span><br></pre></td></tr></table></figure><h3 id="4-2-常见陷阱与解决方案"><a href="#4-2-常见陷阱与解决方案" class="headerlink" title="4.2 常见陷阱与解决方案"></a>4.2 常见陷阱与解决方案</h3><h4 id="4-2-1-循环引用问题"><a href="#4-2-1-循环引用问题" class="headerlink" title="4.2.1 循环引用问题"></a>4.2.1 循环引用问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：循环引用导致内存泄漏</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BadNode</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;BadNode&gt; parent; <span class="comment">// 应该使用 weak_ptr</span></span><br><span class="line">    std::shared_ptr&lt;BadNode&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确解决方案</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodNode</span> &#123;</span><br><span class="line">    std::weak_ptr&lt;GoodNode&gt; parent; <span class="comment">// 使用 weak_ptr 打破循环</span></span><br><span class="line">    std::shared_ptr&lt;GoodNode&gt; child;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-避免原始指针与智能指针混用"><a href="#4-2-2-避免原始指针与智能指针混用" class="headerlink" title="4.2.2 避免原始指针与智能指针混用"></a>4.2.2 避免原始指针与智能指针混用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 危险的做法</span></span><br><span class="line">MyClass* raw_ptr = <span class="keyword">new</span> <span class="built_in">MyClass</span>();</span><br><span class="line"><span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">ptr1</span><span class="params">(raw_ptr)</span></span>;</span><br><span class="line"><span class="comment">// std::shared_ptr&lt;MyClass&gt; ptr2(raw_ptr); // 灾难！双重删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全的做法</span></span><br><span class="line">std::shared_ptr&lt;MyClass&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line">std::shared_ptr&lt;MyClass&gt; ptr2 = ptr1; <span class="comment">// 共享所有权</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-this-指针问题"><a href="#4-2-3-this-指针问题" class="headerlink" title="4.2.3 this 指针问题"></a>4.2.3 this 指针问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;MyClass&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">get_shared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>(); <span class="comment">// 安全地获取 shared_ptr</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：直接从 this 创建 shared_ptr</span></span><br><span class="line"><span class="comment">// std::shared_ptr&lt;MyClass&gt; bad_ptr(this);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：使用 enable_shared_from_this</span></span><br><span class="line"><span class="keyword">auto</span> obj = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line"><span class="keyword">auto</span> good_ptr = obj-&gt;<span class="built_in">get_shared</span>();</span><br></pre></td></tr></table></figure><h3 id="4-3-性能优化建议"><a href="#4-3-性能优化建议" class="headerlink" title="4.3 性能优化建议"></a>4.3 性能优化建议</h3><h4 id="4-3-1-优先使用-make-shared-和-make-unique"><a href="#4-3-1-优先使用-make-shared-和-make-unique" class="headerlink" title="4.3.1 优先使用 make_shared 和 make_unique"></a>4.3.1 优先使用 make_shared 和 make_unique</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐：两次内存分配</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：一次内存分配，更好的性能</span></span><br><span class="line">std::shared_ptr&lt;MyClass&gt; p2 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line">std::unique_ptr&lt;MyClass&gt; p3 = std::<span class="built_in">make_unique</span>&lt;MyClass&gt;();</span><br></pre></td></tr></table></figure><h4 id="4-3-2-避免不必要的-shared-ptr-拷贝"><a href="#4-3-2-避免不必要的-shared-ptr-拷贝" class="headerlink" title="4.3.2 避免不必要的 shared_ptr 拷贝"></a>4.3.2 避免不必要的 shared_ptr 拷贝</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的做法：不必要的拷贝</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Data&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不需要共享所有权，应该传引用</span></span><br><span class="line">    data-&gt;<span class="built_in">process</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的做法：根据需求选择参数类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_by_ref</span><span class="params">(Data&amp; data)</span> </span>&#123; <span class="comment">// 不需要所有权</span></span><br><span class="line">    data.<span class="built_in">process</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_by_shared</span><span class="params">(std::shared_ptr&lt;Data&gt; data)</span> </span>&#123; <span class="comment">// 需要共享所有权</span></span><br><span class="line">    data-&gt;<span class="built_in">process</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过理解和正确应用这些智能指针，可以编写出更安全、更高效的 C++ 代码，避免常见的内存管理错误。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;C-智能指针详解：shared-ptr-auto-ptr-和-weak-ptr&quot;&gt;&lt;a href=&quot;#C-智能指针详解：shared-ptr-auto-ptr-和-weak-ptr&quot; class=&quot;headerlink&quot; title=&quot;C++ 智能指针详解：shared_ptr, auto_ptr 和 weak_ptr&quot;&gt;&lt;/a&gt;C++ 智能指针详解：shared_ptr, auto_ptr 和 weak_ptr&lt;/h1&gt;&lt;h2 id=&quot;1-shared-ptr：共享所有权智能指针&quot;&gt;&lt;a href=&quot;#1-shared-ptr：共享所有权智能指针&quot; class=&quot;headerlink&quot; title=&quot;1. shared_ptr：共享所有权智能指针&quot;&gt;&lt;/a&gt;1. shared_ptr：共享所有权智能指针&lt;/h2&gt;&lt;h3 id=&quot;1-1-核心概念与定义&quot;&gt;&lt;a href=&quot;#1-1-核心概念与定义&quot; class=&quot;headerlink&quot; title=&quot;1.1 核心概念与定义&quot;&gt;&lt;/a&gt;1.1 核心概念与定义&lt;/h3&gt;&lt;h4 id=&quot;1-1-1-什么是-shared-ptr&quot;&gt;&lt;a href=&quot;#1-1-1-什么是-shared-ptr&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 什么是 shared_ptr&quot;&gt;&lt;/a&gt;1.1.1 什么是 shared_ptr&lt;/h4&gt;&lt;p&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt; 是 C++11 引入的共享所有权智能指针，它通过&lt;strong&gt;引用计数（Reference Counting）&lt;/strong&gt; 机制实现多个智能指针共享同一个对象的所有权。与 &lt;code&gt;unique_ptr&lt;/code&gt; 的独占所有权不同，&lt;code&gt;shared_ptr&lt;/code&gt; 允许多个指针实例共同管理同一个动态分配的对象。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://lyroom.github.io/tags/C/"/>
    
    <category term="智能指针" scheme="https://lyroom.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
    <category term="shared_ptr" scheme="https://lyroom.github.io/tags/shared-ptr/"/>
    
    <category term="auto_ptr" scheme="https://lyroom.github.io/tags/auto-ptr/"/>
    
    <category term="weak_ptr" scheme="https://lyroom.github.io/tags/weak-ptr/"/>
    
  </entry>
  
  <entry>
    <title>详解 C++ unique_ptr：独占式智能指针</title>
    <link href="https://lyroom.github.io/2025/09/23/%E8%AF%A6%E8%A7%A3-C-unique-ptr%EF%BC%9A%E7%8B%AC%E5%8D%A0%E5%BC%8F%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>https://lyroom.github.io/2025/09/23/%E8%AF%A6%E8%A7%A3-C-unique-ptr%EF%BC%9A%E7%8B%AC%E5%8D%A0%E5%BC%8F%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2025-09-23T00:18:46.000Z</published>
    <updated>2025-09-23T00:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="详解-C-unique-ptr：独占式智能指针"><a href="#详解-C-unique-ptr：独占式智能指针" class="headerlink" title="详解 C++ unique_ptr：独占式智能指针"></a>详解 C++ unique_ptr：独占式智能指针</h1><h2 id="1-unique-ptr-的核心概念与定义"><a href="#1-unique-ptr-的核心概念与定义" class="headerlink" title="1. unique_ptr 的核心概念与定义"></a>1. unique_ptr 的核心概念与定义</h2><h3 id="1-1-什么是-unique-ptr"><a href="#1-1-什么是-unique-ptr" class="headerlink" title="1.1 什么是 unique_ptr"></a>1.1 什么是 unique_ptr</h3><p><code>std::unique_ptr</code> 是 C++11 标准库中引入的一种智能指针，其核心设计目标是提供一种对动态分配对象的<strong>独占所有权（Exclusive Ownership）</strong> 管理机制。</p><span id="more"></span><p>与原始指针（raw pointer）不同，<code>unique_ptr</code> 遵循 <strong>RAII（Resource Acquisition Is Initialization，资源获取即初始化）</strong> 原则，确保其管理的内存在其生命周期结束时能够被自动、可靠地释放，从而有效防止了内存泄漏、悬空指针等常见的内存管理错误。</p><p><code>unique_ptr</code> 对象本身是一个轻量级的封装，它在大多数情况下与原始指针具有相同的性能开销，但提供了更强的安全保障和更清晰的语义。它通过禁止拷贝操作，只允许移动操作，来强制实现所有权的唯一性，即在任何时刻，只有一个 <code>unique_ptr</code> 可以拥有并负责释放一个特定的对象。</p><h4 id="1-1-1-独占所有权语义"><a href="#1-1-1-独占所有权语义" class="headerlink" title="1.1.1 独占所有权语义"></a>1.1.1 独占所有权语义</h4><p><code>unique_ptr</code> 的”独占所有权”是其最核心的特性。这意味着一个 <code>unique_ptr</code> 对象对其所指向的资源拥有唯一的控制权。当 <code>unique_ptr</code> 被销毁时（例如，离开其作用域），它所管理的对象也会被自动销毁。</p><p>这种机制确保了资源的释放是确定性的，并且与 <code>unique_ptr</code> 的生命周期紧密绑定。为了实现这种独占性，<code>unique_ptr</code> 明确禁止了拷贝构造函数和拷贝赋值运算符。任何试图复制一个 <code>unique_ptr</code> 的操作都会导致编译错误。</p><p>然而，所有权是可以被<strong>转移（Transfer）</strong> 的。C++11 引入的<strong>移动语义（Move Semantics）</strong> 为 <code>unique_ptr</code> 提供了完美的支持。通过 <code>std::move()</code>，可以将一个 <code>unique_ptr</code> 的所有权转移给另一个 <code>unique_ptr</code>，而原指针则会被置为空（<code>nullptr</code>），不再拥有任何资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="comment">// std::unique_ptr&lt;int&gt; ptr2 = ptr1; // 错误：拷贝构造函数被删除</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr1); <span class="comment">// 合法：所有权从 ptr1 转移到 ptr2</span></span><br><span class="line"><span class="comment">// 此时 ptr1 为 nullptr，ptr2 拥有对 int(42) 的所有权</span></span><br></pre></td></tr></table></figure><p>这种所有权的转移机制，使得 <code>unique_ptr</code> 在函数参数传递和返回值中非常有用，可以清晰地表达所有权的转移意图。</p><h4 id="1-1-2-RAII（资源获取即初始化）原则的体现"><a href="#1-1-2-RAII（资源获取即初始化）原则的体现" class="headerlink" title="1.1.2 RAII（资源获取即初始化）原则的体现"></a>1.1.2 RAII（资源获取即初始化）原则的体现</h4><p><code>unique_ptr</code> 是 <strong>RAII（Resource Acquisition Is Initialization）</strong> 原则的绝佳范例。RAII 是一种编程范式，它将资源的生命周期与对象的生命周期绑定。</p><p>资源（如内存、文件句柄、锁等）在对象的构造函数中获取，并在对象的析构函数中释放。<code>unique_ptr</code> 完美地遵循了这一原则：当通过 <code>new</code> 创建一个对象并用其初始化 <code>unique_ptr</code> 时，资源被获取；当 <code>unique_ptr</code> 对象离开其作用域并被销毁时，其析构函数会自动调用，从而释放所管理的资源。</p><p>这种机制极大地简化了资源管理，尤其是在处理异常时。即使在函数执行过程中抛出异常，导致函数提前退出，局部作用域中的 <code>unique_ptr</code> 对象依然会被正确销毁，其管理的资源也会被安全释放，从而避免了因异常处理不当而导致的资源泄漏。</p><h4 id="1-1-3-与原始指针的区别与优势"><a href="#1-1-3-与原始指针的区别与优势" class="headerlink" title="1.1.3 与原始指针的区别与优势"></a>1.1.3 与原始指针的区别与优势</h4><p>与原始指针相比，<code>unique_ptr</code> 提供了显著的优势：</p><ul><li><strong>安全性</strong>：原始指针需要程序员手动调用 <code>delete</code> 来释放内存，这极易出错，容易导致内存泄漏（忘记 <code>delete</code>）或悬空指针（<code>delete</code> 后继续使用）。<code>unique_ptr</code> 通过自动管理内存，从根本上消除了这类问题。</li><li><strong>清晰的语义</strong>：通过其独占所有权的特性，代码的意图变得更加明确：一个 <code>unique_ptr</code> 明确表示它拥有并负责释放该对象。这使得代码更易于理解和维护。</li><li><strong>扩展性</strong>：<code>unique_ptr</code> 还支持自定义删除器，使其能够管理不仅仅是通过 <code>new</code> 分配的资源，例如文件句柄、网络连接等，进一步扩展了其应用范围。</li><li><strong>性能</strong>：尽管 <code>unique_ptr</code> 提供了这些额外的功能，但其性能开销极小，在大多数情况下与原始指针相当。</li></ul><table><thead><tr><th>特性</th><th>原始指针 (T*)</th><th>std::unique_ptr<T></th></tr></thead><tbody><tr><td>所有权</td><td>不明确，需要程序员手动管理</td><td>独占所有权，通过移动语义转移</td></tr><tr><td>生命周期</td><td>不明确，需要手动 delete</td><td>与 unique_ptr 对象的生命周期绑定，自动释放</td></tr><tr><td>内存泄漏风险</td><td>高，容易忘记 delete</td><td>无，自动释放</td></tr><tr><td>悬垂指针风险</td><td>高，delete 后指针仍有效</td><td>低，释放后 unique_ptr 变为 nullptr</td></tr><tr><td>重复释放风险</td><td>高，可能多次 delete 同一指针</td><td>无，所有权唯一</td></tr><tr><td>拷贝</td><td>支持浅拷贝，可能导致多个指针指向同一资源</td><td>不支持拷贝，仅支持移动</td></tr><tr><td>大小</td><td>与平台指针大小相同</td><td>通常与原始指针大小相同（得益于空基类优化）</td></tr><tr><td>自定义删除器</td><td>需要手动调用</td><td>支持在模板参数中指定</td></tr></tbody></table><h3 id="1-2-模板类定义与参数"><a href="#1-2-模板类定义与参数" class="headerlink" title="1.2 模板类定义与参数"></a>1.2 模板类定义与参数</h3><p><code>std::unique_ptr</code> 是一个类模板，其定义位于 <code>&lt;memory&gt;</code> 头文件中。它有两种形式：一种用于管理单个对象，另一种用于管理动态分配的数组。</p><h4 id="1-2-1-模板参数-T：被管理的对象类型"><a href="#1-2-1-模板参数-T：被管理的对象类型" class="headerlink" title="1.2.1 模板参数 T：被管理的对象类型"></a>1.2.1 模板参数 T：被管理的对象类型</h4><p>第一个模板参数 <code>T</code> 指定了 <code>unique_ptr</code> 所管理的对象的类型。例如，<code>std::unique_ptr&lt;int&gt;</code> 管理一个 <code>int</code> 类型的对象，而 <code>std::unique_ptr&lt;MyClass&gt;</code> 则管理一个 <code>MyClass</code> 类型的对象。</p><p>在 <code>unique_ptr</code> 的内部，这个类型被别名为 <code>element_type</code>。对于数组特化版本 <code>unique_ptr&lt;T[]&gt;</code>，<code>T</code> 表示数组元素的类型。</p><p>需要注意的是，如果 <code>T</code> 是一个引用类型，那么实例化 <code>unique_ptr&lt;T&gt;</code> 的程序是格式错误的。</p><h4 id="1-2-2-模板参数-Deleter：自定义删除器类型"><a href="#1-2-2-模板参数-Deleter：自定义删除器类型" class="headerlink" title="1.2.2 模板参数 Deleter：自定义删除器类型"></a>1.2.2 模板参数 Deleter：自定义删除器类型</h4><p>第二个模板参数 <code>Deleter</code> 是一个可选参数，用于指定一个可调用对象（函数对象或函数指针），该对象定义了如何销毁被管理的资源。这个类型在 <code>unique_ptr</code> 内部被别名为 <code>deleter_type</code>。</p><p>默认情况下，<code>Deleter</code> 是 <code>std::default_delete&lt;T&gt;</code>，它简单地调用 <code>delete</code> 来释放内存。然而，通过提供自定义的删除器，<code>unique_ptr</code> 可以管理任何需要特殊清理逻辑的资源。</p><p><code>Deleter</code> 必须是一个可调用对象，能够接受一个 <code>unique_ptr::pointer</code> 类型的参数。将 <code>Deleter</code> 作为模板参数是实现零开销抽象的关键，因为它允许编译器在编译时内联删除器的调用，从而避免了运行时的额外开销。</p><h4 id="1-2-3-默认删除器-std-default-delete"><a href="#1-2-3-默认删除器-std-default-delete" class="headerlink" title="1.2.3 默认删除器 std::default_delete"></a>1.2.3 默认删除器 std::default_delete<T></h4><p><code>std::default_delete&lt;T&gt;</code> 是 <code>unique_ptr</code> 的默认删除器。它是一个无状态的函数对象（functor），其 <code>operator()</code> 简单地调用 <code>delete</code> 来销毁其管理的对象。</p><p>对于数组特化版本 <code>unique_ptr&lt;T[]&gt;</code>，<code>default_delete&lt;T[]&gt;</code> 会调用 <code>delete[]</code> 来释放数组。</p><p><code>default_delete</code> 的设计非常高效，因为它是一个空类（empty class），不包含任何数据成员。这使得 <code>unique_ptr</code> 可以利用<strong>空基类优化（EBO）</strong> 技术，在不增加额外内存开销的情况下存储删除器。</p><p>当使用默认删除器时，<code>unique_ptr</code> 的大小通常与原始指针相同，保证了其轻量级的特性。</p><p>需要注意的是，如果使用 <code>default_delete</code>，被管理的类型 <code>T</code> 在 <code>unique_ptr</code> 的析构函数、移动赋值运算符和 <code>reset</code> 成员函数被实例化的地方必须是完整类型（complete type）。</p><h3 id="1-3-内部类型定义"><a href="#1-3-内部类型定义" class="headerlink" title="1.3 内部类型定义"></a>1.3 内部类型定义</h3><p>为了方便使用和提高代码的可读性，<code>unique_ptr</code> 定义了几个内部类型别名。</p><h4 id="1-3-1-element-type：被管理对象的类型别名"><a href="#1-3-1-element-type：被管理对象的类型别名" class="headerlink" title="1.3.1 element_type：被管理对象的类型别名"></a>1.3.1 element_type：被管理对象的类型别名</h4><p><code>element_type</code> 是模板参数 <code>T</code> 的别名。它代表了 <code>unique_ptr</code> 所管理的对象的类型。例如，在 <code>std::unique_ptr&lt;int&gt;</code> 中，<code>element_type</code> 就是 <code>int</code>。</p><p>这个别名在编写泛型代码时非常有用，因为它允许在不明确知道 <code>T</code> 的具体类型的情况下，引用被管理对象的类型。</p><h4 id="1-3-2-deleter-type：删除器的类型别名"><a href="#1-3-2-deleter-type：删除器的类型别名" class="headerlink" title="1.3.2 deleter_type：删除器的类型别名"></a>1.3.2 deleter_type：删除器的类型别名</h4><p><code>deleter_type</code> 是模板参数 <code>Deleter</code> 的别名。它代表了用于销毁被管理对象的删除器的类型。例如，在 <code>std::unique_ptr&lt;int, MyDeleter&gt;</code> 中，<code>deleter_type</code> 就是 <code>MyDeleter</code>。</p><p>这个别名同样有助于编写泛型代码，使得代码可以灵活地处理不同类型的删除器。</p><h4 id="1-3-3-pointer：指针类型别名"><a href="#1-3-3-pointer：指针类型别名" class="headerlink" title="1.3.3 pointer：指针类型别名"></a>1.3.3 pointer：指针类型别名</h4><p><code>pointer</code> 是一个更复杂的类型别名，它定义了 <code>unique_ptr</code> 内部使用的指针类型。它的定义如下：</p><ul><li>如果 <code>Deleter</code> 类型（去除引用后）有一个名为 <code>pointer</code> 的内部类型，那么 <code>unique_ptr::pointer</code> 就是这个类型。</li><li>否则，<code>pointer</code> 就是 <code>T*</code>。</li></ul><p>这个设计允许 <code>Deleter</code> 指定一个”智能”指针类型（例如，一个用于共享内存的偏移指针），而不仅仅是普通的 <code>T*</code>。这使得 <code>unique_ptr</code> 能够与更广泛的资源管理方案集成。</p><p><code>pointer</code> 类型必须满足 <code>NullablePointer</code> 的要求，这意味着它可以被默认构造、与 <code>nullptr</code> 进行比较，并且可以像原始指针一样使用。</p><h2 id="2-unique-ptr-的常用接口与用法"><a href="#2-unique-ptr-的常用接口与用法" class="headerlink" title="2. unique_ptr 的常用接口与用法"></a>2. unique_ptr 的常用接口与用法</h2><p><code>unique_ptr</code> 提供了一套丰富的接口，用于管理其生命周期和所有权。这些接口的设计旨在提供安全、高效且直观的资源管理方式。</p><h3 id="2-1-构造与析构"><a href="#2-1-构造与析构" class="headerlink" title="2.1 构造与析构"></a>2.1 构造与析构</h3><p><code>unique_ptr</code> 的构造函数和析构函数是其资源管理功能的核心。</p><h4 id="2-1-1-默认构造函数：创建空的-unique-ptr"><a href="#2-1-1-默认构造函数：创建空的-unique-ptr" class="headerlink" title="2.1.1 默认构造函数：创建空的 unique_ptr"></a>2.1.1 默认构造函数：创建空的 unique_ptr</h4><p><code>unique_ptr</code> 的默认构造函数创建一个不拥有任何对象的 <code>unique_ptr</code>，其内部指针被初始化为 <code>nullptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr; <span class="comment">// ptr 不管理任何对象，get() 返回 nullptr</span></span><br></pre></td></tr></table></figure><p>这个构造函数是 <code>noexcept</code> 的，并且要求删除器类型 <code>Deleter</code> 是可默认构造的，且其构造过程不抛出异常。</p><p>此外，<code>unique_ptr</code> 还有一个接受 <code>std::nullptr_t</code> 的构造函数，其效果与默认构造函数相同，这使得 <code>unique_ptr</code> 可以被显式地初始化为 <code>nullptr</code>。</p><h4 id="2-1-2-带指针的构造函数：接管原始指针"><a href="#2-1-2-带指针的构造函数：接管原始指针" class="headerlink" title="2.1.2 带指针的构造函数：接管原始指针"></a>2.1.2 带指针的构造函数：接管原始指针</h4><p><code>unique_ptr</code> 提供了一个显式的构造函数，用于从一个原始指针接管所有权。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">// ptr 现在拥有这个 int 对象</span></span><br></pre></td></tr></table></figure><p>这个构造函数将传入的指针存储在 <code>unique_ptr</code> 内部，并负责在析构时释放它。这个构造函数也是 <code>noexcept</code> 的，并且要求删除器是可默认构造的。</p><p>需要注意的是，一旦将一个原始指针交给 <code>unique_ptr</code> 管理，就不应该再手动 <code>delete</code> 它，也不应该再使用这个原始指针，因为 <code>unique_ptr</code> 会在其生命周期结束时自动处理释放。</p><h4 id="2-1-3-移动构造函数：转移所有权"><a href="#2-1-3-移动构造函数：转移所有权" class="headerlink" title="2.1.3 移动构造函数：转移所有权"></a>2.1.3 移动构造函数：转移所有权</h4><p><code>unique_ptr</code> 的核心特性之一是其移动语义。它提供了移动构造函数，允许将所有权从一个 <code>unique_ptr</code> 转移给另一个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(std::move(ptr1))</span></span>; <span class="comment">// 所有权从 ptr1 转移到 ptr2</span></span><br><span class="line"><span class="comment">// 现在 ptr1 为 nullptr，ptr2 拥有该对象</span></span><br></pre></td></tr></table></figure><p>移动构造函数是 <code>noexcept</code> 的，并且要求删除器是可移动构造的（如果 <code>Deleter</code> 不是引用类型）。</p><p>此外，<code>unique_ptr</code> 还支持从一个不同类型的 <code>unique_ptr</code> 进行移动构造，只要源指针类型可以隐式转换为目标指针类型，并且源删除器类型可以转换为目标删除器类型。这种跨类型的移动构造在处理继承层次结构时非常有用。</p><h4 id="2-1-4-析构函数：自动释放资源"><a href="#2-1-4-析构函数：自动释放资源" class="headerlink" title="2.1.4 析构函数：自动释放资源"></a>2.1.4 析构函数：自动释放资源</h4><p><code>unique_ptr</code> 的析构函数是其 RAII 机制的关键。当一个 <code>unique_ptr</code> 对象被销毁时，其析构函数会检查它是否拥有一个对象。如果拥有，析构函数会调用其存储的删除器来销毁该对象。</p><p>例如，对于默认删除器，它会调用 <code>delete</code>。析构函数要求 <code>get_deleter()(get())</code> 这个表达式是合法的，并且不会抛出异常。</p><p>这种自动释放机制确保了即使在发生异常的情况下，资源也能被正确清理，从而极大地提高了代码的健壮性。</p><h3 id="2-2-所有权管理核心接口"><a href="#2-2-所有权管理核心接口" class="headerlink" title="2.2 所有权管理核心接口"></a>2.2 所有权管理核心接口</h3><p><code>unique_ptr</code> 提供了一组核心接口，用于在不转移所有权的情况下观察和操作其管理的对象。</p><h4 id="2-2-1-get-：获取原始指针（不转移所有权）"><a href="#2-2-1-get-：获取原始指针（不转移所有权）" class="headerlink" title="2.2.1 get()：获取原始指针（不转移所有权）"></a>2.2.1 get()：获取原始指针（不转移所有权）</h4><p><code>get()</code> 成员函数返回 <code>unique_ptr</code> 内部存储的原始指针，但不会转移所有权。调用 <code>get()</code> 后，<code>unique_ptr</code> 仍然拥有该对象，并将在其析构时负责释放它。</p><p>这个函数通常用于需要与只接受原始指针的旧版 API 进行交互的场景。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="type">int</span>* raw_ptr = ptr.<span class="built_in">get</span>(); <span class="comment">// raw_ptr 指向该对象，但 ptr 仍然拥有它</span></span><br><span class="line"><span class="comment">// 不要对 raw_ptr 调用 delete</span></span><br></pre></td></tr></table></figure><p><code>get()</code> 是 <code>noexcept</code> 的，并且返回的指针类型是 <code>unique_ptr::pointer</code>。</p><h4 id="2-2-2-release-：释放所有权并返回原始指针"><a href="#2-2-2-release-：释放所有权并返回原始指针" class="headerlink" title="2.2.2 release()：释放所有权并返回原始指针"></a>2.2.2 release()：释放所有权并返回原始指针</h4><p><code>release()</code> 成员函数会断开 <code>unique_ptr</code> 与其管理对象之间的关联，并返回该对象的原始指针。调用 <code>release()</code> 后，<code>unique_ptr</code> 变为空（<code>get() == nullptr</code>），而调用者则获得了该对象的所有权，并需要负责在适当的时候手动释放它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="type">int</span>* raw_ptr = ptr.<span class="built_in">release</span>(); <span class="comment">// ptr 变为空，raw_ptr 现在拥有该对象</span></span><br><span class="line"><span class="comment">// 现在必须对 raw_ptr 调用 delete: delete raw_ptr;</span></span><br></pre></td></tr></table></figure><p><code>release()</code> 是 <code>noexcept</code> 的，它首先将内部指针设置为 <code>nullptr</code>，然后返回其先前的值。</p><p>这个函数在需要将所有权转移给一个不接受 <code>unique_ptr</code> 的函数或 API 时非常有用。</p><h4 id="2-2-3-reset-：重置管理的对象"><a href="#2-2-3-reset-：重置管理的对象" class="headerlink" title="2.2.3 reset()：重置管理的对象"></a>2.2.3 reset()：重置管理的对象</h4><p><code>reset()</code> 成员函数用于替换 <code>unique_ptr</code> 当前管理的对象。它首先会销毁当前管理的对象（如果存在），然后接管新传入的指针的所有权。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>)); <span class="comment">// 销毁旧的 int(42)，并管理新的 int(100)</span></span><br><span class="line">ptr.<span class="built_in">reset</span>(); <span class="comment">// 销毁 int(100)，并使 ptr 变为空</span></span><br></pre></td></tr></table></figure><p><code>reset()</code> 可以接受一个原始指针参数，也可以不带参数（默认为 <code>nullptr</code>）。如果传入的指针与当前管理的指针相同，<code>reset()</code> 会先存储新指针，然后删除旧指针，这可能导致传入的指针被立即删除。</p><p><code>reset()</code> 是 <code>noexcept</code> 的，并且要求删除器的调用不抛出异常。</p><h4 id="2-2-4-swap-：交换两个-unique-ptr-的管理对象"><a href="#2-2-4-swap-：交换两个-unique-ptr-的管理对象" class="headerlink" title="2.2.4 swap()：交换两个 unique_ptr 的管理对象"></a>2.2.4 swap()：交换两个 unique_ptr 的管理对象</h4><p><code>swap()</code> 成员函数用于交换两个 <code>unique_ptr</code> 对象的内容，包括它们管理的指针和删除器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">ptr1.<span class="built_in">swap</span>(ptr2); <span class="comment">// 现在 ptr1 管理 int(100)，ptr2 管理 int(42)</span></span><br></pre></td></tr></table></figure><p><code>swap()</code> 是 <code>noexcept</code> 的，并且通常具有常数时间复杂度。</p><p>此外，标准库还提供了一个非成员的 <code>swap</code> 函数模板，专门用于 <code>unique_ptr</code>，它也会调用成员 <code>swap</code> 函数。</p><h3 id="2-3-其他重要操作符与函数"><a href="#2-3-其他重要操作符与函数" class="headerlink" title="2.3 其他重要操作符与函数"></a>2.3 其他重要操作符与函数</h3><p>除了上述核心接口，<code>unique_ptr</code> 还提供了一些操作符和辅助函数，使其使用起来更像一个原始指针。</p><h4 id="2-3-1-operator-x3D-：移动赋值运算符"><a href="#2-3-1-operator-x3D-：移动赋值运算符" class="headerlink" title="2.3.1 operator&#x3D;：移动赋值运算符"></a>2.3.1 operator&#x3D;：移动赋值运算符</h4><p><code>unique_ptr</code> 提供了移动赋值运算符，允许将一个 <code>unique_ptr</code> 的所有权转移给另一个。与移动构造函数类似，它会销毁左侧 <code>unique_ptr</code> 当前管理的对象，然后接管右侧 <code>unique_ptr</code> 的所有权。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2;</span><br><span class="line">ptr2 = std::<span class="built_in">move</span>(ptr1); <span class="comment">// 所有权从 ptr1 转移到 ptr2</span></span><br><span class="line"><span class="comment">// 现在 ptr1 为 nullptr，ptr2 拥有该对象</span></span><br></pre></td></tr></table></figure><p>移动赋值运算符是 <code>noexcept</code> 的，并且要求删除器是可移动赋值的（如果 <code>Deleter</code> 不是引用类型）。</p><p>它还支持从一个不同类型的 <code>unique_ptr</code> 进行移动赋值，只要满足相应的类型转换要求。</p><h4 id="2-3-2-operator-与-operator-gt-：解引用操作"><a href="#2-3-2-operator-与-operator-gt-：解引用操作" class="headerlink" title="2.3.2 operator* 与 operator-&gt;：解引用操作"></a>2.3.2 operator* 与 operator-&gt;：解引用操作</h4><p>对于非数组版本的 <code>unique_ptr</code>，提供了 <code>operator*</code> 和 <code>operator-&gt;</code>，使其可以像原始指针一样进行解引用。</p><ul><li><code>operator*</code> 返回对所管理对象的引用。</li><li><code>operator-&gt;</code> 返回内部存储的原始指针，允许访问对象的成员。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;MyClass&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">ptr-&gt;<span class="built_in">doSomething</span>(); <span class="comment">// 调用 MyClass 的成员函数</span></span><br><span class="line">(*ptr).<span class="built_in">doSomething</span>(); <span class="comment">// 等价于上一行</span></span><br></pre></td></tr></table></figure><p>这些操作符使得 <code>unique_ptr</code> 的使用体验与原始指针非常相似，但提供了额外的安全保障。</p><h4 id="2-3-3-operator-bool：检查是否管理对象"><a href="#2-3-3-operator-bool：检查是否管理对象" class="headerlink" title="2.3.3 operator bool：检查是否管理对象"></a>2.3.3 operator bool：检查是否管理对象</h4><p><code>unique_ptr</code> 提供了一个转换到 <code>bool</code> 类型的操作符，用于检查其是否管理一个对象。如果 <code>unique_ptr</code> 不为空（即 <code>get() != nullptr</code>），则返回 <code>true</code>；否则返回 <code>false</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">    <span class="comment">// ptr 管理一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个操作符使得检查 <code>unique_ptr</code> 的状态变得非常直观和方便。</p><h4 id="2-3-4-get-deleter-：获取删除器"><a href="#2-3-4-get-deleter-：获取删除器" class="headerlink" title="2.3.4 get_deleter()：获取删除器"></a>2.3.4 get_deleter()：获取删除器</h4><p><code>get_deleter()</code> 成员函数返回一个对 <code>unique_ptr</code> 内部存储的删除器的引用。这允许在运行时访问和修改删除器的状态（如果删除器不是无状态的）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> deleter = [](<span class="type">int</span>* p) &#123; std::cout &lt;&lt; <span class="string">&quot;Deleting int\n&quot;</span>; <span class="keyword">delete</span> p; &#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>, <span class="title">decltype</span><span class="params">(deleter)</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>), deleter)</span></span>;</span><br><span class="line">ptr.<span class="built_in">get_deleter</span>()(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>)); <span class="comment">// 手动调用删除器</span></span><br></pre></td></tr></table></figure><p><code>get_deleter()</code> 有两个重载版本，一个返回非常量引用，另一个返回常量引用。</p><h2 id="3-unique-ptr-的内部实现逻辑"><a href="#3-unique-ptr-的内部实现逻辑" class="headerlink" title="3. unique_ptr 的内部实现逻辑"></a>3. unique_ptr 的内部实现逻辑</h2><p><code>unique_ptr</code> 的高效性和强大功能源于其精巧的内部实现，特别是其对空基类优化（EBO）的利用。</p><h3 id="3-1-核心数据结构"><a href="#3-1-核心数据结构" class="headerlink" title="3.1 核心数据结构"></a>3.1 核心数据结构</h3><p><code>unique_ptr</code> 的内部实现主要围绕两个核心数据成员：一个用于存储被管理对象的原始指针，另一个用于存储删除器。</p><h4 id="3-1-1-存储原始指针"><a href="#3-1-1-存储原始指针" class="headerlink" title="3.1.1 存储原始指针"></a>3.1.1 存储原始指针</h4><p><code>unique_ptr</code> 必须存储一个指向其管理对象的原始指针。这个指针的类型由 <code>unique_ptr::pointer</code> 定义，通常是 <code>T*</code>，但在使用自定义删除器时可能是其他类型。</p><p>这个指针是 <code>unique_ptr</code> 的核心，所有对管理对象的访问都通过这个指针进行。</p><h4 id="3-1-2-存储删除器"><a href="#3-1-2-存储删除器" class="headerlink" title="3.1.2 存储删除器"></a>3.1.2 存储删除器</h4><p><code>unique_ptr</code> 还需要存储其删除器。删除器的类型是 <code>Deleter</code>，它可以是任何可调用对象。</p><p>将删除器作为 <code>unique_ptr</code> 的一部分，使得 <code>unique_ptr</code> 能够灵活地管理各种需要特殊清理逻辑的资源。然而，如果删除器是一个有状态的、非空的对象，直接将其作为 <code>unique_ptr</code> 的成员会增加 <code>unique_ptr</code> 的大小，从而引入额外的内存开销。</p><p>为了解决这个问题，<code>unique_ptr</code> 采用了<strong>空基类优化</strong>技术。</p><h3 id="3-2-空基类优化（EBO）"><a href="#3-2-空基类优化（EBO）" class="headerlink" title="3.2 空基类优化（EBO）"></a>3.2 空基类优化（EBO）</h3><p><strong>空基类优化（Empty Base Optimization, EBO）</strong> 是 C++ 中一项重要的优化技术，它允许一个空类（即没有非静态数据成员的类）作为基类时，不占用任何额外的内存空间。<code>unique_ptr</code> 利用 EBO 来优化其内部存储，特别是当使用默认的无状态删除器时。</p><h4 id="3-2-1-压缩空指针（Compressed-Pair）技术"><a href="#3-2-1-压缩空指针（Compressed-Pair）技术" class="headerlink" title="3.2.1 压缩空指针（Compressed Pair）技术"></a>3.2.1 压缩空指针（Compressed Pair）技术</h4><p>为了实现 EBO，<code>unique_ptr</code> 的实现通常依赖于一个名为 <code>compressed_pair</code>（或类似名称）的内部辅助类。这个类模板旨在存储两个对象，并利用 EBO 来消除其中一个对象（如果它是空的）的存储开销。</p><p><code>compressed_pair</code> 的实现通常涉及模板特化和继承。它会检查两个模板参数的类型，如果其中一个类型是空的且不是 <code>final</code> 的，它就会将该类型作为基类，而另一个类型作为成员变量。这样，如果删除器是一个空类（如 <code>default_delete</code>），它就不会占用任何额外的内存空间。</p><h4 id="3-2-2-优化空删除器的存储开销"><a href="#3-2-2-优化空删除器的存储开销" class="headerlink" title="3.2.2 优化空删除器的存储开销"></a>3.2.2 优化空删除器的存储开销</h4><p>在 <code>unique_ptr</code> 的典型实现中，其唯一的成员变量是一个 <code>compressed_pair&lt;pointer, deleter_type&gt;</code>。当使用默认的 <code>default_delete&lt;T&gt;</code> 时，<code>deleter_type</code> 是一个空类。<code>compressed_pair</code> 会检测到这一点，并将 <code>deleter_type</code> 作为其基类。由于 EBO，这个基类不会增加 <code>compressed_pair</code> 的大小。</p><p>因此，<code>unique_ptr</code> 的最终大小就只有一个指针的大小，与原始指针完全相同，实现了<strong>零开销抽象</strong>。</p><p>这种优化是 <code>unique_ptr</code> 将 <code>Deleter</code> 作为模板参数而非构造函数参数的关键原因，也是其性能优于 <code>shared_ptr</code> 的重要因素之一。</p><h3 id="3-3-移动语义的实现"><a href="#3-3-移动语义的实现" class="headerlink" title="3.3 移动语义的实现"></a>3.3 移动语义的实现</h3><p><code>unique_ptr</code> 的独占所有权语义是通过禁用拷贝操作并启用移动操作来实现的。</p><h4 id="3-3-1-删除拷贝构造函数和拷贝赋值运算符"><a href="#3-3-1-删除拷贝构造函数和拷贝赋值运算符" class="headerlink" title="3.3.1 删除拷贝构造函数和拷贝赋值运算符"></a>3.3.1 删除拷贝构造函数和拷贝赋值运算符</h4><p>为了确保所有权的唯一性，<code>unique_ptr</code> 明确地将拷贝构造函数和拷贝赋值运算符声明为 <code>delete</code>。这意味着任何试图复制 <code>unique_ptr</code> 的代码都会在编译时失败，从而从根本上防止了所有权的共享。</p><h4 id="3-3-2-实现移动构造函数和移动赋值运算符"><a href="#3-3-2-实现移动构造函数和移动赋值运算符" class="headerlink" title="3.3.2 实现移动构造函数和移动赋值运算符"></a>3.3.2 实现移动构造函数和移动赋值运算符</h4><p><code>unique_ptr</code> 提供了移动构造函数和移动赋值运算符，它们允许将所有权从一个 <code>unique_ptr</code> 转移给另一个。这些函数的实现通常涉及以下步骤：</p><ol><li>从源 <code>unique_ptr</code> 中获取原始指针（通过 <code>release()</code>）。</li><li>将获取的指针存储到目标 <code>unique_ptr</code> 中。</li><li>将源 <code>unique_ptr</code> 的删除器移动或复制到目标 <code>unique_ptr</code> 中。</li><li>确保源 <code>unique_ptr</code> 在操作后变为空（<code>get() == nullptr</code>）。</li></ol><p>通过这种方式，<code>unique_ptr</code> 实现了所有权的明确转移，保证了在任何时候都只有一个 <code>unique_ptr</code> 实例负责管理一个特定的资源。</p><h2 id="4-unique-ptr-与-shared-ptr-的区别"><a href="#4-unique-ptr-与-shared-ptr-的区别" class="headerlink" title="4. unique_ptr 与 shared_ptr 的区别"></a>4. unique_ptr 与 shared_ptr 的区别</h2><p><code>unique_ptr</code> 和 <code>shared_ptr</code> 是 C++ 标准库中两种主要的智能指针，它们都用于自动管理动态分配的资源，但其底层所有权模型、性能和适用场景有显著不同。</p><h3 id="4-1-所有权模型对比"><a href="#4-1-所有权模型对比" class="headerlink" title="4.1 所有权模型对比"></a>4.1 所有权模型对比</h3><p>所有权模型是 <code>unique_ptr</code> 和 <code>shared_ptr</code> 最根本的区别。</p><h4 id="4-1-1-unique-ptr-的独占所有权"><a href="#4-1-1-unique-ptr-的独占所有权" class="headerlink" title="4.1.1 unique_ptr 的独占所有权"></a>4.1.1 unique_ptr 的独占所有权</h4><p><code>unique_ptr</code> 遵循<strong>独占所有权模型</strong>。在任何给定时刻，只有一个 <code>unique_ptr</code> 实例可以拥有一个特定的对象。当这个 <code>unique_ptr</code> 被销毁时，它所拥有的对象也会被销毁。</p><p>这种模型保证了资源释放的确定性和即时性。所有权的转移只能通过移动语义（<code>std::move</code>）来完成，这使得所有权的转移在代码中非常明确。</p><h4 id="4-1-2-shared-ptr-的共享所有权与引用计数"><a href="#4-1-2-shared-ptr-的共享所有权与引用计数" class="headerlink" title="4.1.2 shared_ptr 的共享所有权与引用计数"></a>4.1.2 shared_ptr 的共享所有权与引用计数</h4><p><code>shared_ptr</code> 遵循<strong>共享所有权模型</strong>。多个 <code>shared_ptr</code> 实例可以同时拥有同一个对象。为了跟踪有多少个 <code>shared_ptr</code> 正在共享一个对象，<code>shared_ptr</code> 内部使用了一个引用计数器。</p><p>每当一个新的 <code>shared_ptr</code> 被创建并指向该对象时，引用计数加一；每当一个 <code>shared_ptr</code> 被销毁或重置时，引用计数减一。当引用计数变为零时，意味着没有 <code>shared_ptr</code> 再拥有该对象，此时对象会被自动销毁。</p><p>这种模型提供了更大的灵活性，但也引入了额外的开销和潜在的循环引用问题。</p><h3 id="4-2-复制与移动语义对比"><a href="#4-2-复制与移动语义对比" class="headerlink" title="4.2 复制与移动语义对比"></a>4.2 复制与移动语义对比</h3><p>所有权模型的差异直接导致了两者在复制和移动语义上的不同。</p><h4 id="4-2-1-unique-ptr-仅支持移动"><a href="#4-2-1-unique-ptr-仅支持移动" class="headerlink" title="4.2.1 unique_ptr 仅支持移动"></a>4.2.1 unique_ptr 仅支持移动</h4><p><code>unique_ptr</code> 明确禁止拷贝，只支持移动。拷贝构造函数和拷贝赋值运算符被声明为 <code>delete</code>，以防止所有权的意外共享。移动操作则高效地转移所有权，源 <code>unique_ptr</code> 在操作后会变为空。</p><h4 id="4-2-2-shared-ptr-支持复制和移动"><a href="#4-2-2-shared-ptr-支持复制和移动" class="headerlink" title="4.2.2 shared_ptr 支持复制和移动"></a>4.2.2 shared_ptr 支持复制和移动</h4><p><code>shared_ptr</code> 既支持拷贝也支持移动。</p><ul><li><strong>拷贝</strong>：当一个 <code>shared_ptr</code> 被拷贝时，新的 <code>shared_ptr</code> 会与原 <code>shared_ptr</code> 共享同一个对象，并且引用计数会加一。</li><li><strong>移动</strong>：当一个 <code>shared_ptr</code> 被移动时，所有权会从源 <code>shared_ptr</code> 转移到目标 <code>shared_ptr</code>，源 <code>shared_ptr</code> 会变为空。与拷贝不同，移动操作不会修改引用计数，因此性能更高。</li></ul><h3 id="4-3-性能与开销对比"><a href="#4-3-性能与开销对比" class="headerlink" title="4.3 性能与开销对比"></a>4.3 性能与开销对比</h3><p>性能和开销是选择 <code>unique_ptr</code> 还是 <code>shared_ptr</code> 时需要考虑的重要因素。</p><h4 id="4-3-1-unique-ptr-的轻量级特性"><a href="#4-3-1-unique-ptr-的轻量级特性" class="headerlink" title="4.3.1 unique_ptr 的轻量级特性"></a>4.3.1 unique_ptr 的轻量级特性</h4><p><code>unique_ptr</code> 是一个非常轻量级的智能指针。在大多数情况下，它的大小与原始指针相同，因为它利用了空基类优化来消除无状态删除器的存储开销。</p><p>它的操作（如构造、析构、移动）通常与原始指针的操作一样高效，没有额外的运行时开销。</p><h4 id="4-3-2-shared-ptr-的引用计数开销"><a href="#4-3-2-shared-ptr-的引用计数开销" class="headerlink" title="4.3.2 shared_ptr 的引用计数开销"></a>4.3.2 shared_ptr 的引用计数开销</h4><p><code>shared_ptr</code> 的性能开销相对较大。这主要源于其内部的引用计数机制。</p><ul><li><strong>内存开销</strong>：<code>shared_ptr</code> 需要为每个管理的对象分配一个额外的控制块（control block）来存储引用计数和弱引用计数。这使得 <code>shared_ptr</code> 本身的大小通常是原始指针的两倍（一个指针指向对象，一个指针指向控制块）。</li><li><strong>运行时开销</strong>：引用计数的增减必须是原子操作，以保证线程安全。这些原子操作会带来一定的性能开销，尤其是在多线程环境下频繁创建和销毁 <code>shared_ptr</code> 时。</li></ul><table><thead><tr><th>特性</th><th>std::unique_ptr</th><th>std::shared_ptr</th></tr></thead><tbody><tr><td>所有权模型</td><td>独占所有权</td><td>共享所有权</td></tr><tr><td>复制语义</td><td>不支持（被删除）</td><td>支持（增加引用计数）</td></tr><tr><td>移动语义</td><td>支持（转移所有权）</td><td>支持（转移所有权，不增加计数）</td></tr><tr><td>内存开销</td><td>一个指针大小（轻量级）</td><td>两个指针大小 + 控制块（较重）</td></tr><tr><td>性能开销</td><td>极小</td><td>引用计数的原子操作开销</td></tr><tr><td>循环引用</td><td>不存在</td><td>可能导致内存泄漏（需配合 weak_ptr）</td></tr><tr><td>适用场景</td><td>独占资源、性能敏感、工厂函数</td><td>共享资源、复杂数据结构、异步操作</td></tr></tbody></table><h3 id="4-4-适用场景对比"><a href="#4-4-适用场景对比" class="headerlink" title="4.4 适用场景对比"></a>4.4 适用场景对比</h3><p>基于以上区别，<code>unique_ptr</code> 和 <code>shared_ptr</code> 适用于不同的场景。</p><h4 id="4-4-1-何时选择-unique-ptr"><a href="#4-4-1-何时选择-unique-ptr" class="headerlink" title="4.4.1 何时选择 unique_ptr"></a>4.4.1 何时选择 unique_ptr</h4><ul><li><strong>独占所有权</strong>：当资源的生命周期应该由单个所有者明确管理时，应首选 <code>unique_ptr</code>。例如，在工厂函数中创建并返回一个对象，或者在类中作为成员变量管理一个动态分配的子对象。</li><li><strong>性能敏感</strong>：在对性能要求较高的场景下，应优先使用 <code>unique_ptr</code>，因为它没有引用计数的开销。</li><li><strong>RAII 封装</strong>：当需要封装任何需要特殊清理逻辑的资源（如文件句柄、数据库连接等）时，<code>unique_ptr</code> 配合自定义删除器是一个非常好的选择。</li></ul><h4 id="4-4-2-何时选择-shared-ptr"><a href="#4-4-2-何时选择-shared-ptr" class="headerlink" title="4.4.2 何时选择 shared_ptr"></a>4.4.2 何时选择 shared_ptr</h4><ul><li><strong>共享所有权</strong>：当多个对象需要共享同一个资源，并且资源的生命周期应该由最后一个使用者决定时，应使用 <code>shared_ptr</code>。例如，在复杂的对象关系图中，或者在缓存系统中。</li><li><strong>需要复制</strong>：当需要将一个指针传递给多个接收者，并且每个接收者都可能延长该对象的生命周期时，<code>shared_ptr</code> 的拷贝语义非常有用。</li><li><strong>与 weak_ptr 配合使用</strong>：当需要打破循环引用，或者需要观察一个对象但不想影响其生命周期时，<code>shared_ptr</code> 可以与 <code>weak_ptr</code> 配合使用。</li></ul><h2 id="5-unique-ptr-的实际应用场景"><a href="#5-unique-ptr-的实际应用场景" class="headerlink" title="5. unique_ptr 的实际应用场景"></a>5. unique_ptr 的实际应用场景</h2><p><code>unique_ptr</code> 凭借其高效、安全和语义清晰的特性，在现代 C++ 编程中有着广泛的应用。</p><h3 id="5-1-管理动态分配的对象"><a href="#5-1-管理动态分配的对象" class="headerlink" title="5.1 管理动态分配的对象"></a>5.1 管理动态分配的对象</h3><p><code>unique_ptr</code> 最常见的用途是管理通过 <code>new</code> 动态分配的对象，确保其内存能够被自动释放。</p><h4 id="5-1-1-作为类成员变量（pImpl-惯用法）"><a href="#5-1-1-作为类成员变量（pImpl-惯用法）" class="headerlink" title="5.1.1 作为类成员变量（pImpl 惯用法）"></a>5.1.1 作为类成员变量（pImpl 惯用法）</h4><p>在类设计中，将 <code>unique_ptr</code> 作为成员变量是实现 <strong>pImpl（Pointer to Implementation）</strong> 惯用法的理想选择。pImpl 惯用法通过将实现细节隐藏在一个不透明的指针后面，来减少编译依赖和接口的稳定性。</p><p>使用 <code>unique_ptr</code> 作为这个指针，可以自动管理实现对象的生命周期，无需在类的析构函数中手动 <code>delete</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>();</span><br><span class="line">    ~<span class="built_in">MyClass</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Impl</span>; <span class="comment">// 前向声明</span></span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyClass.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>::Impl &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>() : <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br><span class="line">MyClass::~<span class="built_in">MyClass</span>() = <span class="keyword">default</span>; <span class="comment">// 自动生成，会调用 unique_ptr 的析构函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::doSomething</span><span class="params">()</span> </span>&#123; pImpl-&gt;<span class="built_in">doSomething</span>(); &#125;</span><br></pre></td></tr></table></figure><p>这种方式不仅简化了代码，还提供了强大的异常安全保障。</p><h4 id="5-1-2-在函数中传递和返回所有权"><a href="#5-1-2-在函数中传递和返回所有权" class="headerlink" title="5.1.2 在函数中传递和返回所有权"></a>5.1.2 在函数中传递和返回所有权</h4><p><code>unique_ptr</code> 非常适合在函数之间传递和返回动态分配对象的所有权。</p><ul><li><strong>作为返回值</strong>：工厂函数可以返回一个 <code>unique_ptr</code>，将新创建对象的所有权转移给调用者。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;MyClass&gt; <span class="title">createMyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MyClass&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>作为参数</strong>：函数可以通过值或右值引用的方式接收 <code>unique_ptr</code>，以接管所有权。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processMyClass</span><span class="params">(std::unique_ptr&lt;MyClass&gt; ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ptr 现在拥有该对象</span></span><br><span class="line">&#125; <span class="comment">// ptr 离开作用域，对象被销毁</span></span><br></pre></td></tr></table></figure><p>这种方式使得所有权的转移在代码中非常明确，避免了所有权的混淆。</p><h3 id="5-2-管理动态数组"><a href="#5-2-管理动态数组" class="headerlink" title="5.2 管理动态数组"></a>5.2 管理动态数组</h3><p><code>unique_ptr</code> 提供了对动态数组的特化版本 <code>unique_ptr&lt;T[]&gt;</code>，用于管理通过 <code>new[]</code> 分配的数组。</p><h4 id="5-2-1-使用-unique-ptr-lt-T-gt"><a href="#5-2-1-使用-unique-ptr-lt-T-gt" class="headerlink" title="5.2.1 使用 unique_ptr&lt;T[]&gt;"></a>5.2.1 使用 unique_ptr&lt;T[]&gt;</h4><p><code>unique_ptr&lt;T[]&gt;</code> 的特化版本重载了 <code>operator[]</code>，并确保在析构时调用 <code>delete[]</code> 而不是 <code>delete</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">arr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>这使得管理动态数组变得像管理单个对象一样简单和安全。</p><h4 id="5-2-2-访问数组元素"><a href="#5-2-2-访问数组元素" class="headerlink" title="5.2.2 访问数组元素"></a>5.2.2 访问数组元素</h4><p>对于 <code>unique_ptr&lt;T[]&gt;</code>，可以使用 <code>operator[]</code> 来访问数组的元素，就像使用普通数组一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">arr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">42</span>;</span><br><span class="line">std::cout &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>这种方式比使用 <code>std::vector</code> 更轻量，但功能也更有限，因为它不支持动态调整大小。</p><h3 id="5-3-与标准库容器结合使用"><a href="#5-3-与标准库容器结合使用" class="headerlink" title="5.3 与标准库容器结合使用"></a>5.3 与标准库容器结合使用</h3><p><code>unique_ptr</code> 可以作为标准库容器（如 <code>std::vector</code>）的元素类型，用于创建多态对象容器。</p><h4 id="5-3-1-在-vector-中存储-unique-ptr"><a href="#5-3-1-在-vector-中存储-unique-ptr" class="headerlink" title="5.3.1 在 vector 中存储 unique_ptr"></a>5.3.1 在 vector 中存储 unique_ptr</h4><p>由于 <code>unique_ptr</code> 不可拷贝，但可移动，因此可以将其存储在 <code>std::vector</code> 中。这使得可以创建一个拥有其元素的容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::unique_ptr&lt;MyClass&gt;&gt; vec;</span><br><span class="line">vec.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;MyClass&gt;());</span><br><span class="line">vec.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;MyClass&gt;());</span><br></pre></td></tr></table></figure><p>当 <code>vec</code> 被销毁时，其所有元素（即 <code>unique_ptr</code> 对象）也会被销毁，从而自动释放所有管理的 <code>MyClass</code> 对象。</p><h4 id="5-3-2-实现多态容器"><a href="#5-3-2-实现多态容器" class="headerlink" title="5.3.2 实现多态容器"></a>5.3.2 实现多态容器</h4><p>通过将基类的 <code>unique_ptr</code> 存储在容器中，可以创建一个多态容器，用于存储不同派生类的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::unique_ptr&lt;Base&gt;&gt; poly_vec;</span><br><span class="line">poly_vec.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;Derived1&gt;());</span><br><span class="line">poly_vec.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;Derived2&gt;());</span><br></pre></td></tr></table></figure><p>当 <code>poly_vec</code> 被销毁时，所有 <code>Derived1</code> 和 <code>Derived2</code> 对象都会被自动正确地销毁。</p><p>需要注意的是，如果通过基类 <code>unique_ptr</code> 删除派生类对象，基类的析构函数必须是虚函数（<code>virtual</code>），否则会导致未定义行为。</p><h3 id="5-4-自定义删除器的应用"><a href="#5-4-自定义删除器的应用" class="headerlink" title="5.4 自定义删除器的应用"></a>5.4 自定义删除器的应用</h3><p><code>unique_ptr</code> 的第二个模板参数 <code>Deleter</code> 使其能够管理任何需要特殊清理逻辑的资源，而不仅仅是通过 <code>new</code> 分配的内存。</p><h4 id="5-4-1-管理文件句柄（FILE-）"><a href="#5-4-1-管理文件句柄（FILE-）" class="headerlink" title="5.4.1 管理文件句柄（FILE*）"></a>5.4.1 管理文件句柄（FILE*）</h4><p>这是一个经典的自定义删除器应用场景。C 标准库中的文件操作使用 <code>FILE*</code> 句柄，需要通过 <code>fclose</code> 来关闭。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个自定义删除器</span></span><br><span class="line"><span class="keyword">auto</span> file_deleter = [](std::FILE* fp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">        std::<span class="built_in">fclose</span>(fp);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File closed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 unique_ptr 来管理 FILE*</span></span><br><span class="line"><span class="keyword">using</span> unique_file_ptr = std::unique_ptr&lt;std::FILE, <span class="keyword">decltype</span>(file_deleter)&gt;;</span><br><span class="line"><span class="function">unique_file_ptr <span class="title">file</span><span class="params">(std::fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>), file_deleter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (file) &#123;</span><br><span class="line">    <span class="comment">// 使用文件...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当 file 离开作用域时，file_deleter 会被自动调用，关闭文件</span></span><br></pre></td></tr></table></figure><h4 id="5-4-2-管理其他需要特殊清理的资源"><a href="#5-4-2-管理其他需要特殊清理的资源" class="headerlink" title="5.4.2 管理其他需要特殊清理的资源"></a>5.4.2 管理其他需要特殊清理的资源</h4><p>除了文件句柄，自定义删除器还可以用于管理各种其他资源，例如：</p><ul><li><strong>网络套接字</strong>：删除器可以调用 <code>close</code> 或 <code>closesocket</code> 来关闭套接字。</li><li><strong>数据库连接</strong>：删除器可以调用相应的 API 来断开数据库连接。</li><li><strong>互斥锁</strong>：删除器可以调用 <code>unlock</code> 来释放锁，确保即使在异常情况下锁也能被正确释放。</li><li><strong>共享内存</strong>：删除器可以调用 <code>shm_unlink</code> 或类似的函数来清理共享内存段。</li></ul><p>通过这种方式，<code>unique_ptr</code> 成为了一个通用的 RAII 包装器，可以用于管理任何需要显式清理的资源，极大地提高了代码的健壮性和安全性。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;详解-C-unique-ptr：独占式智能指针&quot;&gt;&lt;a href=&quot;#详解-C-unique-ptr：独占式智能指针&quot; class=&quot;headerlink&quot; title=&quot;详解 C++ unique_ptr：独占式智能指针&quot;&gt;&lt;/a&gt;详解 C++ unique_ptr：独占式智能指针&lt;/h1&gt;&lt;h2 id=&quot;1-unique-ptr-的核心概念与定义&quot;&gt;&lt;a href=&quot;#1-unique-ptr-的核心概念与定义&quot; class=&quot;headerlink&quot; title=&quot;1. unique_ptr 的核心概念与定义&quot;&gt;&lt;/a&gt;1. unique_ptr 的核心概念与定义&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是-unique-ptr&quot;&gt;&lt;a href=&quot;#1-1-什么是-unique-ptr&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是 unique_ptr&quot;&gt;&lt;/a&gt;1.1 什么是 unique_ptr&lt;/h3&gt;&lt;p&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt; 是 C++11 标准库中引入的一种智能指针，其核心设计目标是提供一种对动态分配对象的&lt;strong&gt;独占所有权（Exclusive Ownership）&lt;/strong&gt; 管理机制。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://lyroom.github.io/tags/C/"/>
    
    <category term="智能指针" scheme="https://lyroom.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
    <category term="unique_ptr" scheme="https://lyroom.github.io/tags/unique-ptr/"/>
    
  </entry>
  
  <entry>
    <title>C++朝花夕拾-assert宏用法</title>
    <link href="https://lyroom.github.io/2025/09/22/C-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-assert%E5%AE%8F%E7%94%A8%E6%B3%95/"/>
    <id>https://lyroom.github.io/2025/09/22/C-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-assert%E5%AE%8F%E7%94%A8%E6%B3%95/</id>
    <published>2025-09-22T13:40:37.000Z</published>
    <updated>2025-09-22T13:40:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚学了 C++ 的 <strong>异常机制（<code>throw</code> &#x2F; <code>try</code> &#x2F; <code>catch</code>）</strong>，现在问到 <code>assert</code> —— 它和异常看似都是“报错”，但<strong>用途、时机、行为完全不同</strong>！</p><h1 id="🧩-C-中的-assert-——-通俗易懂-详细对比异常机制"><a href="#🧩-C-中的-assert-——-通俗易懂-详细对比异常机制" class="headerlink" title="🧩 C++ 中的 assert —— 通俗易懂 + 详细对比异常机制"></a>🧩 C++ 中的 <code>assert</code> —— 通俗易懂 + 详细对比异常机制</h1><span id="more"></span><blockquote><p>✅ 一句话总结：<br><strong><code>assert</code> 是“调试断言”，用于开发阶段捕捉“绝不应该发生”的程序错误；而 <code>异常</code> 是“运行时错误处理”，用于处理“可能发生”的意外情况。</strong></p></blockquote><hr><h2 id="📌-一、什么是-assert？"><a href="#📌-一、什么是-assert？" class="headerlink" title="📌 一、什么是 assert？"></a>📌 一、什么是 <code>assert</code>？</h2><p><code>assert</code> 是一个<strong>宏（macro）</strong>，定义在头文件 <code>&lt;cassert&gt;</code> 中（C 语言是 <code>&lt;assert.h&gt;</code>）。</p><p>它的作用是：</p><blockquote><p><strong>“如果条件为假（false），程序立即终止，并输出错误信息”</strong></p></blockquote><h3 id="🧪-基本语法："><a href="#🧪-基本语法：" class="headerlink" title="🧪 基本语法："></a>🧪 基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>(条件表达式);</span><br></pre></td></tr></table></figure><hr><h2 id="🎯-二、assert-的典型用法（调试神器！）"><a href="#🎯-二、assert-的典型用法（调试神器！）" class="headerlink" title="🎯 二、assert 的典型用法（调试神器！）"></a>🎯 二、<code>assert</code> 的典型用法（调试神器！）</h2><h3 id="✅-1-检查函数参数（前置条件）"><a href="#✅-1-检查函数参数（前置条件）" class="headerlink" title="✅ 1. 检查函数参数（前置条件）"></a>✅ 1. 检查函数参数（前置条件）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divide</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(b != <span class="number">0.0</span>); <span class="comment">// 开发时确保调用者不会传 0</span></span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">divide</span>(<span class="number">10.0</span>, <span class="number">2.0</span>) &lt;&lt; endl; <span class="comment">// ✅ 正常</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">divide</span>(<span class="number">10.0</span>, <span class="number">0.0</span>) &lt;&lt; endl; <span class="comment">// ❌ 程序崩溃！输出错误位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>💥 如果 <code>b == 0.0</code>，程序会立即终止，并输出类似：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assertion failed: b != 0.0, file test.cpp, line 6</span><br></pre></td></tr></table></figure><hr><h3 id="✅-2-检查函数返回值或中间状态（不变式）"><a href="#✅-2-检查函数返回值或中间状态（不变式）" class="headerlink" title="✅ 2. 检查函数返回值或中间状态（不变式）"></a>✅ 2. 检查函数返回值或中间状态（不变式）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>); <span class="comment">// 阶乘不能对负数计算！</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        result *= i;</span><br><span class="line">        <span class="built_in">assert</span>(result &gt; <span class="number">0</span>); <span class="comment">// 防止整数溢出（调试用）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="✅-3-检查指针不为空（防崩溃）"><a href="#✅-3-检查指针不为空（防崩溃）" class="headerlink" title="✅ 3. 检查指针不为空（防崩溃）"></a>✅ 3. 检查指针不为空（防崩溃）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printLength</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(str != <span class="literal">nullptr</span>); <span class="comment">// 确保调用者没传空指针</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;长度: &quot;</span> &lt;&lt; <span class="built_in">strlen</span>(str) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="⚙️-三、assert-的底层机制（重点！）"><a href="#⚙️-三、assert-的底层机制（重点！）" class="headerlink" title="⚙️ 三、assert 的底层机制（重点！）"></a>⚙️ 三、<code>assert</code> 的底层机制（重点！）</h2><p><code>assert</code> 是一个<strong>预处理宏</strong>，它的行为取决于是否定义了 <code>NDEBUG</code> 宏：</p><table><thead><tr><th>编译模式</th><th>NDEBUG 是否定义</th><th>assert 行为</th></tr></thead><tbody><tr><td>Debug 模式</td><td>❌ 未定义</td><td>✅ 检查条件，失败则终止</td></tr><tr><td>Release 模式</td><td>✅ 已定义</td><td>❌ 被完全移除，无开销</td></tr></tbody></table><h3 id="🔍-举个例子："><a href="#🔍-举个例子：" class="headerlink" title="🔍 举个例子："></a>🔍 举个例子：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译时：</span></span><br><span class="line"><span class="comment">// Debug: g++ -g -o test test.cpp</span></span><br><span class="line"><span class="comment">// Release: g++ -DNDEBUG -O2 -o test test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">assert</span>(x &gt;= <span class="number">0</span>); <span class="comment">// Debug 模式下会崩溃，Release 模式下这行代码不存在！</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>✅ <strong>设计哲学</strong>：<br><code>assert</code> 只用于<strong>开发调试阶段</strong>，捕捉程序员的逻辑错误；<br>发布版本中完全消失，不影响性能！</p></blockquote><hr><h2 id="🆚-四、assert-vs-异常-——-核心区别表"><a href="#🆚-四、assert-vs-异常-——-核心区别表" class="headerlink" title="🆚 四、assert vs 异常 —— 核心区别表"></a>🆚 四、<code>assert</code> vs <code>异常</code> —— 核心区别表</h2><table><thead><tr><th>特性</th><th><code>assert</code></th><th><code>异常 (throw/catch)</code></th></tr></thead><tbody><tr><td><strong>用途</strong></td><td>捕捉“程序员错误”（不该发生的）</td><td>处理“运行时错误”（可能发生的）</td></tr><tr><td><strong>是否可恢复</strong></td><td>❌ 程序直接终止</td><td>✅ 可捕获并恢复</td></tr><tr><td><strong>是否影响发布版</strong></td><td>❌ Release 模式下被移除</td><td>✅ 始终存在</td></tr><tr><td><strong>性能开销</strong></td><td>❌ Debug 有开销，Release 无开销</td><td>✅ 无异常时开销极小，抛异常时较大</td></tr><tr><td><strong>适用阶段</strong></td><td>开发调试阶段</td><td>开发 + 发布阶段</td></tr><tr><td><strong>典型场景</strong></td><td>参数检查、不变式、内部逻辑错误</td><td>文件打不开、网络断开、用户输入错误</td></tr><tr><td><strong>能否被忽略</strong></td><td>❌ 不能（直接 crash）</td><td>✅ 能（但不推荐）</td></tr></tbody></table><hr><h2 id="🚫-五、什么时候不该用-assert？"><a href="#🚫-五、什么时候不该用-assert？" class="headerlink" title="🚫 五、什么时候不该用 assert？"></a>🚫 五、什么时候<strong>不该</strong>用 <code>assert</code>？</h2><h3 id="❌-1-检查用户输入"><a href="#❌-1-检查用户输入" class="headerlink" title="❌ 1. 检查用户输入"></a>❌ 1. 检查用户输入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age;</span><br><span class="line">cin &gt;&gt; age;</span><br><span class="line"><span class="built_in">assert</span>(age &gt;= <span class="number">0</span>); <span class="comment">// ❌ 错误！用户可能输入负数，这是“可预期错误”</span></span><br></pre></td></tr></table></figure><p>✅ 应该用异常或错误码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;年龄不能为负数！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="❌-2-检查文件-x2F-网络等外部资源"><a href="#❌-2-检查文件-x2F-网络等外部资源" class="headerlink" title="❌ 2. 检查文件&#x2F;网络等外部资源"></a>❌ 2. 检查文件&#x2F;网络等外部资源</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE* f = <span class="built_in">fopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="built_in">assert</span>(f != <span class="literal">nullptr</span>); <span class="comment">// ❌ 错误！文件可能不存在，这是“运行时异常”</span></span><br></pre></td></tr></table></figure><p>✅ 应该用异常：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!f) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;无法打开文件 data.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="❌-3-在析构函数中使用（危险！）"><a href="#❌-3-在析构函数中使用（危险！）" class="headerlink" title="❌ 3. 在析构函数中使用（危险！）"></a>❌ 3. 在析构函数中使用（危险！）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">    <span class="built_in">assert</span>(ptr != <span class="literal">nullptr</span>); <span class="comment">// ❌ 如果 assert 失败 → 程序终止，可能掩盖更严重问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 应记录日志或静默处理。</p><hr><h2 id="✅-六、什么时候该用-assert？"><a href="#✅-六、什么时候该用-assert？" class="headerlink" title="✅ 六、什么时候该用 assert？"></a>✅ 六、什么时候<strong>该</strong>用 <code>assert</code>？</h2><table><thead><tr><th>场景</th><th>示例</th></tr></thead><tbody><tr><td>函数前置条件</td><td><code>assert(index &gt;= 0 &amp;&amp; index &lt; size);</code></td></tr><tr><td>循环不变式</td><td><code>assert(total &gt;= 0);</code></td></tr><tr><td>指针有效性</td><td><code>assert(p != nullptr);</code></td></tr><tr><td>算法内部状态</td><td><code>assert(sorted == true);</code></td></tr><tr><td>测试驱动开发</td><td><code>assert(result == expected);</code></td></tr></tbody></table><blockquote><p>🎯 <strong>黄金法则</strong>：<br><strong>“如果这个条件为假，说明我的代码有 bug —— 用 <code>assert</code>”</strong><br><strong>“如果这个条件为假，是用户&#x2F;环境的问题 —— 用异常”</strong></p></blockquote><hr><h2 id="🧰-七、自定义断言（高级技巧）"><a href="#🧰-七、自定义断言（高级技巧）" class="headerlink" title="🧰 七、自定义断言（高级技巧）"></a>🧰 七、自定义断言（高级技巧）</h2><p>你可以定义自己的断言宏，添加更多信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_ASSERT(expr, msg) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!(expr)) &#123; \</span></span><br><span class="line"><span class="meta">            std::cerr &lt;&lt; <span class="string">&quot;Assertion failed: &quot;</span> &lt;&lt; #expr \</span></span><br><span class="line"><span class="meta">                      &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; msg &lt;&lt; <span class="string">&quot;) &quot;</span> \</span></span><br><span class="line"><span class="meta">                      &lt;&lt; <span class="string">&quot;in &quot;</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; __LINE__ &lt;&lt; std::endl; \</span></span><br><span class="line"><span class="meta">            std::abort(); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">MY_ASSERT</span>(x &gt;= <span class="number">0</span>, <span class="string">&quot;x 应该是非负数&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>🖨️ 输出：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assertion failed: x &gt;= 0 (x 应该是非负数) in test.cpp:15</span><br></pre></td></tr></table></figure><hr><h2 id="📊-八、assert-在大型项目中的使用（Google-x2F-Microsoft-风格）"><a href="#📊-八、assert-在大型项目中的使用（Google-x2F-Microsoft-风格）" class="headerlink" title="📊 八、assert 在大型项目中的使用（Google &#x2F; Microsoft 风格）"></a>📊 八、<code>assert</code> 在大型项目中的使用（Google &#x2F; Microsoft 风格）</h2><ul><li>Google C++ Style Guide：<strong>鼓励使用 <code>assert</code> 检查内部不变式</strong></li><li>Microsoft：在 Windows 内核开发中大量使用 <code>NT_ASSERT</code></li><li>游戏引擎（如 Unreal）：<code>check()</code> 宏（类似 assert）</li></ul><blockquote><p>✅ 原则：<strong>“Fail Fast” —— 尽早崩溃，比隐藏 bug 导致后续灾难要好！</strong></p></blockquote><hr><h2 id="🧠-九、考考你！"><a href="#🧠-九、考考你！" class="headerlink" title="🧠 九、考考你！"></a>🧠 九、考考你！</h2><p>下面代码在 Debug 和 Release 模式下分别输出什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;getValue 被调用了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">getValue</span>() &gt;= <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;程序继续...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>✅ <strong>Debug 模式</strong>：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getValue 被调用了！</span><br><span class="line">Assertion failed: getValue() &gt;= 0, file test.cpp, line 10</span><br><span class="line">💥 程序终止，不会输出“程序继续...”</span><br></pre></td></tr></table></figure><blockquote><p>✅ <strong>Release 模式</strong>：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序继续...</span><br></pre></td></tr></table></figure><blockquote><p>🌟 解释：Release 模式下 <code>assert(...)</code> 整行被预处理器删除，<code>getValue()</code> 根本不会被调用！</p></blockquote><hr><h2 id="🧩-十、static-assert-——-编译期断言（C-11）"><a href="#🧩-十、static-assert-——-编译期断言（C-11）" class="headerlink" title="🧩 十、static_assert —— 编译期断言（C++11）"></a>🧩 十、<code>static_assert</code> —— 编译期断言（C++11）</h2><p>除了运行时 <code>assert</code>，C++11 引入了 <strong>编译期断言</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) == <span class="number">4</span>, <span class="string">&quot;int 必须是 4 字节！&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>在<strong>编译时</strong>检查条件</li><li>失败则编译报错</li><li>常用于模板元编程、类型检查</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_integral_v&lt;T&gt;, <span class="string">&quot;T 必须是整数类型！&quot;</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="📌-总结：assert-使用口诀"><a href="#📌-总结：assert-使用口诀" class="headerlink" title="📌 总结：assert 使用口诀"></a>📌 总结：<code>assert</code> 使用口诀</h2><blockquote><p>✅ <strong>用 assert</strong>：  </p><ul><li>检查“程序员的错”  </li><li>调试阶段捕捉 bug  </li><li>内部逻辑、不变式、前置条件  </li><li>“Fail Fast” 原则</li></ul><p>❌ <strong>不用 assert</strong>：  </p><ul><li>用户输入、外部资源、可恢复错误  </li><li>发布版本中需要处理的错误  </li><li>析构函数中</li></ul><p>🔄 <strong>用异常</strong>：  </p><ul><li>处理“可能发生”的运行时错误  </li><li>需要恢复或通知用户的场景  </li><li>库函数、API 设计</li></ul></blockquote><hr><p>🎯 <strong>终极建议</strong>：</p><blockquote><p>把 <code>assert</code> 当作你的“代码保镖”，在开发阶段帮你揪出隐藏的逻辑错误；<br>把 <code>异常</code> 当作你的“错误处理专家”，在运行时优雅应对各种意外情况。</p></blockquote><p>两者配合，让你的 C++ 程序既健壮又安全！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;刚学了 C++ 的 &lt;strong&gt;异常机制（&lt;code&gt;throw&lt;/code&gt; &amp;#x2F; &lt;code&gt;try&lt;/code&gt; &amp;#x2F; &lt;code&gt;catch&lt;/code&gt;）&lt;/strong&gt;，现在问到 &lt;code&gt;assert&lt;/code&gt; —— 它和异常看似都是“报错”，但&lt;strong&gt;用途、时机、行为完全不同&lt;/strong&gt;！&lt;/p&gt;
&lt;h1 id=&quot;🧩-C-中的-assert-——-通俗易懂-详细对比异常机制&quot;&gt;&lt;a href=&quot;#🧩-C-中的-assert-——-通俗易懂-详细对比异常机制&quot; class=&quot;headerlink&quot; title=&quot;🧩 C++ 中的 assert —— 通俗易懂 + 详细对比异常机制&quot;&gt;&lt;/a&gt;🧩 C++ 中的 &lt;code&gt;assert&lt;/code&gt; —— 通俗易懂 + 详细对比异常机制&lt;/h1&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://lyroom.github.io/tags/C/"/>
    
    <category term="朝花夕拾" scheme="https://lyroom.github.io/tags/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    <category term="assert" scheme="https://lyroom.github.io/tags/assert/"/>
    
    <category term="断言" scheme="https://lyroom.github.io/tags/%E6%96%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++朝花夕拾-异常机制</title>
    <link href="https://lyroom.github.io/2025/09/22/C-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/"/>
    <id>https://lyroom.github.io/2025/09/22/C-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</id>
    <published>2025-09-22T12:49:47.000Z</published>
    <updated>2025-09-22T12:49:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🚨-C-异常机制-——-从零到精通"><a href="#🚨-C-异常机制-——-从零到精通" class="headerlink" title="🚨 C++ 异常机制 —— 从零到精通"></a>🚨 C++ 异常机制 —— 从零到精通</h1><blockquote><p>💡 一句话总结：<br><strong>“异常 &#x3D; 程序运行时发生的‘意外情况’，C++ 用 <code>throw</code>, <code>try</code>, <code>catch</code> 三剑客来处理它，让程序不崩溃、能恢复、有尊严地报错。”</strong></p></blockquote><span id="more"></span><hr><h2 id="🎯-一、为什么要学异常？——-先看“没有异常”的痛苦"><a href="#🎯-一、为什么要学异常？——-先看“没有异常”的痛苦" class="headerlink" title="🎯 一、为什么要学异常？—— 先看“没有异常”的痛苦"></a>🎯 一、为什么要学异常？—— 先看“没有异常”的痛苦</h2><h3 id="👶-传统错误处理方式：返回错误码（return-1-NULL-false…）"><a href="#👶-传统错误处理方式：返回错误码（return-1-NULL-false…）" class="headerlink" title="👶 传统错误处理方式：返回错误码（return -1, NULL, false…）"></a>👶 传统错误处理方式：返回错误码（return -1, NULL, false…）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 用 -1 表示“除零错误”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误：除数不能为0！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;结果是：&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>❗ 问题来了：</p><ul><li>如果忘记检查返回值？→ 程序逻辑错乱！</li><li>如果函数要返回“正常值”和“错误码”？→ 设计混乱！</li><li>如果错误发生在“深层调用”中？→ 一层层往上传，代码臃肿！</li></ul></blockquote><hr><h2 id="🌟-二、异常机制登场-——-throw-try-catch"><a href="#🌟-二、异常机制登场-——-throw-try-catch" class="headerlink" title="🌟 二、异常机制登场 —— throw, try, catch"></a>🌟 二、异常机制登场 —— <code>throw</code>, <code>try</code>, <code>catch</code></h2><p>C++ 异常机制三大关键字：</p><table><thead><tr><th>关键字</th><th>作用</th></tr></thead><tbody><tr><td><code>throw</code></td><td>抛出一个异常（相当于“报警”）</td></tr><tr><td><code>try</code></td><td>包裹可能出错的代码（“监控区”）</td></tr><tr><td><code>catch</code></td><td>捕获并处理异常（“接警处理”）</td></tr></tbody></table><hr><h3 id="🎬-生活化比喻：餐厅点餐"><a href="#🎬-生活化比喻：餐厅点餐" class="headerlink" title="🎬 生活化比喻：餐厅点餐"></a>🎬 生活化比喻：餐厅点餐</h3><ul><li>你点了一份“牛排” → <code>try &#123; 点餐(); &#125;</code></li><li>厨房发现“牛肉卖完了” → <code>throw &quot;没牛肉了！&quot;;</code></li><li>服务员接到通知 → <code>catch (string msg) &#123; 告诉顾客 + 推荐别的菜 &#125;</code></li><li>顾客不会因为“没牛肉”掀桌子（程序不崩溃），而是优雅换菜 😊</li></ul><hr><h2 id="🧩-三、基本语法-示例"><a href="#🧩-三、基本语法-示例" class="headerlink" title="🧩 三、基本语法 + 示例"></a>🧩 三、基本语法 + 示例</h2><h3 id="✅-1-抛出异常：throw-表达式"><a href="#✅-1-抛出异常：throw-表达式" class="headerlink" title="✅ 1. 抛出异常：throw 表达式;"></a>✅ 1. 抛出异常：<code>throw 表达式;</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;年龄不能为负数！&quot;</span>; <span class="comment">// 抛出字符串异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">999</span>; <span class="comment">// 抛出整数异常（不推荐，但合法）</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年龄合法：&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>💡 <code>throw</code> 可以抛出 <strong>任何类型</strong>：<code>int</code>, <code>string</code>, <code>char*</code>, 自定义类对象等<br>✅ 推荐抛出 <strong>异常类对象</strong>（后文讲）</p></blockquote><hr><h3 id="✅-2-捕获异常：try-catch"><a href="#✅-2-捕获异常：try-catch" class="headerlink" title="✅ 2. 捕获异常：try { ... } catch (...) { ... }"></a>✅ 2. 捕获异常：<code>try &#123; ... &#125; catch (...) &#123; ... &#125;</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">checkAge</span>(<span class="number">-5</span>); <span class="comment">// 可能抛异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123; <span class="comment">// 捕获 char* 类型异常</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;捕获到异常：&quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">int</span> code) &#123; <span class="comment">// 捕获 int 类型异常</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误代码：&quot;</span> &lt;&lt; code &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;程序继续运行...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>🖨️ 输出：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常：年龄不能为负数！</span><br><span class="line">程序继续运行...</span><br></pre></td></tr></table></figure><hr><h2 id="🧱-四、异常的传播（栈展开-——-Stack-Unwinding）"><a href="#🧱-四、异常的传播（栈展开-——-Stack-Unwinding）" class="headerlink" title="🧱 四、异常的传播（栈展开 —— Stack Unwinding）"></a>🧱 四、异常的传播（栈展开 —— Stack Unwinding）</h2><h3 id="❓-问题：如果异常发生在“函数调用深处”，怎么办？"><a href="#❓-问题：如果异常发生在“函数调用深处”，怎么办？" class="headerlink" title="❓ 问题：如果异常发生在“函数调用深处”，怎么办？"></a>❓ 问题：如果异常发生在“函数调用深处”，怎么办？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;func3 出错了！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func3</span>(); <span class="comment">// func3 抛异常</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;这行不会执行！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func1</span>(); <span class="comment">// 异常从 func3 一路“冒泡”到 main</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;main 捕获：&quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>🔄 <strong>栈展开过程</strong>：</p><ol><li><code>func3()</code> 抛异常</li><li><code>func3()</code> 立刻退出 → 析构局部对象</li><li><code>func2()</code> 退出 → 析构局部对象</li><li><code>func1()</code> 退出 → 析构局部对象</li><li><code>main()</code> 的 <code>catch</code> 捕获异常 → 程序继续</li></ol></blockquote><blockquote><p>✅ <strong>关键点</strong>：异常会沿着调用栈“向上传播”，直到被捕获，中间函数全部退出（局部对象被析构）！</p></blockquote><hr><h2 id="🧰-五、标准异常类（推荐使用！）"><a href="#🧰-五、标准异常类（推荐使用！）" class="headerlink" title="🧰 五、标准异常类（推荐使用！）"></a>🧰 五、标准异常类（推荐使用！）</h2><p>C++ 标准库提供了一套异常类（在 <code>&lt;stdexcept&gt;</code> 中），建议优先使用：</p><table><thead><tr><th>异常类</th><th>用途</th></tr></thead><tbody><tr><td><code>std::runtime_error</code></td><td>运行时错误（如文件打不开）</td></tr><tr><td><code>std::logic_error</code></td><td>逻辑错误（如传参错误）</td></tr><tr><td><code>std::invalid_argument</code></td><td>无效参数</td></tr><tr><td><code>std::out_of_range</code></td><td>越界访问（如 vector）</td></tr></tbody></table><h3 id="✅-示例：使用标准异常"><a href="#✅-示例：使用标准异常" class="headerlink" title="✅ 示例：使用标准异常"></a>✅ 示例：使用标准异常</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divide</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;除数不能为零！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">divide</span>(<span class="number">10.0</span>, <span class="number">0.0</span>) &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> invalid_argument&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;参数错误：&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> exception&amp; e) &#123; <span class="comment">// 基类，捕获所有标准异常</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;标准异常：&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>📌 <code>.what()</code> 是 <code>std::exception</code> 的虚函数，返回错误描述字符串。</p></blockquote><hr><h2 id="🛠️-六、自定义异常类（高级用法）"><a href="#🛠️-六、自定义异常类（高级用法）" class="headerlink" title="🛠️ 六、自定义异常类（高级用法）"></a>🛠️ 六、自定义异常类（高级用法）</h2><p>你可以继承 <code>std::exception</code> 或其子类，创建自己的异常：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> std::exception &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string msg;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>(<span class="type">const</span> string&amp; m) : <span class="built_in">msg</span>(m) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg.<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">riskyFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="string">&quot;我的自定义异常！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">riskyFunction</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> MyException&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;捕获自定义异常：&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>✅ 自定义异常 &#x3D; 更精确的错误分类 + 更丰富的错误信息！</p></blockquote><hr><h2 id="⚠️-七、异常规范（C-11-起已废弃，了解即可）"><a href="#⚠️-七、异常规范（C-11-起已废弃，了解即可）" class="headerlink" title="⚠️ 七、异常规范（C++11 起已废弃，了解即可）"></a>⚠️ 七、异常规范（C++11 起已废弃，了解即可）</h2><p>老版本 C++ 支持异常规范：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// 只允许抛 int 异常（已废弃）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;    <span class="comment">// 不允许抛任何异常（已废弃）</span></span><br></pre></td></tr></table></figure><blockquote><p>🚫 <strong>C++11 起废弃</strong>，改用 <code>noexcept</code>：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeFunc</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// 承诺不抛异常</span></span><br><span class="line">    <span class="comment">// 如果这里 throw 了 → std::terminate() 程序终止！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔄-八、重新抛出异常（throw-）"><a href="#🔄-八、重新抛出异常（throw-）" class="headerlink" title="🔄 八、重新抛出异常（throw;）"></a>🔄 八、重新抛出异常（<code>throw;</code>）</h2><p>在 <code>catch</code> 块中，你可以“处理一部分，再抛出去”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">handlePartially</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">riskyOperation</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;记录日志：发生异常！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// 重新抛出当前异常（不改变类型！）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">handlePartially</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;最终处理：&quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>✅ 用途：日志记录、资源清理、部分处理后交给上层。</p></blockquote><hr><h2 id="🧹-九、异常安全与-RAII（重要！）"><a href="#🧹-九、异常安全与-RAII（重要！）" class="headerlink" title="🧹 九、异常安全与 RAII（重要！）"></a>🧹 九、异常安全与 RAII（重要！）</h2><h3 id="❗-异常可能导致资源泄漏！"><a href="#❗-异常可能导致资源泄漏！" class="headerlink" title="❗ 异常可能导致资源泄漏！"></a>❗ 异常可能导致资源泄漏！</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">badExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">riskyFunction</span>(); <span class="comment">// 如果这里抛异常 → p 永远不会 delete！</span></span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="✅-解决方案：RAII-智能指针"><a href="#✅-解决方案：RAII-智能指针" class="headerlink" title="✅ 解决方案：RAII + 智能指针"></a>✅ 解决方案：RAII + 智能指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">1000</span>); <span class="comment">// 智能指针</span></span><br><span class="line">    <span class="built_in">riskyFunction</span>(); <span class="comment">// 即使抛异常，p 也会自动析构！</span></span><br><span class="line">    <span class="comment">// 不用手动 delete</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>🌟 <strong>RAII 原则</strong>：资源获取即初始化，绑定对象生命周期 → 异常时自动释放！</p></blockquote><hr><h2 id="🚫-十、不要在析构函数中抛异常！"><a href="#🚫-十、不要在析构函数中抛异常！" class="headerlink" title="🚫 十、不要在析构函数中抛异常！"></a>🚫 十、不要在析构函数中抛异常！</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BadClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">BadClass</span>() &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;析构函数抛异常！&quot;</span>; <span class="comment">// ❌ 危险！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>💥 如果析构函数抛异常，且当前正在处理另一个异常 → <code>std::terminate()</code> 程序直接终止！</p></blockquote><p>✅ 正确做法：在析构函数中用 <code>try-catch</code> 吞掉异常，或记录日志。</p><hr><h2 id="📊-十一、异常的性能开销"><a href="#📊-十一、异常的性能开销" class="headerlink" title="📊 十一、异常的性能开销"></a>📊 十一、异常的性能开销</h2><ul><li><strong>无异常时</strong>：现代编译器优化得很好，几乎无开销</li><li><strong>抛异常时</strong>：栈展开、查找 catch 块 → 开销较大（比 if-else 慢很多）</li><li>✅ <strong>建议</strong>：异常用于“真正异常”的情况（如文件打不开、网络断开），不要用于控制流程！</li></ul><hr><h2 id="🧠-十二、异常-vs-错误码-——-如何选择？"><a href="#🧠-十二、异常-vs-错误码-——-如何选择？" class="headerlink" title="🧠 十二、异常 vs 错误码 —— 如何选择？"></a>🧠 十二、异常 vs 错误码 —— 如何选择？</h2><table><thead><tr><th>场景</th><th>推荐方式</th></tr></thead><tbody><tr><td>频繁发生的“可预期”错误（如用户输错）</td><td>✅ 错误码</td></tr><tr><td>罕见、严重、不可恢复的错误（如内存不足、文件损坏）</td><td>✅ 异常</td></tr><tr><td>库函数、API 设计</td><td>✅ 异常（更安全、不易忽略）</td></tr><tr><td>性能敏感代码（游戏循环、高频交易）</td><td>✅ 错误码</td></tr></tbody></table><hr><h2 id="🎓-十三、完整实战示例"><a href="#🎓-十三、完整实战示例" class="headerlink" title="🎓 十三、完整实战示例"></a>🎓 十三、完整实战示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConfigFile</span> &#123;</span><br><span class="line">    string filename;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConfigFile</span>(<span class="type">const</span> string&amp; fname) : <span class="built_in">filename</span>(fname) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;无法打开配置文件: &quot;</span> + filename);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string content, line;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">getline</span>(file, line)) &#123;</span><br><span class="line">            content += line + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ConfigFile <span class="title">cfg</span><span class="params">(<span class="string">&quot;config.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        string data = cfg.<span class="built_in">load</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;配置内容：\n&quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> runtime_error&amp; e) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;加载失败：&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;未知错误！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;程序正常结束。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="📌-总结：C-异常机制核心要点"><a href="#📌-总结：C-异常机制核心要点" class="headerlink" title="📌 总结：C++ 异常机制核心要点"></a>📌 总结：C++ 异常机制核心要点</h2><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td><code>throw</code></td><td>抛出异常，中断当前函数</td></tr><tr><td><code>try-catch</code></td><td>捕获并处理异常，防止程序崩溃</td></tr><tr><td>栈展开</td><td>异常向上传播，中间函数退出，局部对象析构</td></tr><tr><td>标准异常</td><td>优先使用 <code>std::exception</code> 及其子类</td></tr><tr><td>自定义异常</td><td>继承 <code>std::exception</code>，重写 <code>what()</code></td></tr><tr><td><code>noexcept</code></td><td>声明函数不抛异常（C++11）</td></tr><tr><td><code>throw;</code></td><td>重新抛出当前异常</td></tr><tr><td>RAII</td><td>用对象管理资源，确保异常时自动释放</td></tr><tr><td>析构函数</td><td>绝对不要抛异常！</td></tr><tr><td>性能</td><td>异常用于“真异常”，不要滥用</td></tr></tbody></table><hr><h2 id="🧩-考考你！"><a href="#🧩-考考你！" class="headerlink" title="🧩 考考你！"></a>🧩 考考你！</h2><p>下面代码会输出什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A 构造&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A 析构&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;出错了！&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;这行不会执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;捕获：&quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>✅ 答案：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A 构造</span><br><span class="line">A 析构</span><br><span class="line">捕获：出错了！</span><br></pre></td></tr></table></figure><blockquote><p>🌟 解释：即使 <code>throw</code> 中断了 <code>func()</code>，局部对象 <code>a</code> 仍会析构！这就是 <strong>栈展开 + RAII</strong> 的威力！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;🚨-C-异常机制-——-从零到精通&quot;&gt;&lt;a href=&quot;#🚨-C-异常机制-——-从零到精通&quot; class=&quot;headerlink&quot; title=&quot;🚨 C++ 异常机制 —— 从零到精通&quot;&gt;&lt;/a&gt;🚨 C++ 异常机制 —— 从零到精通&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;💡 一句话总结：&lt;br&gt;&lt;strong&gt;“异常 &amp;#x3D; 程序运行时发生的‘意外情况’，C++ 用 &lt;code&gt;throw&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt; 三剑客来处理它，让程序不崩溃、能恢复、有尊严地报错。”&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://lyroom.github.io/tags/C/"/>
    
    <category term="朝花夕拾" scheme="https://lyroom.github.io/tags/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
  </entry>
  
  <entry>
    <title>C++朝花夕拾-🌊 浅拷贝 vs 🏗️ 深拷贝</title>
    <link href="https://lyroom.github.io/2025/09/22/C-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%F0%9F%8C%8A-%E6%B5%85%E6%8B%B7%E8%B4%9D-vs-%F0%9F%8F%97%EF%B8%8F-%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://lyroom.github.io/2025/09/22/C-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%F0%9F%8C%8A-%E6%B5%85%E6%8B%B7%E8%B4%9D-vs-%F0%9F%8F%97%EF%B8%8F-%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2025-09-22T07:36:25.000Z</published>
    <updated>2025-09-22T07:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🌊-浅拷贝-vs-🏗️-深拷贝-——-一文看懂！"><a href="#🌊-浅拷贝-vs-🏗️-深拷贝-——-一文看懂！" class="headerlink" title="🌊 浅拷贝 vs 🏗️ 深拷贝 —— 一文看懂！"></a>🌊 浅拷贝 vs 🏗️ 深拷贝 —— 一文看懂！</h1><hr><h2 id="🧍‍♂️-举个生活例子：复印钥匙"><a href="#🧍‍♂️-举个生活例子：复印钥匙" class="headerlink" title="🧍‍♂️ 举个生活例子：复印钥匙"></a>🧍‍♂️ 举个生活例子：复印钥匙</h2><p>想象你有一把<strong>家门钥匙🔑</strong>，你把它“拷贝”给朋友：</p><span id="more"></span><ul><li><p><strong>浅拷贝</strong> &#x3D; 你直接把原钥匙给了朋友 → 你们俩用的是<strong>同一把钥匙</strong><br>👉 他丢了钥匙，你也进不了门！<br>👉 他配了一把新钥匙，你也多了一把！</p></li><li><p><strong>深拷贝</strong> &#x3D; 你去配了一把<strong>全新的、独立的钥匙</strong>给朋友 → 你们各有各的钥匙<br>👉 他丢了，不影响你<br>👉 他换锁了，你家门还是原样！</p></li></ul><hr><h2 id="💡-在-C-中，这“钥匙”就是——指针指向的堆内存"><a href="#💡-在-C-中，这“钥匙”就是——指针指向的堆内存" class="headerlink" title="💡 在 C++ 中，这“钥匙”就是——指针指向的堆内存"></a>💡 在 C++ 中，这“钥匙”就是——<strong>指针指向的堆内存</strong></h2><p>当你有一个类，里面包含指针成员（比如 <code>int* p;</code>），拷贝对象时：</p><ul><li><strong>浅拷贝</strong>：只复制指针的值（地址）→ 两个对象指向<strong>同一块内存</strong></li><li><strong>深拷贝</strong>：复制指针指向的<strong>内容</strong> → 两个对象各自拥有<strong>独立的内存</strong></li></ul><hr><h2 id="📜-默认拷贝是“浅拷贝”"><a href="#📜-默认拷贝是“浅拷贝”" class="headerlink" title="📜 默认拷贝是“浅拷贝”"></a>📜 默认拷贝是“浅拷贝”</h2><p>C++ 编译器默认提供的拷贝构造函数和赋值运算符，都是<strong>浅拷贝</strong>！</p><h3 id="👇-看个浅拷贝出问题的例子："><a href="#👇-看个浅拷贝出问题的例子：" class="headerlink" title="👇 看个浅拷贝出问题的例子："></a>👇 看个浅拷贝出问题的例子：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* score;  <span class="comment">// 指向堆内存的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> s) &#123;</span><br><span class="line">        score = <span class="keyword">new</span> <span class="built_in">int</span>(s); <span class="comment">// 在堆上分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器默认生成浅拷贝构造函数：</span></span><br><span class="line">    <span class="comment">// Student(const Student&amp; other) &#123;</span></span><br><span class="line">    <span class="comment">//     score = other.score; // 只复制地址！</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Student</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> score; <span class="comment">// 释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">s1</span><span class="params">(<span class="number">90</span>)</span></span>;</span><br><span class="line">    Student s2 = s1; <span class="comment">// 浅拷贝！s2.score 和 s1.score 指向同一块内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 s1 和 s2 析构时...</span></span><br><span class="line">&#125; <span class="comment">// 💥 程序崩溃！同一块内存被 delete 了两次！</span></span><br></pre></td></tr></table></figure><blockquote><p>💥 这就是“浅拷贝陷阱”——<strong>重复释放内存，程序崩溃！</strong></p></blockquote><hr><h2 id="✅-深拷贝：自己动手，丰衣足食！"><a href="#✅-深拷贝：自己动手，丰衣足食！" class="headerlink" title="✅ 深拷贝：自己动手，丰衣足食！"></a>✅ 深拷贝：自己动手，丰衣足食！</h2><p>我们手动写拷贝构造函数和赋值运算符，实现深拷贝：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* score;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> s) &#123;</span><br><span class="line">        score = <span class="keyword">new</span> <span class="built_in">int</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 👇 深拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Student&amp; other) &#123;</span><br><span class="line">        score = <span class="keyword">new</span> <span class="built_in">int</span>(*other.score); <span class="comment">// 分配新内存，复制内容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 👇 深拷贝赋值运算符</span></span><br><span class="line">    Student&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Student&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 自我赋值检查</span></span><br><span class="line">        <span class="keyword">delete</span> score;                     <span class="comment">// 先释放旧内存</span></span><br><span class="line">        score = <span class="keyword">new</span> <span class="built_in">int</span>(*other.score);    <span class="comment">// 再深拷贝</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Student</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">s1</span><span class="params">(<span class="number">90</span>)</span></span>;</span><br><span class="line">    Student s2 = s1; <span class="comment">// 深拷贝！各自有独立内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 s2 不影响 s1</span></span><br><span class="line">    *s2.score = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; *s1.score &lt;&lt; endl; <span class="comment">// 输出 90 ✅</span></span><br><span class="line">    cout &lt;&lt; *s2.score &lt;&lt; endl; <span class="comment">// 输出 100 ✅</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 析构时各自释放自己的内存，安全！✅</span></span><br></pre></td></tr></table></figure><hr><h2 id="🧩-一句话总结"><a href="#🧩-一句话总结" class="headerlink" title="🧩 一句话总结"></a>🧩 一句话总结</h2><blockquote><p><strong>浅拷贝 &#x3D; 复印地址（共享资源，危险！）</strong><br><strong>深拷贝 &#x3D; 复印内容（独立资源，安全！）</strong></p></blockquote><hr><h2 id="🚨-什么时候需要深拷贝？"><a href="#🚨-什么时候需要深拷贝？" class="headerlink" title="🚨 什么时候需要深拷贝？"></a>🚨 什么时候需要深拷贝？</h2><p>✅ 当你的类中包含：</p><ul><li>指针成员（<code>int*</code>, <code>char*</code>, <code>MyClass*</code> 等）</li><li>动态分配的资源（<code>new</code>, <code>malloc</code>, 文件句柄等）</li><li>任何“独占资源” —— 不能共享的东西！</li></ul><blockquote><p>📌 口诀：<strong>“三五法则”</strong><br>如果你需要自定义析构函数、拷贝构造、赋值运算符中的任何一个，很可能三个都需要写！</p></blockquote><hr><h2 id="🎁-额外小贴士：现代-C-更推荐用“智能指针”或“值语义”"><a href="#🎁-额外小贴士：现代-C-更推荐用“智能指针”或“值语义”" class="headerlink" title="🎁 额外小贴士：现代 C++ 更推荐用“智能指针”或“值语义”"></a>🎁 额外小贴士：现代 C++ 更推荐用“智能指针”或“值语义”</h2><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; score; <span class="comment">// 自动管理内存，拷贝时编译器会报错（不可拷贝）</span></span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="type">int</span> score; <span class="comment">// 直接存值，根本不需要指针 → 默认拷贝就是“深拷贝”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>✅ 优先使用 <code>std::string</code>, <code>std::vector</code>, <code>std::unique_ptr</code> 等 RAII 类型，避免手动管理内存！</p></blockquote><hr><h2 id="🧠-考考你！"><a href="#🧠-考考你！" class="headerlink" title="🧠 考考你！"></a>🧠 考考你！</h2><p>下面代码会出问题吗？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="built_in">Cat</span>(std::string n) : <span class="built_in">name</span>(n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Cat <span class="title">c1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>)</span></span>;</span><br><span class="line">    Cat c2 = c1; <span class="comment">// 浅拷贝还是深拷贝？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>✅ 答案：<strong>深拷贝！</strong><br>因为 <code>std::string</code> 内部已经帮你实现了深拷贝（或写时复制），你无需操心！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;🌊-浅拷贝-vs-🏗️-深拷贝-——-一文看懂！&quot;&gt;&lt;a href=&quot;#🌊-浅拷贝-vs-🏗️-深拷贝-——-一文看懂！&quot; class=&quot;headerlink&quot; title=&quot;🌊 浅拷贝 vs 🏗️ 深拷贝 —— 一文看懂！&quot;&gt;&lt;/a&gt;🌊 浅拷贝 vs 🏗️ 深拷贝 —— 一文看懂！&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;🧍‍♂️-举个生活例子：复印钥匙&quot;&gt;&lt;a href=&quot;#🧍‍♂️-举个生活例子：复印钥匙&quot; class=&quot;headerlink&quot; title=&quot;🧍‍♂️ 举个生活例子：复印钥匙&quot;&gt;&lt;/a&gt;🧍‍♂️ 举个生活例子：复印钥匙&lt;/h2&gt;&lt;p&gt;想象你有一把&lt;strong&gt;家门钥匙🔑&lt;/strong&gt;，你把它“拷贝”给朋友：&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://lyroom.github.io/tags/C/"/>
    
    <category term="朝花夕拾" scheme="https://lyroom.github.io/tags/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    <category term="浅拷贝" scheme="https://lyroom.github.io/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
    <category term="深拷贝" scheme="https://lyroom.github.io/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>C++朝花夕拾-using关键字</title>
    <link href="https://lyroom.github.io/2025/09/22/C-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-using%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://lyroom.github.io/2025/09/22/C-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-using%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2025-09-22T07:12:49.000Z</published>
    <updated>2025-09-22T07:12:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="📘-C-中-using-关键字的用法详解"><a href="#📘-C-中-using-关键字的用法详解" class="headerlink" title="📘 C++ 中 using 关键字的用法详解"></a>📘 C++ 中 <code>using</code> 关键字的用法详解</h1><p>在 C++ 中，<code>using</code> 关键字功能强大且用途多样，从 C++11 开始更是得到了显著增强。它主要用于简化代码、提高可读性、解决继承中的函数隐藏问题等。以下是 <code>using</code> 在 C++ 中的<strong>主要用法详解</strong>：</p><span id="more"></span><hr><h2 id="1️⃣-引入命名空间成员（Namespace-Members）"><a href="#1️⃣-引入命名空间成员（Namespace-Members）" class="headerlink" title="1️⃣ 引入命名空间成员（Namespace Members）"></a>1️⃣ 引入命名空间成员（Namespace Members）</h2><h3 id="1-1-引入单个成员"><a href="#1-1-引入单个成员" class="headerlink" title="1.1 引入单个成员"></a>1.1 引入单个成员</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; v[<span class="number">0</span>] &lt;&lt; endl; <span class="comment">// 不用写 std::</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>✅ 推荐：比 <code>using namespace std;</code> 更安全，避免命名污染。</p></blockquote><hr><h3 id="1-2-引入整个命名空间（谨慎使用）"><a href="#1-2-引入整个命名空间（谨慎使用）" class="headerlink" title="1.2 引入整个命名空间（谨慎使用）"></a>1.2 引入整个命名空间（谨慎使用）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 警告：<strong>不要在头文件或大型项目中使用</strong>，容易引起命名冲突！</p></blockquote><hr><h2 id="2️⃣-定义类型别名（Type-Alias）—-替代-typedef"><a href="#2️⃣-定义类型别名（Type-Alias）—-替代-typedef" class="headerlink" title="2️⃣ 定义类型别名（Type Alias）— 替代 typedef"></a>2️⃣ 定义类型别名（Type Alias）— 替代 <code>typedef</code></h2><p>C++11 起，<code>using</code> 可用于定义类型别名，语法更直观，功能更强。</p><h3 id="2-1-基本类型别名"><a href="#2-1-基本类型别名" class="headerlink" title="2.1 基本类型别名"></a>2.1 基本类型别名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> IntPtr = <span class="type">int</span>*;</span><br><span class="line"><span class="keyword">using</span> String = std::string;</span><br><span class="line"><span class="keyword">using</span> Callback = <span class="built_in">void</span>(*)(<span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* IntPtr;</span><br><span class="line"><span class="keyword">typedef</span> std::string String;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Callback)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>✅ <code>using</code> 语法更符合“赋值”语义：<code>别名 = 原类型</code></p></blockquote><hr><h3 id="2-2-模板别名（typedef-无法做到！）"><a href="#2-2-模板别名（typedef-无法做到！）" class="headerlink" title="2.2 模板别名（typedef 无法做到！）"></a>2.2 模板别名（<code>typedef</code> 无法做到！）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; v1;        <span class="comment">// std::vector&lt;int&gt;</span></span><br><span class="line">Vec&lt;std::string&gt; v2; <span class="comment">// std::vector&lt;std::string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MapString = std::map&lt;std::string, T&gt;;</span><br><span class="line"></span><br><span class="line">MapString&lt;<span class="type">int</span>&gt; m; <span class="comment">// std::map&lt;std::string, int&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>🌟 这是 <code>using</code> 最强大的优势之一 —— <strong>支持模板别名</strong>！</p></blockquote><hr><h2 id="3️⃣-在派生类中引入基类成员（解决函数隐藏）"><a href="#3️⃣-在派生类中引入基类成员（解决函数隐藏）" class="headerlink" title="3️⃣ 在派生类中引入基类成员（解决函数隐藏）"></a>3️⃣ 在派生类中引入基类成员（解决函数隐藏）</h2><p>当派生类定义了与基类同名的函数时，基类所有重载版本都会被<strong>隐藏</strong>。使用 <code>using</code> 可显式引入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::func(int)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::func(double)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::func; <span class="comment">// 引入所有重载版本 ✅</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::func(char)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">func</span>(<span class="number">10</span>);    <span class="comment">// Base::func(int)</span></span><br><span class="line">    d.<span class="built_in">func</span>(<span class="number">3.14</span>);  <span class="comment">// Base::func(double)</span></span><br><span class="line">    d.<span class="built_in">func</span>(<span class="string">&#x27;a&#x27;</span>);   <span class="comment">// Derived::func(char)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>❌ 如果没有 <code>using Base::func;</code>，则 <code>d.func(10)</code> 会报错 —— 因为基类函数被隐藏了！</p></blockquote><hr><h2 id="4️⃣-改变继承成员的访问权限（C-11）"><a href="#4️⃣-改变继承成员的访问权限（C-11）" class="headerlink" title="4️⃣ 改变继承成员的访问权限（C++11）"></a>4️⃣ 改变继承成员的访问权限（C++11）</h2><p>在派生类中，可以用 <code>using</code> 提升或改变从基类继承的成员的访问级别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">protectedFunc</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Protected&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publicFunc</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Public&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123; <span class="comment">// 私有继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::publicFunc;     <span class="comment">// 保持 public</span></span><br><span class="line">    <span class="keyword">using</span> Base::protectedFunc;  <span class="comment">// 提升为 public ✅</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">publicFunc</span>();     <span class="comment">// ✅</span></span><br><span class="line">    d.<span class="built_in">protectedFunc</span>();  <span class="comment">// ✅ 现在可以访问了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>📌 注意：不能用 <code>using</code> 降低访问权限（比如 public → private），只能提升或保持。</p></blockquote><hr><h2 id="5️⃣-在模板中引入依赖基类成员（解决编译错误）"><a href="#5️⃣-在模板中引入依赖基类成员（解决编译错误）" class="headerlink" title="5️⃣ 在模板中引入依赖基类成员（解决编译错误）"></a>5️⃣ 在模板中引入依赖基类成员（解决编译错误）</h2><p>在模板派生类中访问基类成员时，有时编译器无法识别，需用 <code>using</code> 或 <code>this-&gt;</code> 显式声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base&lt;T&gt;::value; <span class="comment">// ✅ 显式引入依赖基类成员</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl; <span class="comment">// 现在可以访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>💡 原因：在模板中，基类是依赖名称（dependent name），编译器默认不查找基类作用域。</p></blockquote><hr><h2 id="📋-总结：using-的五大用途"><a href="#📋-总结：using-的五大用途" class="headerlink" title="📋 总结：using 的五大用途"></a>📋 总结：<code>using</code> 的五大用途</h2><table><thead><tr><th>用途</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>1️⃣ 引入命名空间成员</td><td><code>using std::cout;</code></td><td>避免写 <code>std::</code>，更安全</td></tr><tr><td>2️⃣ 定义类型别名</td><td><code>using IntVec = std::vector&lt;int&gt;;</code></td><td>替代 <code>typedef</code>，支持模板</td></tr><tr><td>3️⃣ 引入基类函数</td><td><code>using Base::func;</code></td><td>解决派生类函数隐藏问题</td></tr><tr><td>4️⃣ 改变访问权限</td><td><code>using Base::func;</code>（在 public 下）</td><td>提升继承成员访问级别</td></tr><tr><td>5️⃣ 模板中引入基类成员</td><td><code>using Base&lt;T&gt;::member;</code></td><td>解决依赖名称查找问题</td></tr></tbody></table><hr><h2 id="💡-最佳实践建议"><a href="#💡-最佳实践建议" class="headerlink" title="💡 最佳实践建议"></a>💡 最佳实践建议</h2><ul><li>✅ 优先使用 <code>using</code> 定义类型别名（特别是模板别名）</li><li>✅ 在类中使用 <code>using</code> 解决函数重载隐藏问题</li><li>✅ 在 <code>.cpp</code> 文件中局部使用 <code>using namespace xxx;</code>，避免在头文件中使用</li><li>✅ 在模板派生类中，对基类成员使用 <code>using</code> 或 <code>this-&gt;</code> 避免编译错误</li><li>❌ 不要用 <code>using</code> 降低访问权限（语法不允许）</li></ul><hr><h2 id="🧠-小测验"><a href="#🧠-小测验" class="headerlink" title="🧠 小测验"></a>🧠 小测验</h2><p>下面代码能否编译通过？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">5</span>); <span class="comment">// ❓ 会调用哪个？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>❌ 编译错误！<code>A::foo(int)</code> 被 <code>B::foo(double)</code> 隐藏了。<br>✅ 解决方案：在 <code>B</code> 中添加 <code>using A::foo;</code></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;📘-C-中-using-关键字的用法详解&quot;&gt;&lt;a href=&quot;#📘-C-中-using-关键字的用法详解&quot; class=&quot;headerlink&quot; title=&quot;📘 C++ 中 using 关键字的用法详解&quot;&gt;&lt;/a&gt;📘 C++ 中 &lt;code&gt;using&lt;/code&gt; 关键字的用法详解&lt;/h1&gt;&lt;p&gt;在 C++ 中，&lt;code&gt;using&lt;/code&gt; 关键字功能强大且用途多样，从 C++11 开始更是得到了显著增强。它主要用于简化代码、提高可读性、解决继承中的函数隐藏问题等。以下是 &lt;code&gt;using&lt;/code&gt; 在 C++ 中的&lt;strong&gt;主要用法详解&lt;/strong&gt;：&lt;/p&gt;</summary>
    
    
    
    
    <category term="c++" scheme="https://lyroom.github.io/tags/c/"/>
    
    <category term="朝花夕拾" scheme="https://lyroom.github.io/tags/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
  </entry>
  
  <entry>
    <title>C++朝花夕拾-缺省</title>
    <link href="https://lyroom.github.io/2025/09/19/C-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%E7%BC%BA%E7%9C%81/"/>
    <id>https://lyroom.github.io/2025/09/19/C-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%E7%BC%BA%E7%9C%81/</id>
    <published>2025-09-19T09:51:05.000Z</published>
    <updated>2025-09-19T09:51:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="📘-c-朝花夕拾-缺省"><a href="#📘-c-朝花夕拾-缺省" class="headerlink" title="📘 c++朝花夕拾-缺省"></a>📘 c++朝花夕拾-缺省</h1><p> 在C++中，“缺省”（Default）是一个核心概念，主要指<strong>系统、编译器或程序员预先设定的默认值或行为</strong>，当用户未显式提供具体值或指令时，程序将自动采用这些预设值。以下从多个维度系统解析“缺省”的含义、应用场景及注意事项：<br> <span id="more"></span></p><h2 id="🔑-1-缺省的核心含义"><a href="#🔑-1-缺省的核心含义" class="headerlink" title="🔑 1. 缺省的核心含义"></a><strong>🔑 1. 缺省的核心含义</strong></h2><ul><li><strong>本质</strong>：缺省是“预设的默认状态”，用于简化代码编写、减少冗余参数传递，同时保持灵活性，甚至以下<strong>可以把“缺省”两个字改成“默认”</strong>也不影响逻辑。</li><li><strong>关键特性</strong>：<ul><li><strong>可覆盖性</strong>：用户可显式提供值覆盖缺省设置。</li><li><strong>上下文依赖性</strong>：缺省行为可能因编译器、标准版本或代码上下文而异。</li><li><strong>隐式生效</strong>：在未明确指定时自动激活，无需额外代码。</li></ul></li></ul><h2 id="🧩-2-主要应用场景"><a href="#🧩-2-主要应用场景" class="headerlink" title="🧩 2. 主要应用场景"></a><strong>🧩 2. 主要应用场景</strong></h2><h3 id="（1）函数默认参数"><a href="#（1）函数默认参数" class="headerlink" title="（1）函数默认参数"></a><strong>（1）函数默认参数</strong></h3><ul><li><strong>定义</strong>：在函数声明或定义时为参数指定默认值，调用时可省略该参数。</li><li><strong>规则</strong>：<ul><li>默认参数需从右向左连续指定（如<code>void func(int a, int b=2, int c=3)</code>合法，但<code>void func(int a=1, int b, int c=3)</code>非法）。</li><li>默认参数通常在函数声明中指定（而非定义），以避免多重定义冲突。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> value = <span class="number">42</span>)</span> </span>&#123;  <span class="comment">// 缺省参数 value=42</span></span><br><span class="line">    std::cout &lt;&lt; value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>();    <span class="comment">// 输出 42（使用缺省值）</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">100</span>); <span class="comment">// 输出 100（覆盖缺省值）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="（2）类与结构体的默认成员初始化"><a href="#（2）类与结构体的默认成员初始化" class="headerlink" title="（2）类与结构体的默认成员初始化"></a><strong>（2）类与结构体的默认成员初始化</strong></h3><ul><li><strong>C++11及以上</strong>：可在类&#x2F;结构体中直接为成员变量指定默认值。</li><li><strong>优势</strong>：避免未初始化导致的未定义行为，简化构造函数。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;  <span class="comment">// 缺省值 0</span></span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;  <span class="comment">// 缺省值 0</span></span><br><span class="line">&#125;;</span><br><span class="line">Point p1;  <span class="comment">// p1.x=0, p1.y=0</span></span><br><span class="line">Point p2&#123;<span class="number">5</span>&#125;; <span class="comment">// p2.x=5, p2.y=0（覆盖 x 的缺省值）</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="（3）模板参数的默认类型"><a href="#（3）模板参数的默认类型" class="headerlink" title="（3）模板参数的默认类型"></a><strong>（3）模板参数的默认类型</strong></h3><ul><li><strong>定义</strong>：模板参数可指定默认类型，使模板实例化时无需显式提供类型。</li><li><strong>规则</strong>：默认类型需符合模板的语义要求（如可复制、可比较等）。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;  <span class="comment">// 缺省模板参数 T=int</span></span><br><span class="line"><span class="keyword">class</span> Box &#123;</span><br><span class="line">    T data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Box&lt;&gt; b1;    <span class="comment">// 等价于 Box&lt;int&gt; b1;</span></span><br><span class="line">Box&lt;<span class="type">double</span>&gt; b2; <span class="comment">// 覆盖缺省类型</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="（4）构造函数与特殊成员函数的默认生成"><a href="#（4）构造函数与特殊成员函数的默认生成" class="headerlink" title="（4）构造函数与特殊成员函数的默认生成"></a><strong>（4）构造函数与特殊成员函数的默认生成</strong></h3><ul><li>**<code>= default</code>**：显式要求编译器生成默认的构造函数、析构函数、拷贝构造函数、拷贝赋值运算符等。</li><li><strong>适用场景</strong>：当类需要默认行为（如浅拷贝）但未显式定义时。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() = <span class="keyword">default</span>;  <span class="comment">// 缺省构造函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() = <span class="keyword">default</span>; <span class="comment">// 缺省析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="（5）标准库容器的默认行为"><a href="#（5）标准库容器的默认行为" class="headerlink" title="（5）标准库容器的默认行为"></a><strong>（5）标准库容器的默认行为</strong></h3><ul><li><strong>容器初始化</strong>：如<code>std::vector&lt;int&gt; v;</code>默认构造空向量，<code>std::map&lt;int, std::string&gt; m;</code>默认构造空映射。</li><li><strong>算法默认参数</strong>：如<code>std::sort(v.begin(), v.end())</code>默认使用<code>&lt;</code>比较元素。</li></ul><h2 id="⚠️-3-缺省值的潜在风险与注意事项"><a href="#⚠️-3-缺省值的潜在风险与注意事项" class="headerlink" title="⚠️ 3. 缺省值的潜在风险与注意事项"></a><strong>⚠️ 3. 缺省值的潜在风险与注意事项</strong></h2><h3 id="（1）函数重载歧义"><a href="#（1）函数重载歧义" class="headerlink" title="（1）函数重载歧义"></a><strong>（1）函数重载歧义</strong></h3><ul><li>当多个函数具有相同参数数量但不同默认参数时，调用可能因默认参数导致歧义。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">int</span> level)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> std::string &amp;message = <span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">log</span>(<span class="number">1</span>); <span class="comment">// 编译错误：调用存在歧义（匹配第一个还是第二个？）</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="（2）默认值变更的影响"><a href="#（2）默认值变更的影响" class="headerlink" title="（2）默认值变更的影响"></a><strong>（2）默认值变更的影响</strong></h3><ul><li>修改函数的默认参数值可能破坏现有代码（如从<code>func(int a=1)</code>改为<code>func(int a=2)</code>）。</li><li>需谨慎对待公共API的默认参数，避免频繁变更。</li></ul><h3 id="（3）性能与可读性权衡"><a href="#（3）性能与可读性权衡" class="headerlink" title="（3）性能与可读性权衡"></a><strong>（3）性能与可读性权衡</strong></h3><ul><li>过度使用默认参数可能隐藏函数依赖关系，降低代码可读性。</li><li>对于大型对象，默认参数可能导致不必要的拷贝（需结合引用传递优化）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> std::string&amp; name = <span class="string">&quot;default&quot;</span>)</span></span>; <span class="comment">// ✅ 推荐</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(std::string name = <span class="string">&quot;default&quot;</span>)</span></span>;        <span class="comment">// ❌ 可能拷贝</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="（4）与const的交互"><a href="#（4）与const的交互" class="headerlink" title="（4）与const的交互"></a><strong>（4）与<code>const</code>的交互</strong></h3><ul><li>默认参数不能是局部变量或需要计算的表达式（需为编译时常量或可求值表达式）。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x = calc())</span></span>; <span class="comment">// 错误：默认参数需为常量表达式</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-默认参数与头文件管理"><a href="#5-默认参数与头文件管理" class="headerlink" title="(5) 默认参数与头文件管理"></a><strong>(5) 默认参数与头文件管理</strong></h3><ul><li>默认参数写在<strong>头文件声明</strong>中，而非 <code>.cpp</code> 实现文件</li><li>否则不同编译单元看到不同默认值 → 链接错误或行为不一致</li></ul><h2 id="📈-4-缺省与C-标准的演变"><a href="#📈-4-缺省与C-标准的演变" class="headerlink" title="📈 4. 缺省与C++标准的演变"></a><strong>📈 4. 缺省与C++标准的演变</strong></h2><ul><li><strong>C++98&#x2F;03</strong>：支持函数默认参数、类成员默认初始化（需在构造函数中完成）。</li><li><strong>C++11</strong>：引入类成员直接默认初始化（如<code>int x=0;</code>）、<code>= default</code>语法、模板默认参数。</li><li><strong>C++17&#x2F;20</strong>：进一步强化常量表达式、结构化绑定等特性，使缺省值更安全、灵活。</li></ul><h2 id="🎯-5-实际应用中的最佳实践"><a href="#🎯-5-实际应用中的最佳实践" class="headerlink" title="🎯 5. 实际应用中的最佳实践"></a><strong>🎯 5. 实际应用中的最佳实践</strong></h2><ul><li><strong>明确性优先</strong>：在关键函数或公共接口中，避免过度依赖默认参数，可通过重载提供更清晰的接口。</li><li><strong>文档化</strong>：对默认参数的行为进行文档说明，尤其是非直观的逻辑。</li><li><strong>测试覆盖</strong>：确保默认参数路径被单元测试覆盖，避免因缺省值导致逻辑错误。</li><li><strong>避免全局状态</strong>：默认参数不应依赖全局变量或可变状态，以免引发难以追踪的bug。</li></ul><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅  总结"></a><strong>✅  总结</strong></h2><p>C++中的“缺省”是预设默认值或行为的机制，广泛应用于函数参数、类成员初始化、模板实例化等场景。它通过减少冗余代码提升开发效率，但需注意潜在风险（如重载歧义、性能影响）。合理使用缺省机制需结合具体场景，权衡灵活性、可读性与维护成本，同时遵循C++标准的演进方向，确保代码的健壮性与可扩展性。   </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;📘-c-朝花夕拾-缺省&quot;&gt;&lt;a href=&quot;#📘-c-朝花夕拾-缺省&quot; class=&quot;headerlink&quot; title=&quot;📘 c++朝花夕拾-缺省&quot;&gt;&lt;/a&gt;📘 c++朝花夕拾-缺省&lt;/h1&gt;&lt;p&gt; 在C++中，“缺省”（Default）是一个核心概念，主要指&lt;strong&gt;系统、编译器或程序员预先设定的默认值或行为&lt;/strong&gt;，当用户未显式提供具体值或指令时，程序将自动采用这些预设值。以下从多个维度系统解析“缺省”的含义、应用场景及注意事项：&lt;br&gt;</summary>
    
    
    
    
    <category term="c++" scheme="https://lyroom.github.io/tags/c/"/>
    
    <category term="朝花夕拾" scheme="https://lyroom.github.io/tags/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
  </entry>
  
  <entry>
    <title>C++朝花夕拾-形参VS实参</title>
    <link href="https://lyroom.github.io/2025/09/19/C-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%E5%BD%A2%E5%8F%82VS%E5%AE%9E%E5%8F%82/"/>
    <id>https://lyroom.github.io/2025/09/19/C-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%E5%BD%A2%E5%8F%82VS%E5%AE%9E%E5%8F%82/</id>
    <published>2025-09-19T09:33:13.000Z</published>
    <updated>2025-09-19T09:33:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="📘-c-朝花夕拾-形参VS实参"><a href="#📘-c-朝花夕拾-形参VS实参" class="headerlink" title="📘 c++朝花夕拾-形参VS实参"></a>📘 c++朝花夕拾-形参VS实参</h1><p>在C++中，<strong>形参（形式参数）</strong>和<strong>实参（实际参数）</strong>是函数调用机制的核心概念，二者的区别及使用场景需结合C++的语法特性（如值传递、引用传递、指针传递等）深入理解。以下从定义、区别、使用场景及特殊案例四方面系统解析：</p><span id="more"></span><h2 id="1-定义与本质"><a href="#1-定义与本质" class="headerlink" title="1. 定义与本质"></a><strong>1. 定义与本质</strong></h2><ul><li><p><strong>形参（形式参数）</strong><br>在函数<strong>定义</strong>时声明的参数，是函数接口的“占位符”，用于描述函数需要接收的数据类型、结构及数量。<br><em>示例</em>：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;  <span class="comment">// a、b 是形参</span></span><br><span class="line">    std::cout &lt;&lt; a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实参（实际参数）</strong><br>在函数<strong>调用</strong>时实际传递给函数的值或变量，是具体的数据，用于替换形参执行函数逻辑。<br><em>示例</em>：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printSum</span>(<span class="number">3</span>, <span class="number">5</span>);  <span class="comment">// 3 和 5 是实参</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printSum</span>(x, y);  <span class="comment">// x 和 y 是实参</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-核心区别"><a href="#2-核心区别" class="headerlink" title="2. 核心区别"></a><strong>2. 核心区别</strong></h2><table><thead><tr><th><strong>对比维度</strong></th><th><strong>形参</strong></th><th><strong>实参</strong></th></tr></thead><tbody><tr><td><strong>存在阶段</strong></td><td>函数定义时声明（编译期确定）</td><td>函数调用时传递（运行时确定）</td></tr><tr><td><strong>作用范围</strong></td><td>仅在函数内部有效（局部作用域）</td><td>由外部作用域决定（如全局变量、局部变量）</td></tr><tr><td><strong>生命周期</strong></td><td>函数调用时创建，调用结束销毁</td><td>由外部作用域决定（如全局变量持续存在）</td></tr><tr><td><strong>内存占用</strong></td><td>不占用实际内存（符号引用）</td><td>占用具体内存（存储实际值或地址）</td></tr><tr><td><strong>修改影响</strong></td><td>修改形参仅影响函数内部逻辑</td><td>修改实参可能影响外部数据（需看传递方式）</td></tr><tr><td><strong>类型要求</strong></td><td>需明确指定类型（如<code>int</code>、<code>float</code>）</td><td>需与形参类型兼容（或可隐式转换）</td></tr></tbody></table><h2 id="3-传递方式与影响"><a href="#3-传递方式与影响" class="headerlink" title="3. 传递方式与影响"></a><strong>3. 传递方式与影响</strong></h2><p>C++中参数传递的本质是<strong>数据复制</strong>或<strong>地址传递</strong>，具体分为以下三种方式：</p><h3 id="（1）值传递（Pass-by-Value）"><a href="#（1）值传递（Pass-by-Value）" class="headerlink" title="（1）值传递（Pass by Value）"></a><strong>（1）值传递（Pass by Value）</strong></h3><ul><li><strong>机制</strong>：实参将<strong>值</strong>复制给形参，函数内修改形参不影响外部实参。  </li><li><strong>适用场景</strong>：不可变类型（如<code>int</code>、<code>double</code>、<code>struct</code>）或需保护实参不被修改的场景。  </li><li><em>示例</em>：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeValue</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">100</span>;  <span class="comment">// 修改形参，不影响外部实参</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">changeValue</span>(x);</span><br><span class="line">    std::cout &lt;&lt; x;  <span class="comment">// 输出 5（x 未被修改）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="（2）引用传递（Pass-by-Reference）"><a href="#（2）引用传递（Pass-by-Reference）" class="headerlink" title="（2）引用传递（Pass by Reference）"></a><strong>（2）引用传递（Pass by Reference）</strong></h3><ul><li><strong>机制</strong>：实参将<strong>引用（地址）</strong>传递给形参，函数内修改形参会直接影响外部实参。  </li><li><strong>适用场景</strong>：可变类型（如数组、类对象）或需在函数内修改外部数据的场景（如交换两个变量）。  </li><li><em>示例</em>：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123;  <span class="comment">// a、b 是引用形参</span></span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">swap</span>(x, y);  <span class="comment">// 传递变量引用</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y;  <span class="comment">// 输出 10 5（x、y 被交换）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="（3）指针传递（Pass-by-Pointer）"><a href="#（3）指针传递（Pass-by-Pointer）" class="headerlink" title="（3）指针传递（Pass by Pointer）"></a><strong>（3）指针传递（Pass by Pointer）</strong></h3><ul><li><strong>机制</strong>：实参将<strong>指针（地址）</strong>传递给形参，函数内通过指针修改指向的内存。  </li><li><strong>适用场景</strong>：需动态内存操作、数组遍历或兼容C语言接口的场景。  </li><li><em>示例</em>：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyArray</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        arr[i] *= <span class="number">2</span>;  <span class="comment">// 通过指针修改外部数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">modifyArray</span>(arr, <span class="number">3</span>);  <span class="comment">// 传递数组首地址</span></span><br><span class="line">    <span class="comment">// arr 变为 &#123;2, 4, 6&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-使用场景与最佳实践"><a href="#4-使用场景与最佳实践" class="headerlink" title="4. 使用场景与最佳实践"></a><strong>4. 使用场景与最佳实践</strong></h2><ul><li><p><strong>使用形参的场景</strong>  </p><ul><li>定义函数接口时，明确需要哪些输入（如<code>double calculateArea(double length, double width)</code>）。  </li><li>设置默认值（C++11起支持<code>= default</code>或显式默认值），使参数可省略（如<code>void greet(const std::string &amp;name = &quot;游客&quot;)</code>）。  </li><li>限制参数类型（通过类型提示）或使用<code>const</code>保护形参不被修改（如<code>void process(const std::vector&lt;int&gt; &amp;data)</code>）。  </li><li>实现函数重载（通过形参类型、数量或顺序区分同名函数）。</li></ul></li><li><p><strong>使用实参的场景</strong>  </p><ul><li>调用函数时，传递具体值（如<code>calculateArea(5.0, 3.0)</code>）。  </li><li>传递变量、表达式或函数结果（如<code>calculateArea(a+b, c*2)</code>）。  </li><li>传递可变对象（如数组、类对象）以修改外部数据（需使用引用或指针）。  </li><li>传递动态内存地址（如<code>int *ptr = new int[10]; modifyArray(ptr, 10)</code>）。</li></ul></li></ul><h2 id="5-特殊案例与注意事项"><a href="#5-特殊案例与注意事项" class="headerlink" title="5. 特殊案例与注意事项"></a><strong>5. 特殊案例与注意事项</strong></h2><ul><li><p><strong>形参与实参的“错位”</strong>  </p><ul><li><strong>数量不匹配</strong>：调用时实参数量少于形参会报错（如<code>error: too few arguments to function</code>）；过多则可能被忽略或需使用可变参数（如<code>...</code>）。  </li><li><strong>类型不匹配</strong>：如形参要求<code>int</code>，但实参传递<code>float</code>，可能触发隐式转换或编译错误（需看具体类型兼容性）。  </li><li><strong>引用与指针的陷阱</strong>：若形参为引用类型（如<code>int &amp;a</code>），实参必须是可修改的左值（如变量），不能是常量或临时值（如<code>changeValue(10)</code>会报错）。</li></ul></li><li><p><strong>const形参与实参</strong>  </p><ul><li>使用<code>const</code>修饰形参可防止函数内意外修改参数（如<code>void print(const std::string &amp;str)</code>）。  </li><li>实参为<code>const</code>变量时，需确保形参也为<code>const</code>（如<code>const int x = 5; print(x)</code>需形参为<code>const int</code>）。</li></ul></li><li><p><strong>函数重载与形参</strong><br>C++支持通过形参类型、数量或顺序实现函数重载（如<code>void log(int); void log(double);</code>），但需注意重载解析规则（如类型提升、引用折叠）。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>形参是函数接口的“设计图”，定义了函数需要的数据结构；实参是“实际材料”，在调用时填充形参的占位符。二者通过<strong>传递方式</strong>（值、引用、指针）关联，影响数据的复制、修改及内存占用。在C++中，合理选择传递方式（如对大型对象使用引用传递避免拷贝）、利用<code>const</code>保护数据、通过函数重载设计灵活接口，是高效编程的关键。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;📘-c-朝花夕拾-形参VS实参&quot;&gt;&lt;a href=&quot;#📘-c-朝花夕拾-形参VS实参&quot; class=&quot;headerlink&quot; title=&quot;📘 c++朝花夕拾-形参VS实参&quot;&gt;&lt;/a&gt;📘 c++朝花夕拾-形参VS实参&lt;/h1&gt;&lt;p&gt;在C++中，&lt;strong&gt;形参（形式参数）&lt;/strong&gt;和&lt;strong&gt;实参（实际参数）&lt;/strong&gt;是函数调用机制的核心概念，二者的区别及使用场景需结合C++的语法特性（如值传递、引用传递、指针传递等）深入理解。以下从定义、区别、使用场景及特殊案例四方面系统解析：&lt;/p&gt;</summary>
    
    
    
    
    <category term="c++" scheme="https://lyroom.github.io/tags/c/"/>
    
    <category term="朝花夕拾" scheme="https://lyroom.github.io/tags/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
  </entry>
  
  <entry>
    <title>智能指针</title>
    <link href="https://lyroom.github.io/2025/09/19/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>https://lyroom.github.io/2025/09/19/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2025-09-19T04:53:17.000Z</published>
    <updated>2025-09-19T04:53:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>哈哈哈</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;哈哈哈&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="智能指针" scheme="https://lyroom.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
    <category term="c++" scheme="https://lyroom.github.io/tags/c/"/>
    
    <category term="朝花夕拾" scheme="https://lyroom.github.io/tags/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    <category term="指针" scheme="https://lyroom.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++ 程序运行时内存布局</title>
    <link href="https://lyroom.github.io/2025/09/19/C-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    <id>https://lyroom.github.io/2025/09/19/C-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</id>
    <published>2025-09-19T04:26:31.000Z</published>
    <updated>2025-09-19T04:26:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🧠-C-程序运行时内存布局"><a href="#🧠-C-程序运行时内存布局" class="headerlink" title="🧠 C++ 程序运行时内存布局"></a>🧠 C++ 程序运行时内存布局</h1><blockquote><p>📌 适用于理解全局变量、栈、堆、静态区、代码段的存储位置与生命周期。</p></blockquote><p>本文我们主要介绍 C++ 程序运行时内存布局，以及变量存储位置，包括栈、堆、静态存储区等，并附上 ASCII 图解。</p><span id="more"></span><hr><h2 id="🖼️-内存布局示意图（ASCII-图）"><a href="#🖼️-内存布局示意图（ASCII-图）" class="headerlink" title="🖼️ 内存布局示意图（ASCII 图）"></a>🖼️ 内存布局示意图（ASCII 图）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">高地址</span><br><span class="line">┌──────────────────────────────┐  ← 栈顶（向低地址增长）</span><br><span class="line">│         Stack (栈)           │</span><br><span class="line">│  - 局部变量                  │</span><br><span class="line">│  - 函数参数                  │</span><br><span class="line">│  - 返回地址                  │</span><br><span class="line">├──────────────────────────────┤</span><br><span class="line">│                              │  ← 未使用内存（空闲区）</span><br><span class="line">│        （Free Memory）       │</span><br><span class="line">│                              │</span><br><span class="line">├──────────────────────────────┤</span><br><span class="line">│         Heap (堆)            │  ← 堆底（向高地址增长）</span><br><span class="line">│  - new / malloc 分配的对象    │</span><br><span class="line">│  - 动态数据结构              │</span><br><span class="line">├──────────────────────────────┤</span><br><span class="line">│   .bss 段                    │</span><br><span class="line">│  - 未初始化的全局/静态变量     │ → int global_uninit;</span><br><span class="line">├──────────────────────────────┤</span><br><span class="line">│   .data 段                   │</span><br><span class="line">│  - 已初始化的全局/静态变量     │ → int global_init = 100;</span><br><span class="line">│  - static 变量               │</span><br><span class="line">├──────────────────────────────┤</span><br><span class="line">│   .text 段（代码段）          │</span><br><span class="line">│  - 函数机器指令               │ → main(), func() 等</span><br><span class="line">│  - 只读                      │</span><br><span class="line">└──────────────────────────────┘  ← 低地址</span><br></pre></td></tr></table></figure><hr><h2 id="🔍-各内存区域详解"><a href="#🔍-各内存区域详解" class="headerlink" title="🔍 各内存区域详解"></a>🔍 各内存区域详解</h2><h3 id="1️⃣-栈（Stack）"><a href="#1️⃣-栈（Stack）" class="headerlink" title="1️⃣ 栈（Stack）"></a>1️⃣ 栈（Stack）</h3><ul><li><strong>位置</strong>：高地址 → 向低地址增长</li><li><strong>内容</strong>：<ul><li>局部变量</li><li>函数参数</li><li>返回地址</li></ul></li><li><strong>管理方式</strong>：编译器自动分配&#x2F;释放</li><li><strong>生命周期</strong>：函数作用域，离开函数后自动释放内存</li><li><strong>特点</strong>：快、安全、容量小（通常几 MB）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="comment">//函数参数 ← 存在栈上</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// 局部变量 ← 存在栈上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>📌 我们常说栈内存是<strong>函数调用栈</strong>，函数调用时，<strong>参数、局部变量</strong>会压入栈中，函数返回时，<strong>参数、局部变量</strong>会从栈中弹出。</p></blockquote><hr><h3 id="2️⃣-堆（Heap）"><a href="#2️⃣-堆（Heap）" class="headerlink" title="2️⃣ 堆（Heap）"></a>2️⃣ 堆（Heap）</h3><ul><li><strong>位置</strong>：静态区之上，栈之下 → 向高地址增长</li><li><strong>内容</strong>：<ul><li><code>new</code> &#x2F; <code>malloc</code> 分配的对象</li><li>动态数组、对象、容器底层存储等</li></ul></li><li><strong>管理方式</strong>：手动 <code>delete</code> &#x2F; <code>free</code> 或使用智能指针（推荐）</li><li><strong>生命周期</strong>：由程序员控制</li><li><strong>特点</strong>：慢、灵活、容量大</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>); <span class="comment">// ← p指向对象在堆，p 指针变量在栈</span></span><br></pre></td></tr></table></figure><hr><h3 id="3️⃣-静态存储区（Data-Segment）"><a href="#3️⃣-静态存储区（Data-Segment）" class="headerlink" title="3️⃣ 静态存储区（Data Segment）"></a>3️⃣ 静态存储区（Data Segment）</h3><h4 id="➤-data-段"><a href="#➤-data-段" class="headerlink" title="➤ .data 段"></a>➤ <code>.data</code> 段</h4><ul><li>存放<strong>已初始化</strong>的全局变量和静态变量</li><li>示例：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_var = <span class="number">999</span>;      <span class="comment">// ← .data</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s = <span class="number">100</span>;        <span class="comment">// ← .data</span></span><br></pre></td></tr></table></figure><h4 id="➤-bss-段"><a href="#➤-bss-段" class="headerlink" title="➤ .bss 段"></a>➤ <code>.bss</code> 段</h4><ul><li>存放<strong>未初始化或初始化为 0</strong> 的全局&#x2F;静态变量</li><li>示例：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> uninit_global;         <span class="comment">// ← .bss（默认=0）</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> zero_static = <span class="number">0</span>; <span class="comment">// ← 通常优化进 .bss</span></span><br></pre></td></tr></table></figure><blockquote><p>💡 <strong>为什么分 <code>.data</code> 和 <code>.bss</code>？</strong><br><code>.data</code> 需保存初始值 → 占用可执行文件空间；<br><code>.bss</code> 只需记录大小 → 加载时清零 → 节省磁盘空间。</p></blockquote><hr><h3 id="4️⃣-代码段（-text）"><a href="#4️⃣-代码段（-text）" class="headerlink" title="4️⃣ 代码段（.text）"></a>4️⃣ 代码段（.text）</h3><ul><li><strong>内容</strong>：程序的机器指令（函数体）</li><li><strong>属性</strong>：只读、不可修改</li><li><strong>示例</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125; <span class="comment">// ← 函数代码存在 .text 段</span></span><br></pre></td></tr></table></figure><hr><h2 id="🧭-地址增长方向示意"><a href="#🧭-地址增长方向示意" class="headerlink" title="🧭 地址增长方向示意"></a>🧭 地址增长方向示意</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">高地址 ────────────────┐</span><br><span class="line">                       ↓ 栈向下增长（函数调用压栈）</span><br><span class="line">       ┌───────────────┤</span><br><span class="line">       │   Stack       │</span><br><span class="line">       ├───────────────┤</span><br><span class="line">       │   (Free)      │</span><br><span class="line">       ├───────────────┤</span><br><span class="line">       │   Heap        │</span><br><span class="line">       └───────────────┤</span><br><span class="line">                       ↑ 堆向上增长（new 分配内存）</span><br><span class="line">低地址 ────────────────┘</span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 实际地址分布可能因操作系统、编译器、架构略有不同，但“栈向下、堆向上”是常见模型。</p></blockquote><hr><h2 id="🧪-示例代码-地址输出示意"><a href="#🧪-示例代码-地址输出示意" class="headerlink" title="🧪 示例代码 + 地址输出示意"></a>🧪 示例代码 + 地址输出示意</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_data = <span class="number">100</span>;     <span class="comment">// → .data</span></span><br><span class="line"><span class="type">int</span> global_bss;            <span class="comment">// → .bss</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> local_stack = <span class="number">200</span>;           <span class="comment">// → 栈</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> local_static = <span class="number">300</span>;   <span class="comment">// → .data（静态局部变量）</span></span><br><span class="line">    <span class="type">int</span>* heap_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">400</span>);    <span class="comment">// → 堆对象，指针变量在栈</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;global_data (.data): &quot;</span> &lt;&lt; &amp;global_data &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;global_bss  (.bss) : &quot;</span> &lt;&lt; &amp;global_bss &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;local_static(.data): &quot;</span> &lt;&lt; &amp;local_static &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;local_stack (stack): &quot;</span> &lt;&lt; &amp;local_stack &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;heap object (heap) : &quot;</span> &lt;&lt; heap_ptr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> heap_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>📌 <strong>典型输出地址顺序（64位 Linux 示例）</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">global_data:  0x555555558010  ← .data（低地址区）</span><br><span class="line">global_bss:   0x555555558014  ← .bss（紧邻 .data）</span><br><span class="line">local_static: 0x555555558018  ← 静态区</span><br><span class="line">local_stack:  0x7fffffffdc8c  ← 栈（高地址）</span><br><span class="line">heap object:  0x555555579eb0  ← 堆（中间地址）</span><br></pre></td></tr></table></figure><hr><h2 id="✅-总结口诀"><a href="#✅-总结口诀" class="headerlink" title="✅ 总结口诀"></a>✅ 总结口诀</h2><blockquote><p><strong>“代码垫底，数据居中，堆往上爬，栈往下降，全局静态稳如泰山。”</strong></p></blockquote><hr><h2 id="📚-附：变量存储位置速查表"><a href="#📚-附：变量存储位置速查表" class="headerlink" title="📚 附：变量存储位置速查表"></a>📚 附：变量存储位置速查表</h2><table><thead><tr><th>变量类型</th><th>存储位置</th><th>生命周期</th><th>是否需要手动管理</th></tr></thead><tbody><tr><td>全局变量</td><td>静态区（.data&#x2F;.bss）</td><td>整个程序运行期</td><td>❌ 否</td></tr><tr><td>静态局部变量</td><td>静态区</td><td>整个程序运行期</td><td>❌ 否</td></tr><tr><td>局部变量</td><td>栈</td><td>函数作用域</td><td>❌ 自动管理</td></tr><tr><td><code>new</code> &#x2F; <code>malloc</code> 对象</td><td>堆</td><td>手动控制</td><td>✅ 是（或智能指针）</td></tr><tr><td>函数代码</td><td>代码段（.text）</td><td>整个程序运行期</td><td>❌ 只读不可修改</td></tr></tbody></table><hr><p>📌 <strong>学习建议</strong>：配合调试器（如 GDB）或打印变量地址，亲自观察内存分布，理解更深刻！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;🧠-C-程序运行时内存布局&quot;&gt;&lt;a href=&quot;#🧠-C-程序运行时内存布局&quot; class=&quot;headerlink&quot; title=&quot;🧠 C++ 程序运行时内存布局&quot;&gt;&lt;/a&gt;🧠 C++ 程序运行时内存布局&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;📌 适用于理解全局变量、栈、堆、静态区、代码段的存储位置与生命周期。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文我们主要介绍 C++ 程序运行时内存布局，以及变量存储位置，包括栈、堆、静态存储区等，并附上 ASCII 图解。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://lyroom.github.io/tags/C/"/>
    
    <category term="内存" scheme="https://lyroom.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>top命令解析</title>
    <link href="https://lyroom.github.io/2025/09/16/top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/"/>
    <id>https://lyroom.github.io/2025/09/16/top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/</id>
    <published>2025-09-16T04:16:44.000Z</published>
    <updated>2025-09-16T04:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="🐧-Linux-命令解析（杂记）——-top-命令详解"><a href="#🐧-Linux-命令解析（杂记）——-top-命令详解" class="headerlink" title="🐧 Linux 命令解析（杂记）—— top 命令详解"></a>🐧 Linux 命令解析（杂记）—— <code>top</code> 命令详解</h1><blockquote><p><code>top</code> 是 Linux 系统中最常用的实时性能监控工具，用于动态查看系统资源使用情况和进程状态。本文将结合真实输出示例，逐行逐列解析其含义，并提供实用诊断技巧。</p></blockquote><hr><span id="more"></span><h2 id="📊-一、实战示例：top-完整输出"><a href="#📊-一、实战示例：top-完整输出" class="headerlink" title="📊 一、实战示例：top 完整输出"></a>📊 一、实战示例：<code>top</code> 完整输出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@armbian:~<span class="comment"># top</span></span><br><span class="line">top - 12:20:30 up  2:23,  1 user,  load average: 0.00, 0.01, 0.00</span><br><span class="line">Tasks: 236 total,   1 running, 235 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.5 us,  0.9 sy,  0.0 ni, 98.6 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st </span><br><span class="line">MiB Mem :   1801.0 total,    132.6 free,    928.2 used,    892.1 buff/cache     </span><br><span class="line">MiB Swap:      0.0 total,      0.0 free,      0.0 used.    872.8 avail Mem </span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                     </span><br><span class="line">   2472 1000      20   0 1299292  49084  32056 S   1.0   2.7   1:25.30 kernel                                                      </span><br><span class="line">  43581 root      20   0   11628   4768   2884 R   1.0   0.3   0:00.16 top                                                         </span><br><span class="line">    310 root      rt   0       0      0      0 S   0.7   0.0   0:48.36 sugov:0                                                     </span><br><span class="line">    643 root      -2   0       0      0      0 S   0.3   0.0   0:33.40 ksdioirqd/mmc0                                              </span><br><span class="line">   1452 root      20   0 3445756  57160  33332 S   0.3   3.1   0:10.08 dockerd                                                     </span><br><span class="line">   2438 root      20   0    1668   1100    820 S   0.3   0.1   0:25.89 procd                                                       </span><br><span class="line">   2629 root      20   0   85704  22124   9184 S   0.3   1.2   0:24.84 clouddrive                                                  </span><br></pre></td></tr></table></figure><hr><h2 id="🧭-二、全局系统信息详解（前5行）"><a href="#🧭-二、全局系统信息详解（前5行）" class="headerlink" title="🧭 二、全局系统信息详解（前5行）"></a>🧭 二、全局系统信息详解（前5行）</h2><h3 id="🔹-第1行：系统运行时间-amp-负载平均值"><a href="#🔹-第1行：系统运行时间-amp-负载平均值" class="headerlink" title="🔹 第1行：系统运行时间 &amp; 负载平均值"></a>🔹 第1行：系统运行时间 &amp; 负载平均值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top - 12:20:30 up 2:23, 1 user, load average: 0.00, 0.01, 0.00</span><br></pre></td></tr></table></figure><ul><li><strong>当前时间</strong>：12:20:30</li><li><strong>运行时间</strong>：2小时23分钟（新启动系统）</li><li><strong>登录用户</strong>：1 个用户（root）</li><li><strong>负载平均值</strong>：<ul><li>1分钟：0.00 → 几乎无负载</li><li>5分钟：0.01 → 极轻负载</li><li>15分钟：0.00 → 非常空闲</li></ul></li></ul><blockquote><p>✅ 系统非常健康，无过载风险（即使单核 CPU 也远未满载）</p></blockquote><hr><h3 id="🔹-第2行：任务（进程）统计"><a href="#🔹-第2行：任务（进程）统计" class="headerlink" title="🔹 第2行：任务（进程）统计"></a>🔹 第2行：任务（进程）统计</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tasks: 236 total, 1 running, 235 sleeping, 0 stopped, 0 zombie</span><br></pre></td></tr></table></figure><ul><li><strong>总进程数</strong>：236</li><li><strong>运行中</strong>：1 个（就是 <code>top</code> 自己）</li><li><strong>睡眠中</strong>：235 个（正常，大部分后台服务都在等待）</li><li><strong>僵尸进程</strong>：0 → ✅ 健康！</li></ul><hr><h3 id="🔹-第3行：CPU-使用情况"><a href="#🔹-第3行：CPU-使用情况" class="headerlink" title="🔹 第3行：CPU 使用情况"></a>🔹 第3行：CPU 使用情况</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%Cpu(s): 0.5 us, 0.9 sy, 0.0 ni, 98.6 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</span><br></pre></td></tr></table></figure><ul><li><strong>用户空间</strong>（us）：0.5% → 用户程序占用极低</li><li><strong>内核空间</strong>（sy）：0.9% → 系统调用&#x2F;驱动占用也很低</li><li><strong>空闲</strong>（id）：98.6% → CPU 几乎完全空闲</li><li><strong>I&#x2F;O 等待</strong>（wa）：0.0% → 无磁盘&#x2F;网络瓶颈</li><li><strong>虚拟机偷取</strong>（st）：0.0% → 不是虚拟机或未被抢占</li></ul><blockquote><p>✅ CPU 资源充足，无任何瓶颈</p></blockquote><hr><h3 id="🔹-第4行：物理内存（RAM）使用情况"><a href="#🔹-第4行：物理内存（RAM）使用情况" class="headerlink" title="🔹 第4行：物理内存（RAM）使用情况"></a>🔹 第4行：物理内存（RAM）使用情况</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MiB Mem : 1801.0 total, 132.6 free, 928.2 used, 892.1 buff/cache</span><br></pre></td></tr></table></figure><ul><li><strong>总内存</strong>：1801 MiB ≈ <strong>1.76 GB</strong></li><li><strong>空闲内存</strong>：132.6 MiB（⚠️ Linux 会缓存，此值小是正常的）</li><li><strong>已使用</strong>：928.2 MiB（含缓存）</li><li><strong>缓冲&#x2F;缓存</strong>：892.1 MiB → 可被快速回收供程序使用</li></ul><hr><h3 id="🔹-第5行：Swap-与可用内存"><a href="#🔹-第5行：Swap-与可用内存" class="headerlink" title="🔹 第5行：Swap 与可用内存"></a>🔹 第5行：Swap 与可用内存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MiB Swap: 0.0 total, 0.0 free, 0.0 used. 872.8 avail Mem</span><br></pre></td></tr></table></figure><ul><li><strong>交换分区</strong>：未配置（total&#x3D;0）→ 嵌入式&#x2F;轻量系统常见</li><li><strong>可用内存</strong>（avail Mem）：<strong>872.8 MiB</strong> → ✅ 内存充足！</li></ul><blockquote><p>💡 尽管 <code>used=928.2 MiB</code>，但 <code>avail Mem=872.8 MiB</code>，说明系统仍有近一半内存可立即分配给新进程，<strong>无内存压力</strong>。</p></blockquote><hr><h2 id="📋-三、进程列表各列详解（结合示例）"><a href="#📋-三、进程列表各列详解（结合示例）" class="headerlink" title="📋 三、进程列表各列详解（结合示例）"></a>📋 三、进程列表各列详解（结合示例）</h2><table><thead><tr><th>列名</th><th>含义说明</th><th>示例解析（来自上方输出）</th></tr></thead><tbody><tr><td><strong>PID</strong></td><td>进程 ID</td><td><code>43581</code> 是当前运行的 <code>top</code> 进程</td></tr><tr><td><strong>USER</strong></td><td>进程所有者</td><td><code>root</code> 或 <code>1000</code>（普通用户）</td></tr><tr><td><strong>PR</strong></td><td>调度优先级。<code>rt</code> &#x3D; 实时优先级</td><td><code>sugov:0</code> 的 <code>PR=rt</code>，是内核调度器线程</td></tr><tr><td><strong>NI</strong></td><td>Nice 值（-20~19），影响优先级</td><td>多数为 <code>0</code>，<code>ksdioirqd/mmc0</code> 为 <code>-2</code>（高优先级）</td></tr><tr><td><strong>VIRT</strong></td><td>虚拟内存总量（KiB）</td><td><code>kernel</code> 进程：1,299,292 KiB ≈ 1.3 GB</td></tr><tr><td><strong>RES</strong></td><td>常驻物理内存（KiB），真实占用</td><td><code>dockerd</code> 占用 57,160 KiB ≈ 57 MB</td></tr><tr><td><strong>SHR</strong></td><td>共享内存部分</td><td><code>clouddrive</code> 的 9,184 KiB 是共享库内存</td></tr><tr><td><strong>S</strong></td><td>进程状态：<br>• <code>R</code>&#x3D;运行中<br>• <code>S</code>&#x3D;睡眠<br>• <code>Z</code>&#x3D;僵尸等</td><td><code>top</code> 是 <code>R</code>，其余大多是 <code>S</code>（正常）</td></tr><tr><td><strong>%CPU</strong></td><td>CPU 使用率（多核可 &gt;100%）</td><td><code>top</code> 和 <code>kernel</code> 各占 1.0%，极低</td></tr><tr><td><strong>%MEM</strong></td><td>物理内存占用百分比（基于 RES）</td><td><code>dockerd</code> 占 3.1%，是当前内存占用最高的进程</td></tr><tr><td><strong>TIME+</strong></td><td>累计 CPU 时间（分:秒.百分秒）</td><td><code>kernel</code> 已累计使用 1分25秒 CPU 时间</td></tr><tr><td><strong>COMMAND</strong></td><td>启动命令名</td><td><code>clouddrive</code>, <code>dockerd</code>, <code>procd</code> 等</td></tr></tbody></table><hr><h2 id="🛠️-四、实用技巧与诊断建议"><a href="#🛠️-四、实用技巧与诊断建议" class="headerlink" title="🛠️ 四、实用技巧与诊断建议"></a>🛠️ 四、实用技巧与诊断建议</h2><h3 id="🔍-快速定位问题"><a href="#🔍-快速定位问题" class="headerlink" title="🔍 快速定位问题"></a>🔍 快速定位问题</h3><ul><li><strong>CPU 高？</strong> → 看 <code>%CPU</code> 列，按 <code>P</code> 排序</li><li><strong>内存高？</strong> → 看 <code>%MEM</code> 或 <code>RES</code>，按 <code>M</code> 排序</li><li><strong>I&#x2F;O 卡？</strong> → 看全局 <code>wa</code> 是否 &gt; 5%</li><li><strong>僵尸进程？</strong> → 看 Tasks 行 <code>zombie</code> 是否 &gt; 0</li></ul><h3 id="🎯-交互操作（在-top-界面中）"><a href="#🎯-交互操作（在-top-界面中）" class="headerlink" title="🎯 交互操作（在 top 界面中）"></a>🎯 交互操作（在 <code>top</code> 界面中）</h3><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td><code>P</code></td><td>按 CPU 使用率排序</td></tr><tr><td><code>M</code></td><td>按内存使用率排序</td></tr><tr><td><code>T</code></td><td>按运行时间排序</td></tr><tr><td><code>c</code></td><td>显示完整命令行</td></tr><tr><td><code>e</code> &#x2F; <code>E</code></td><td>切换内存单位（进程区&#x2F;全局）</td></tr><tr><td><code>1</code></td><td>显示每个 CPU 核心使用情况</td></tr><tr><td><code>k</code></td><td>杀死指定 PID 进程</td></tr><tr><td><code>q</code></td><td>退出 top</td></tr></tbody></table><h3 id="⚠️-异常关注点（本例中均无）"><a href="#⚠️-异常关注点（本例中均无）" class="headerlink" title="⚠️ 异常关注点（本例中均无）"></a>⚠️ 异常关注点（本例中均无）</h3><ul><li><strong>僵尸进程</strong> → Tasks 行显示 <code>0 zombie</code> ✅</li><li><strong>高 I&#x2F;O 等待</strong> → <code>wa=0.0</code> ✅</li><li><strong>Swap 使用</strong> → <code>Swap used=0.0</code> ✅</li><li><strong>负载过高</strong> → <code>load average</code> 全部 &lt; 0.02 ✅</li></ul><h3 id="🧵-查看线程（进阶）"><a href="#🧵-查看线程（进阶）" class="headerlink" title="🧵 查看线程（进阶）"></a>🧵 查看线程（进阶）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -Hp &lt;PID&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -Hp 2472   <span class="comment"># 查看 PID=2472（kernel）的所有线程</span></span><br></pre></td></tr></table></figure><p>用于定位具体哪个线程占用过高。</p><hr><h2 id="🧩-五、结合示例的诊断结论"><a href="#🧩-五、结合示例的诊断结论" class="headerlink" title="🧩 五、结合示例的诊断结论"></a>🧩 五、结合示例的诊断结论</h2><blockquote><p>💡 <strong>系统整体状态健康，资源充足，无性能瓶颈。</strong></p></blockquote><ul><li><strong>CPU</strong>：98.6% 空闲，无压力</li><li><strong>内存</strong>：可用 872 MiB，无 Swap 使用，无泄漏</li><li><strong>负载</strong>：接近 0，系统极为空闲</li><li><strong>进程</strong>：无僵尸，无异常状态</li><li><strong>热点进程</strong>：<ul><li><code>dockerd</code> 内存占用最高（3.1%）</li><li><code>kernel</code> 和 <code>top</code> 是当前唯二轻微使用 CPU 的进程（各 1.0%）</li></ul></li></ul><hr><h2 id="📌-六、附录：速查表"><a href="#📌-六、附录：速查表" class="headerlink" title="📌 六、附录：速查表"></a>📌 六、附录：速查表</h2><table><thead><tr><th>项目</th><th>正常范围</th><th>本例状态</th><th>是否健康</th></tr></thead><tbody><tr><td>Load Average</td><td>&lt; CPU 核数</td><td>0.00~0.01</td><td>✅</td></tr><tr><td>%CPU idle</td><td>&gt; 20%</td><td>98.6%</td><td>✅</td></tr><tr><td>I&#x2F;O Wait (wa)</td><td>&lt; 5%</td><td>0.0%</td><td>✅</td></tr><tr><td>Zombie 进程</td><td>0</td><td>0</td><td>✅</td></tr><tr><td>Swap Used</td><td>0（或极小）</td><td>0.0</td><td>✅</td></tr><tr><td>Avail Mem</td><td>&gt; 总内存 20%</td><td>872.8 &#x2F; 1801 ≈ 48%</td><td>✅</td></tr></tbody></table><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h2><p>通过 <code>top</code> 命令，我们可以：</p><ol><li><strong>5秒内判断系统整体健康度</strong>（通过前5行全局信息）</li><li><strong>精准定位资源占用大户</strong>（通过进程列表 + 排序）</li><li><strong>发现潜在问题</strong>（僵尸、I&#x2F;O瓶颈、内存泄漏等）</li></ol>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;🐧-Linux-命令解析（杂记）——-top-命令详解&quot;&gt;&lt;a href=&quot;#🐧-Linux-命令解析（杂记）——-top-命令详解&quot; class=&quot;headerlink&quot; title=&quot;🐧 Linux 命令解析（杂记）—— top 命令详解&quot;&gt;&lt;/a&gt;🐧 Linux 命令解析（杂记）—— &lt;code&gt;top&lt;/code&gt; 命令详解&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;top&lt;/code&gt; 是 Linux 系统中最常用的实时性能监控工具，用于动态查看系统资源使用情况和进程状态。本文将结合真实输出示例，逐行逐列解析其含义，并提供实用诊断技巧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://lyroom.github.io/tags/linux/"/>
    
    <category term="top" scheme="https://lyroom.github.io/tags/top/"/>
    
  </entry>
  
  <entry>
    <title>markdown学习</title>
    <link href="https://lyroom.github.io/2025/09/16/markdown%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lyroom.github.io/2025/09/16/markdown%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-09-16T02:03:49.511Z</published>
    <updated>2025-09-16T02:03:49.511Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="📘-Markdown-学习笔记"><a href="#📘-Markdown-学习笔记" class="headerlink" title="📘 Markdown 学习笔记"></a>📘 Markdown 学习笔记</h1><p>程序员必须要会的MarkDown语法，这是写博客的基石，下面我们来简短的学习一下语法。</p><span id="more"></span><h2 id="1️⃣-标题"><a href="#1️⃣-标题" class="headerlink" title="1️⃣ 标题"></a>1️⃣ 标题</h2><p>输入格式：</p><p><code>#（*n）+ 空格 + 标题内容</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="code">`#`</span> 一级标题  </span><br><span class="line"><span class="bullet">-</span> <span class="code">`##`</span> 二级标题  </span><br><span class="line"><span class="bullet">-</span> <span class="code">`###`</span> 三级标题  </span><br><span class="line"><span class="bullet">-</span> <span class="code">`####`</span> 四级标题  </span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br></pre></td></tr></table></figure><hr><h2 id="2️⃣-字体"><a href="#2️⃣-字体" class="headerlink" title="2️⃣ 字体"></a>2️⃣ 字体</h2><ul><li><em>斜体</em>：<code>*文本*</code> → <em>Hello World</em></li><li><strong>加粗</strong>：<code>**文本**</code> → <strong>Hello World</strong></li><li><em><strong>斜体加粗</strong></em>：<code>***文本***</code> → <em><strong>Hello World</strong></em></li><li><del>删除线</del>：<code>~~文本~~</code> → <del>Hello World</del></li></ul><hr><h2 id="3️⃣-引用"><a href="#3️⃣-引用" class="headerlink" title="3️⃣ 引用"></a>3️⃣ 引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一段引用</span></span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>宇宙很大，生活更大</p></blockquote><hr><h2 id="4️⃣-分割线"><a href="#4️⃣-分割线" class="headerlink" title="4️⃣ 分割线"></a>4️⃣ 分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--- </span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><p>效果：</p><hr><hr><hr><h2 id="5️⃣-图片"><a href="#5️⃣-图片" class="headerlink" title="5️⃣ 图片"></a>5️⃣ 图片</h2><p>语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{% asset_img "span>" "<span class="string">图片描述</span>" %}</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">dilireba</span>](<span class="link">markdown学习/dilirebal.jpg</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="6️⃣-超链接"><a href="#6️⃣-超链接" class="headerlink" title="6️⃣ 超链接"></a>6️⃣ 超链接</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">点击跳转到 Henry 的博客</span>](<span class="link">https://lyroom.github.io/</span>)</span><br></pre></td></tr></table></figure><p>效果：<br> <a href="https://lyroom.github.io/">点击跳转到 Henry 的博客</a></p><hr><h2 id="7️⃣-列表"><a href="#7️⃣-列表" class="headerlink" title="7️⃣ 列表"></a>7️⃣ 列表</h2><p>有序列表：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> A</span><br><span class="line"><span class="bullet">2.</span> B</span><br><span class="line"><span class="bullet">3.</span> C</span><br></pre></td></tr></table></figure><p>无序列表：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> A</span><br><span class="line"><span class="bullet">-</span> B</span><br><span class="line"><span class="bullet">-</span> C</span><br></pre></td></tr></table></figure><p>效果：</p><ol><li>A</li><li>B</li><li>C</li></ol><ul><li>A</li><li>B</li><li>C</li></ul><p>任务列表：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [x] 已完成的任务一</span><br><span class="line"><span class="bullet">-</span> [ ] 未完成的任务二</span><br><span class="line"><span class="bullet">-</span> [ ] 未完成的任务三</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li><input checked="" disabled="" type="checkbox"> 已完成的任务一</li><li><input disabled="" type="checkbox"> 未完成的任务二</li><li><input disabled="" type="checkbox"> 未完成的任务三</li></ul><hr><h2 id="8️⃣-表格"><a href="#8️⃣-表格" class="headerlink" title="8️⃣ 表格"></a>8️⃣ 表格</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 名字 | 性别 | 生日 |</span><br><span class="line">| ---- | ---- | ---- |</span><br><span class="line">| 张三 | 男   | 2000 |</span><br><span class="line">| 李四 | 女   | 2001 |</span><br></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th>名字</th><th>性别</th><th>生日</th></tr></thead><tbody><tr><td>张三</td><td>男</td><td>2000</td></tr><tr><td>李四</td><td>女</td><td>2001</td></tr></tbody></table><hr><h2 id="9️⃣-代码块"><a href="#9️⃣-代码块" class="headerlink" title="9️⃣ 代码块"></a>9️⃣ 代码块</h2><p>语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```语言</span></span><br><span class="line"><span class="code">代码内容</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔟-文章截断"><a href="#🔟-文章截断" class="headerlink" title="🔟 文章截断"></a>🔟 文章截断</h2><p>有些博客系统支持 <code>&lt;!--more--&gt;</code> 来截断正文。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="1️⃣1️⃣-高亮文本"><a href="#1️⃣1️⃣-高亮文本" class="headerlink" title="1️⃣1️⃣ 高亮文本"></a>1️⃣1️⃣ 高亮文本</h2><p>语法（部分 Markdown 渲染器支持，如 Typora）：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">==高亮文本==</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">mark</span>&gt;</span></span>高亮文本<span class="language-xml"><span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果：<br> &#x3D;&#x3D;这就是效果&#x3D;&#x3D;<br> <mark>这也是效果</mark></p><hr><h2 id="1️⃣2️⃣-行内代码"><a href="#1️⃣2️⃣-行内代码" class="headerlink" title="1️⃣2️⃣ 行内代码"></a>1️⃣2️⃣ 行内代码</h2><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有一段 `代码` 在行内。</span><br></pre></td></tr></table></figure><p>效果：</p><p>这里有一段 <code>代码</code> 在行内。</p><hr><h2 id="1️⃣3️⃣-换行"><a href="#1️⃣3️⃣-换行" class="headerlink" title="1️⃣3️⃣ 换行"></a>1️⃣3️⃣ 换行</h2><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.行尾加两个空格[space][space]</span><br><span class="line">2.行尾加&lt;br&gt;</span><br><span class="line">3.行尾加反斜杠\</span><br></pre></td></tr></table></figure><h2 id="效果：第一行第二行第三行"><a href="#效果：第一行第二行第三行" class="headerlink" title="效果：第一行第二行第三行\"></a>效果：<br>第一行<br>第二行<br><br>第三行\</h2><h2 id="1️⃣4️⃣-脚注"><a href="#1️⃣4️⃣-脚注" class="headerlink" title="1️⃣4️⃣ 脚注"></a>1️⃣4️⃣ 脚注</h2><p>语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">脚注内容</span>](<span class="link">#脚注 &quot;标题&quot;</span>)</span><br></pre></td></tr></table></figure><p>效果：</p><p><a href="#%E8%84%9A%E6%B3%A8" title="标题">脚注内容</a></p><hr><h2 id="1️⃣5️⃣-数学公式"><a href="#1️⃣5️⃣-数学公式" class="headerlink" title="1️⃣5️⃣ 数学公式"></a>1️⃣5️⃣ 数学公式</h2><p>语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">公式内容</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>效果：</p><p>$$<br>公式内容<br>$$</p><hr><h2 id="1️⃣6️⃣-流程图"><a href="#1️⃣6️⃣-流程图" class="headerlink" title="1️⃣6️⃣ 流程图"></a>1️⃣6️⃣ 流程图</h2><p>语法：</p><h2 id="1️⃣3️⃣-常用符号-amp-Emoji"><a href="#1️⃣3️⃣-常用符号-amp-Emoji" class="headerlink" title="1️⃣3️⃣ 常用符号 &amp; Emoji"></a>1️⃣3️⃣ 常用符号 &amp; Emoji</h2><h3 id="🔹-列表符号"><a href="#🔹-列表符号" class="headerlink" title="🔹 列表符号"></a>🔹 列表符号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 🔹 蓝色小点</span><br><span class="line">- 🔸 橙色小点</span><br><span class="line">- 🔺 红色三角</span><br><span class="line">- 🔻 蓝色三角</span><br><span class="line">- ▶ 箭头</span><br><span class="line">- ➡ 右箭头</span><br><span class="line">- ⬅ 左箭头</span><br><span class="line">- ⬆ 上箭头</span><br><span class="line">- ⬇ 下箭头</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li>🔹 蓝色小点</li><li>🔸 橙色小点</li><li>🔺 红色三角</li><li>🔻 蓝色三角</li><li>▶ 箭头</li><li>➡ 右箭头</li><li>⬅ 左箭头</li><li>⬆ 上箭头</li><li>⬇ 下箭头</li></ul><hr><h3 id="✅-状态符号"><a href="#✅-状态符号" class="headerlink" title="✅ 状态符号"></a>✅ 状态符号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">✅ 成功</span><br><span class="line">❌ 失败</span><br><span class="line">⚠️ 警告</span><br><span class="line">ℹ️ 信息</span><br><span class="line">❓ 疑问</span><br></pre></td></tr></table></figure><p>效果：<br> ✅ 成功<br> ❌ 失败<br> ⚠️ 警告<br> ℹ️ 信息<br> ❓ 疑问</p><hr><h3 id="⭐-重点-x2F-装饰"><a href="#⭐-重点-x2F-装饰" class="headerlink" title="⭐ 重点&#x2F;装饰"></a>⭐ 重点&#x2F;装饰</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">⭐ 星标</span><br><span class="line">✨ 闪光</span><br><span class="line">🔥 火焰</span><br><span class="line">💡 想法</span><br><span class="line">📌 图钉</span><br><span class="line">📎 回形针</span><br><span class="line">📝 记事</span><br><span class="line">📂 文件夹</span><br><span class="line">📦 包裹</span><br></pre></td></tr></table></figure><p>效果：<br> ⭐ 星标<br> ✨ 闪光<br> 🔥 火焰<br> 💡 想法<br> 📌 图钉<br> 📎 回形针<br> 📝 记事<br> 📂 文件夹<br> 📦 包裹</p><hr><h3 id="⏰-时间-x2F-进度"><a href="#⏰-时间-x2F-进度" class="headerlink" title="⏰ 时间&#x2F;进度"></a>⏰ 时间&#x2F;进度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">⏰ 时钟</span><br><span class="line">⌛ 沙漏</span><br><span class="line">🔄 循环</span><br><span class="line">🚀 火箭</span><br></pre></td></tr></table></figure><p>效果：<br> ⏰ 时钟<br> ⌛ 沙漏<br> 🔄 循环<br> 🚀 火箭</p><hr><h3 id="🔗-常用图标"><a href="#🔗-常用图标" class="headerlink" title="🔗 常用图标"></a>🔗 常用图标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">💻 电脑</span><br><span class="line">📱 手机</span><br><span class="line">🌐 地球</span><br><span class="line">🔑 钥匙</span><br><span class="line">🔒 锁</span><br><span class="line">🔓 解锁</span><br><span class="line">⚙️ 齿轮</span><br><span class="line">🖥️ 显示器</span><br></pre></td></tr></table></figure><p>效果：<br> 💻 电脑<br> 📱 手机<br> 🌐 地球<br> 🔑 钥匙<br> 🔒 锁<br> 🔓 解锁<br> ⚙️ 齿轮<br> 🖥️ 显示器</p><hr><h2 id="📌-小技巧"><a href="#📌-小技巧" class="headerlink" title="📌 小技巧"></a>📌 小技巧</h2><ul><li>在 Markdown 里直接复制粘贴 Emoji 即可使用。</li><li>可与 <code>-</code> 或 <code>*</code> 搭配，做成漂亮的列表。</li><li>在标题里用 Emoji，让层次更清晰：</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 🚀 快速开始</span></span><br><span class="line"><span class="section">## ⚙️ 配置方法</span></span><br><span class="line"><span class="section">## 📝 使用示例</span></span><br><span class="line"><span class="section">## ❓ 常见问题</span></span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟markdown</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;📘-Markdown-学习笔记&quot;&gt;&lt;a href=&quot;#📘-Markdown-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;📘 Markdown 学习笔记&quot;&gt;&lt;/a&gt;📘 Markdown 学习笔记&lt;/h1&gt;&lt;p&gt;程序员必须要会的MarkDown语法，这是写博客的基石，下面我们来简短的学习一下语法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Markdown" scheme="https://lyroom.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>linux离线安装软件方法</title>
    <link href="https://lyroom.github.io/2025/09/16/linux%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95/"/>
    <id>https://lyroom.github.io/2025/09/16/linux%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95/</id>
    <published>2025-09-15T16:02:05.000Z</published>
    <updated>2025-09-15T16:02:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🐧-Linux离线安装软件方法"><a href="#🐧-Linux离线安装软件方法" class="headerlink" title="🐧 Linux离线安装软件方法"></a>🐧 Linux离线安装软件方法</h1><p>在离线环境下安装软件时，不仅需要下载主包，还要把依赖包一并下载。这里提供两种情况的处理方法。</p><span id="more"></span><h2 id="跨架构安装软件方法（例如在-x86-上下载-arm64-包）"><a href="#跨架构安装软件方法（例如在-x86-上下载-arm64-包）" class="headerlink" title="跨架构安装软件方法（例如在 x86 上下载 arm64 包）"></a>跨架构安装软件方法（例如在 x86 上下载 arm64 包）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先查看发行版本里面有没有对应的架构和版本</span></span><br><span class="line">apt list -a top</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">apt-cache policy &lt;包名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 添加目标架构支持</span></span><br><span class="line">sudo dpkg --add-architecture arm64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 安装依赖分析工具</span></span><br><span class="line">sudo apt install apt-rdepends</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查看对应包的依赖</span></span><br><span class="line">apt-rdepends &lt;包名&gt;:arm64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 建立目录并进入</span></span><br><span class="line"><span class="built_in">mkdir</span> dependsdep &amp;&amp; <span class="built_in">cd</span> dependsdep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 批量下载依赖包</span></span><br><span class="line">apt-rdepends &lt;包名&gt;:arm64 | grep -E -v <span class="string">&#x27;^ &#x27;</span> | xargs -I&#123;&#125; apt download &#123;&#125;:arm64</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="📌sudo-dpkg-add-architecture-arm64这条命令是永久切换软件包下载吗"><a href="#📌sudo-dpkg-add-architecture-arm64这条命令是永久切换软件包下载吗" class="headerlink" title="📌sudo dpkg --add-architecture arm64这条命令是永久切换软件包下载吗"></a><strong><code>📌sudo dpkg --add-architecture arm64</code>这条命令是永久切换软件包下载吗</strong></h3><p>不是的，不是永久 <strong>切换</strong>，而是永久 <strong>增加</strong> 一种架构支持。</p><h4 id="🔹解释一下"><a href="#🔹解释一下" class="headerlink" title="🔹解释一下"></a>🔹解释一下</h4><ul><li><code>dpkg --print-architecture</code><br> 显示系统的「主架构」（通常是 <code>amd64</code>）。</li><li><code>dpkg --print-foreign-architectures</code><br> 显示系统额外支持的「外部架构」。</li></ul><p>当你执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --add-architecture arm64</span><br></pre></td></tr></table></figure><ul><li>系统会在 <code>/var/lib/dpkg/arch</code> 里记录 <code>arm64</code>。</li><li>以后 <code>apt update</code> 时，就会同时获取 <code>amd64</code> 和 <code>arm64</code> 的软件包信息。</li><li>这样你就可以安装 <code>:arm64</code> 后缀的包（如果源里有）。</li></ul><h4 id="🔹是否“永久”？"><a href="#🔹是否“永久”？" class="headerlink" title="🔹是否“永久”？"></a>🔹是否“永久”？</h4><ul><li>✅ 永久有效（除非你手动删除）。</li><li>❌ 不是切换主架构，主架构仍然是 <code>amd64</code>。</li><li>你可以随时删除：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --remove-architecture arm64</span><br></pre></td></tr></table></figure><h4 id="🔹举个例子"><a href="#🔹举个例子" class="headerlink" title="🔹举个例子"></a>🔹举个例子</h4><ol><li><p>默认情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dpkg --print-architecture</span><br><span class="line"><span class="comment"># amd64</span></span><br><span class="line"></span><br><span class="line">dpkg --print-foreign-architectures</span><br><span class="line"><span class="comment"># （空）</span></span><br></pre></td></tr></table></figure></li><li><p>加了 arm64：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --add-architecture arm64</span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">dpkg --print-architecture</span><br><span class="line"><span class="comment"># amd64</span></span><br><span class="line"></span><br><span class="line">dpkg --print-foreign-architectures</span><br><span class="line"><span class="comment"># arm64</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="同架构安装软件方法（例如-x86-上下载-x86-包）"><a href="#同架构安装软件方法（例如-x86-上下载-x86-包）" class="headerlink" title="同架构安装软件方法（例如 x86 上下载 x86 包）"></a>同架构安装软件方法（例如 x86 上下载 x86 包）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装依赖分析工具</span></span><br><span class="line">sudo apt install apt-rdepends</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查看包的依赖</span></span><br><span class="line">apt-rdepends &lt;包名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 建立目录并进入</span></span><br><span class="line"><span class="built_in">mkdir</span> dependsdep &amp;&amp; <span class="built_in">cd</span> dependsdep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 批量下载依赖包</span></span><br><span class="line">apt-rdepends &lt;包名&gt; | grep -E -v <span class="string">&#x27;^ &#x27;</span> | xargs -I&#123;&#125; apt download &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 安装目标包（假设包已经下载到上一级目录）</span></span><br><span class="line">sudo dpkg -i ../&lt;包名&gt;*.deb</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;🐧-Linux离线安装软件方法&quot;&gt;&lt;a href=&quot;#🐧-Linux离线安装软件方法&quot; class=&quot;headerlink&quot; title=&quot;🐧 Linux离线安装软件方法&quot;&gt;&lt;/a&gt;🐧 Linux离线安装软件方法&lt;/h1&gt;&lt;p&gt;在离线环境下安装软件时，不仅需要下载主包，还要把依赖包一并下载。这里提供两种情况的处理方法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://lyroom.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>构建工具链深度解析：GCC、G++、CMake、Make、QMake 和 CMakeLists.txt</title>
    <link href="https://lyroom.github.io/2025/09/05/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E9%93%BE%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9AGCC%E3%80%81G-%E3%80%81CMake%E3%80%81Make%E3%80%81QMake-%E5%92%8C-CMakeLists-txt/"/>
    <id>https://lyroom.github.io/2025/09/05/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E9%93%BE%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9AGCC%E3%80%81G-%E3%80%81CMake%E3%80%81Make%E3%80%81QMake-%E5%92%8C-CMakeLists-txt/</id>
    <published>2025-09-05T03:35:00.000Z</published>
    <updated>2025-09-05T03:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>  GCC、G++、CMake、Make、QMake 和 CMakeLists.txt这一系列的名词对于初学c++的学者来说是不是听起来很迷茫，但是又在很多的项目中遇到过？今天我们来简短的介绍一下这些专有名词，并且搞懂他们之间的关联。</p><span id="more"></span><h2 id="1-GCC-GNU-Compiler-Collection"><a href="#1-GCC-GNU-Compiler-Collection" class="headerlink" title="1. GCC (GNU Compiler Collection)"></a>1. GCC (GNU Compiler Collection)</h2><ul><li><p><strong>本质</strong>：<strong>编译器</strong></p></li><li><p><strong>作用</strong>：</p><ul><li>将源代码（.c&#x2F;.cpp）转换为机器可执行文件</li><li>处理编译过程的4个阶段：<ol><li>预处理（宏展开、头文件包含）</li><li>编译（源代码 → 汇编代码）</li><li>汇编（汇编代码 → 机器码）</li><li>链接（合并多个目标文件和库）</li></ol></li></ul></li><li><p><strong>特点</strong>：</p><ul><li>支持多种语言（C, C++, Objective-C, Fortran等）</li><li>跨平台（Linux&#x2F;Windows&#x2F;macOS）</li><li>提供丰富的编译选项（优化级别、警告控制等）</li></ul></li><li><p><strong>使用示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.c -o main.o          <span class="comment"># 编译C文件</span></span><br><span class="line">g++ -Wall -O2 app.cpp -o app     <span class="comment"># 编译C++文件并优化</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-G"><a href="#2-G" class="headerlink" title="2. G++"></a>2. G++</h2><ul><li><p><strong>本质</strong>：<strong>C++前端编译器</strong></p></li><li><p><strong>作用</strong>：</p><ul><li>GCC的C++特定版本</li><li>自动链接C++标准库（libstdc++）</li><li>处理C++特有的编译特性（模板、异常处理等）</li></ul></li><li><p><strong>与GCC的关系</strong>：</p><ul><li>G++是GCC的一部分，专注于C++编译</li><li>相当于<code>gcc -lstdc++</code>的快捷方式</li></ul></li><li><p><strong>使用示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++17 main.cpp utils.cpp -o app</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-Make"><a href="#3-Make" class="headerlink" title="3. Make"></a>3. Make</h2><ul><li><p><strong>本质</strong>：<strong>构建自动化工具</strong></p></li><li><p><strong>作用</strong>：</p><ul><li>根据Makefile规则管理构建过程</li><li>自动检测需要重新编译的文件（增量编译）</li><li>执行编译命令（调用gcc&#x2F;g++）</li></ul></li><li><p><strong>核心概念</strong>：</p><ul><li>目标（targets）</li><li>依赖（dependencies）</li><li>命令（commands）</li></ul></li><li><p><strong>Makefile示例</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app: main.o utils.o</span></span><br><span class="line">    g++ main.o utils.o -o app</span><br><span class="line">    </span><br><span class="line"><span class="section">main.o: main.cpp</span></span><br><span class="line">    g++ -c main.cpp</span><br><span class="line">    </span><br><span class="line"><span class="section">utils.o: utils.cpp utils.h</span></span><br><span class="line">    g++ -c utils.cpp</span><br><span class="line">    </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o app</span><br></pre></td></tr></table></figure></li><li><p><strong>特点</strong>：</p><ul><li>简单直接</li><li>需要手动管理依赖关系</li><li>跨平台性有限</li></ul></li></ul><h2 id="4-QMake"><a href="#4-QMake" class="headerlink" title="4. QMake"></a>4. QMake</h2><ul><li><p><strong>本质</strong>：<strong>Qt专用的构建系统生成器</strong></p></li><li><p><strong>作用</strong>：</p><ul><li>解析.pro文件</li><li>生成平台特定的构建文件（Makefile或IDE项目文件）</li><li>自动处理Qt特有的构建步骤（moc, uic, rcc）</li></ul></li><li><p><strong>.pro文件示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QT += widgets</span><br><span class="line">TARGET = myapp</span><br><span class="line">SOURCES += main.cpp widget.cpp</span><br><span class="line">HEADERS += widget.h</span><br><span class="line">RESOURCES += app.qrc</span><br></pre></td></tr></table></figure></li><li><p><strong>特点</strong>：</p><ul><li>Qt原生支持</li><li>简单易学</li><li>跨平台（生成不同平台的构建文件）</li><li>功能相对有限（相比CMake）</li></ul></li></ul><h2 id="5-CMake"><a href="#5-CMake" class="headerlink" title="5. CMake"></a>5. CMake</h2><ul><li><p><strong>本质</strong>：<strong>跨平台构建系统生成器</strong></p></li><li><p><strong>作用</strong>：</p><ul><li>解析CMakeLists.txt文件</li><li>生成平台特定的构建系统文件：<ul><li>Linux&#x2F;macOS → Makefile</li><li>Windows → Visual Studio解决方案(.sln)</li><li>Ninja → build.ninja</li></ul></li><li>自动检测系统环境和依赖库</li></ul></li><li><p><strong>核心优势</strong>：</p><ul><li>“Write once, build everywhere”</li><li>支持复杂项目结构</li><li>强大的依赖管理</li><li>模块化系统</li></ul></li><li><p><strong>使用流程</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake ..     <span class="comment"># 生成构建系统</span></span><br><span class="line">make         <span class="comment"># 执行构建</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="6-CMakeLists-txt"><a href="#6-CMakeLists-txt" class="headerlink" title="6. CMakeLists.txt"></a>6. CMakeLists.txt</h2><ul><li><p><strong>本质</strong>：<strong>CMake的配置文件</strong></p></li><li><p><strong>作用</strong>：</p><ul><li>描述项目结构和构建规则</li><li>定义编译目标（可执行文件、库）</li><li>指定依赖关系和链接选项</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyApp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(myapp main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Qt5 COMPONENTS Widgets REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(myapp PRIVATE Qt5::Widgets)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span>(myapp PROPERTIES</span><br><span class="line">    CXX_STANDARD <span class="number">17</span></span><br><span class="line">    CXX_STANDARD_REQUIRED <span class="keyword">ON</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="工具链对比分析"><a href="#工具链对比分析" class="headerlink" title="工具链对比分析"></a>工具链对比分析</h2><h3 id="层级关系"><a href="#层级关系" class="headerlink" title="层级关系"></a>层级关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[源代码] </span><br><span class="line">  ├── [GCC/G++] → 直接编译（简单项目）</span><br><span class="line">  ├── [Makefile] → [make] → 调用[GCC/G++]</span><br><span class="line">  ├── [.pro] → [qmake] → 生成[Makefile] → [make] → [GCC/G++]</span><br><span class="line">  └── [CMakeLists.txt] → [cmake] → 生成[Makefile/VS项目等] → [make/MSBuild] → [GCC/G++/MSVC]</span><br></pre></td></tr></table></figure><h3 id="功能对比表"><a href="#功能对比表" class="headerlink" title="功能对比表"></a>功能对比表</h3><table><thead><tr><th>工具&#x2F;文件</th><th>主要作用</th><th>输入</th><th>输出</th><th>跨平台性</th><th>复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td>GCC&#x2F;G++</td><td>编译源代码</td><td>源代码文件</td><td>目标文件&#x2F;可执行文件</td><td>高</td><td>低</td><td>简单程序、单文件编译</td></tr><tr><td>Make</td><td>执行构建规则</td><td>Makefile</td><td>构建产物</td><td>中</td><td>中</td><td>中小型项目</td></tr><tr><td>QMake</td><td>生成Qt项目构建系统</td><td>.pro文件</td><td>Makefile&#x2F;项目文件</td><td>高</td><td>中</td><td>Qt项目</td></tr><tr><td>CMake</td><td>生成跨平台构建系统</td><td>CMakeLists.txt</td><td>构建系统文件</td><td>极高</td><td>高</td><td>大型跨平台项目</td></tr><tr><td>CMakeLists.txt</td><td>描述项目构建规则</td><td>无</td><td>无</td><td>极高</td><td>高</td><td>所有CMake项目</td></tr></tbody></table><h3 id="工作流程对比"><a href="#工作流程对比" class="headerlink" title="工作流程对比"></a>工作流程对比</h3><p><strong>简单项目：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.cpp → g++ → a.out</span><br></pre></td></tr></table></figure><p><strong>Make项目：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.cpp + utils.cpp + Makefile → make → (g++) → app</span><br></pre></td></tr></table></figure><p><strong>QMake项目：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.cpp + widget.cpp + app.pro → qmake → Makefile → make → (g++) → app</span><br></pre></td></tr></table></figure><p><strong>CMake项目：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.cpp + utils.cpp + CMakeLists.txt → cmake → Makefile → make → (g++) → app</span><br></pre></td></tr></table></figure><h2 id="现代C-项目推荐工作流"><a href="#现代C-项目推荐工作流" class="headerlink" title="现代C++项目推荐工作流"></a>现代C++项目推荐工作流</h2><h3 id="对于Qt项目"><a href="#对于Qt项目" class="headerlink" title="对于Qt项目"></a>对于Qt项目</h3><!-- <img src="/2025/09/05/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E9%93%BE%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9AGCC%E3%80%81G-%E3%80%81CMake%E3%80%81Make%E3%80%81QMake-%E5%92%8C-CMakeLists-txt/process.png" class="" title="关系"> --><center><img src="/2025/09/05/构建工具链深度解析：GCC、G-、CMake、Make、QMake-和-CMakeLists-txt/大纲.png"  alt="大纲" style="zoom: 70%;" /></center><h3 id="关键配置示例"><a href="#关键配置示例" class="headerlink" title="关键配置示例"></a>关键配置示例</h3><p><strong>Qt项目的CMakeLists.txt：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(MyQtApp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找Qt库</span></span><br><span class="line"><span class="keyword">find_package</span>(Qt6 COMPONENTS Widgets Network REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(myapp</span><br><span class="line">    main.cpp</span><br><span class="line">    mainwindow.cpp</span><br><span class="line">    resources.qrc</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接Qt库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(myapp PRIVATE</span><br><span class="line">    Qt6::Widgets</span><br><span class="line">    Qt6::Network</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动处理Qt元对象系统</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(myapp PROPERTIES</span><br><span class="line">    AUTOMOC <span class="keyword">ON</span></span><br><span class="line">    AUTOUIC <span class="keyword">ON</span></span><br><span class="line">    AUTORCC <span class="keyword">ON</span></span><br><span class="line">    CXX_STANDARD <span class="number">17</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装规则</span></span><br><span class="line"><span class="keyword">install</span>(TARGETS myapp DESTINATION bin)</span><br></pre></td></tr></table></figure><h2 id="如何选择构建工具？"><a href="#如何选择构建工具？" class="headerlink" title="如何选择构建工具？"></a>如何选择构建工具？</h2><ol><li><p><strong>小型工具&#x2F;快速原型</strong>：</p><ul><li>直接使用G++编译</li><li>或简单Makefile</li></ul></li><li><p><strong>Qt专用项目</strong>：</p><ul><li>传统：QMake + .pro文件</li><li>现代：CMake（Qt官方推荐）</li></ul></li><li><p><strong>跨平台C++库&#x2F;应用</strong>：</p><ul><li>CMake（行业标准）</li></ul></li><li><p><strong>大型复杂系统</strong>：</p><ul><li>CMake + 现代构建系统（如Ninja）</li></ul></li></ol><h2 id="常见问题解答"><a href="#常见问题解答" class="headerlink" title="常见问题解答"></a>常见问题解答</h2><p><strong>Q：CMake能完全替代Make吗？</strong><br>A：不完全。CMake生成Makefile，然后Make执行构建。CMake是构建系统生成器，Make是构建执行器。</p><p><strong>Q：QMake会被淘汰吗？</strong><br>A：Qt官方已转向CMake作为首选构建系统，但QMake仍被广泛使用，特别是维护旧项目时。</p><p><strong>Q：为什么需要构建系统？</strong><br>A：当项目具有以下特点时：</p><ul><li>多个源文件</li><li>复杂的依赖关系</li><li>需要跨平台构建</li><li>包含资源文件和代码生成</li><li>需要安装规则和打包</li></ul><p><strong>Q：GCC和Clang的区别？</strong><br>A：两者都是编译器，GCC是GNU项目，Clang是LLVM项目。Clang有更友好的错误信息，更快的编译速度，更好的C++标准支持。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>编译器层</strong>：GCC&#x2F;G++ 负责将源代码转换为机器码</li><li><strong>构建执行层</strong>：Make 负责执行构建规则</li><li><strong>构建系统生成层</strong>：<ul><li>QMake：专为Qt优化的构建系统生成器</li><li>CMake：通用跨平台构建系统生成器</li></ul></li><li><strong>配置文件</strong>：<ul><li>.pro：QMake的配置文件</li><li>CMakeLists.txt：CMake的配置文件</li></ul></li></ul><p>现代C++开发中，<strong>CMake + GCC&#x2F;Clang + Ninja</strong> 已成为主流组合，提供最高效、最灵活的构建解决方案。对于Qt项目，虽然QMake仍可用，但CMake已成为官方推荐的选择，特别是新项目。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;  GCC、G++、CMake、Make、QMake 和 CMakeLists.txt这一系列的名词对于初学c++的学者来说是不是听起来很迷茫，但是又在很多的项目中遇到过？今天我们来简短的介绍一下这些专有名词，并且搞懂他们之间的关联。&lt;/p&gt;</summary>
    
    
    
    
    <category term="c/c++" scheme="https://lyroom.github.io/tags/c-c/"/>
    
    <category term="GCC/G++" scheme="https://lyroom.github.io/tags/GCC-G/"/>
    
    <category term="Make" scheme="https://lyroom.github.io/tags/Make/"/>
    
    <category term="QMake" scheme="https://lyroom.github.io/tags/QMake/"/>
    
    <category term="CMake" scheme="https://lyroom.github.io/tags/CMake/"/>
    
    <category term="CMakeLists" scheme="https://lyroom.github.io/tags/CMakeLists/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu虚拟机安装vmtools遇到的问题</title>
    <link href="https://lyroom.github.io/2025/09/04/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85vmtools%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://lyroom.github.io/2025/09/04/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85vmtools%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2025-09-03T20:02:02.000Z</published>
    <updated>2025-09-03T20:02:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoremove open-vm-tools</span><br><span class="line">sudo apt-get install open-vm-tools</span><br><span class="line">sudo apt-get install open-vm-tools-desktop</span><br></pre></td></tr></table></figure><p>done!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    
    <category term="VMware" scheme="https://lyroom.github.io/tags/VMware/"/>
    
    <category term="Ubuntu" scheme="https://lyroom.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>c++继承中的父子纠葛</title>
    <link href="https://lyroom.github.io/2024/10/23/c-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E7%88%B6%E5%AD%90%E7%BA%A0%E8%91%9B/"/>
    <id>https://lyroom.github.io/2024/10/23/c-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E7%88%B6%E5%AD%90%E7%BA%A0%E8%91%9B/</id>
    <published>2024-10-23T14:42:31.000Z</published>
    <updated>2024-10-23T14:42:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>想必各位对于面向对象都已了然于胸了吧，今天我偶然间遇到了一个面试题，是关于继承方面的，蛮有不错的，邀请各位来探讨一下。</p><span id="more"></span><p>先看下面一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> n = <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> b=<span class="number">3</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> n = <span class="number">10</span>)</span><span class="keyword">override</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Derive :&quot;</span>&lt;&lt;b + n &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Base *arr = <span class="keyword">new</span> Derive[<span class="number">10</span>];</span><br><span class="line">     arr[<span class="number">7</span>].<span class="built_in">print</span>();</span><br><span class="line">     <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">     Base *ptr = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">     ptr-&gt;<span class="built_in">print</span>();</span><br><span class="line">     <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以尝试分析一下，这段代码的结果吗？我们可以回顾一下<a href="https://lyroom.github.io/2024/10/16/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/#4-6-%E7%BB%A7%E6%89%BF:~:text=0%3B%0A%7D-,4.6%20%E7%BB%A7%E6%89%BF,-%E7%BB%A7%E6%89%BF%E6%98%AF%E9%9D%A2%E5%90%91">继承</a>的概念<br>运行这段代码之后我们发现，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mingw64：</span><br><span class="line">    Derive :5</span><br><span class="line">    Derive :5</span><br><span class="line">mingw32：</span><br><span class="line">    exited with code -1073741819</span><br></pre></td></tr></table></figure><p>为什么会出现这种情况呢？我们一步步来分析。</p><h3 id="代码关键点解释"><a href="#代码关键点解释" class="headerlink" title="代码关键点解释"></a>代码关键点解释</h3><ol><li><p><strong>类结构</strong>：</p><ul><li><code>Base</code>类：包含成员变量<code>a = 1</code>，以及虚函数<code>print(int n = 2)</code>，默认参数为2。函数输出<code>&quot;Base:&quot; &lt;&lt; a + n</code>。</li><li><code>Derive</code>类：继承自<code>Base</code>，添加成员变量<code>b = 3</code>，并覆盖虚函数<code>print(int n = 10)</code>，默认参数改为10。函数输出<code>&quot;Derive:&quot; &lt;&lt; b + n</code>。</li><li>虚函数（<code>virtual</code>）支持运行时多态：通过基类指针调用时，实际执行派生类的覆盖函数（动态绑定）。</li></ul></li><li><p><strong>结构体（类）在内存中的存放规则</strong></p><p>​为了更方便的访问结构体对象中的成员变量，通常需要在内存中<code>对齐存储</code>，所以通常需要空一段内存，这便是<code>填充</code>。所以一个结构体对象在内存中的<code>存储原则</code>是：</p><blockquote><p>结构体的起始地址 &#x3D; 最大成员对齐值的整数倍</p><p>每个成员的起始地址能够被该成员大小整除</p><p>结构体的大小 &#x3D; 最大成员的整数倍</p></blockquote><p><strong><code>在64位系统中，每个内存单元的大小通常为64b即8B，所以一般按照8B对齐，指针大小通常也为8B</code></strong></p><p><strong><code>在32位系统中，每个内存单元的大小通常时32b即4B，所以一般按照4B对齐，指针大小通常也为4B</code></strong></p><p>​按照上面的原则，可以知道上述父子类对象在不同系统中，内存的存储方式：</p><center><img src="/2024/10/23/c-继承中的父子纠葛/内存.png"  style="zoom:67%;" /></center></li><li><p><strong>默认参数的绑定规则</strong>：</p><ul><li>默认参数是<strong>静态绑定</strong>（在编译时基于指针或引用类型确定），而非动态绑定。</li><li>当通过基类指针调用虚函数时：<ul><li>函数实现（函数体）使用派生类的版本（动态绑定）。</li><li>默认参数值使用基类定义的默认值（静态绑定），忽略派生类的默认值，所以运算时<code>n的值始终为2</code>。</li></ul></li></ul></li><li><p><strong>数组分配问题</strong>：</p><ul><li><code>Base* arr = new Derive[10]</code>：这里分配了一个包含10个<code>Derive</code>对象的数组，但用<code>Base*</code>指针指向它。</li></ul> <center>  <img src="/2024/10/23/c-继承中的父子纠葛/5.png"  style="zoom:100%;" /> </center><p>我们希望情况如下：</p> <center>  <img src="/2024/10/23/c-继承中的父子纠葛/4.png"  style="zoom:100%;" /> </center><p>但实际上呢？？？</p></li></ol><h3 id="输出结果分析"><a href="#输出结果分析" class="headerlink" title="输出结果分析"></a>输出结果分析</h3><h4 id="1-第一次调用：arr-7-print"><a href="#1-第一次调用：arr-7-print" class="headerlink" title="1. 第一次调用：arr[7].print()"></a>1. 第一次调用：<code>arr[7].print()</code></h4><ul><li><p><strong>输出结果</strong>：</p><p><strong>mingw64</strong>构建运行时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derive :5</span><br></pre></td></tr></table></figure><p><strong>mingw32</strong>构建运行时:  </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exited with code -1073741819</span><br></pre></td></tr></table></figure><ul><li><p><strong>两个编译器为啥输出结果不同？</strong>：</p><p>​<strong>关键在于arr[7] 有没有指向[Derive7]</strong></p><ul><li><p>mingw64构建时：</p><center><img src="/2024/10/23/c-继承中的父子纠葛/1.png"  style="zoom:100%;" /></center><p>虽然Base和Derive大小不同，但是由于<code>内存对齐</code>使得Base的大小和Derive大小相同，阴差阳错的使得arr[7]指向了Derive[7]的位置，使得可以调用Derive的print函数，输出为5；</p></li><li><p>mingw32构建时：</p></li></ul><center> <img src="/2024/10/23/c-继承中的父子纠葛/2.png"  style="zoom:100%;" /></center><p>   指针算术错误：<code>arr</code>指向<code>Derive[10]</code>数组，但<code>arr[7]</code>基于<code>sizeof(Base)</code>计算地址（例如，在32位系统中，<code>arr + 7 * 8 = arr + 56</code>）。实际第7个<code>Derive</code>对象位于<code>arr + 7 * 12 = arr + 84</code>（假设<code>sizeof(Derive)=12</code>）。因此，<code>arr[7]</code>指向无效内存。所以输出错误值。</p></li><li><p><strong>为什么不是多态输出？</strong> 即使忽略指针错误，理论上：</p><ul><li>函数调用应使用<code>Derive::print</code>实现（虚函数动态绑定）。</li><li>但默认参数静态绑定为<code>Base::print</code>的<code>n=2</code>（因为<code>arr</code>类型是<code>Base*</code>）。</li><li>输出应为<code>&quot;Derive:&quot; &lt;&lt; b + 2</code>（即<code>Derive:5</code>），但由于对象地址错误，<code>b</code>的值可能无效或取自错误内存。</li></ul></li></ul></li></ul><h4 id="2-第二次调用：ptr-gt-print"><a href="#2-第二次调用：ptr-gt-print" class="headerlink" title="2. 第二次调用：ptr-&gt;print()"></a>2. 第二次调用：<code>ptr-&gt;print()</code></h4><ul><li><strong>输出结果</strong>：<code>Derive:5</code>  <ul><li>原因：<ul><li><code>ptr</code>指向一个有效的<code>Derive</code>对象（<code>new Derive()</code>），多态正确：<code>ptr</code>类型是<code>Base*</code>，但对象是<code>Derive</code>，因此虚函数调用<code>Derive::print</code>实现（动态绑定）。</li><li>默认参数静态绑定：调用<code>ptr-&gt;print()</code>未提供参数，编译器基于<code>ptr</code>的静态类型（<code>Base*</code>）使用<code>Base::print</code>的默认值<code>n=2</code>（忽略<code>Derive::print</code>的<code>n=10</code>）。</li><li>因此，实际调用<code>Derive::print(2)</code>：<ul><li><code>b + n = 3 + 2 = 5</code>。</li><li>输出：<code>&quot;Derive:5&quot;</code>。</li></ul></li></ul></li><li>关键原理：默认参数在编译时确定，基于指针类型（<code>Base*</code>），而函数体在运行时确定，基于对象类型（<code>Derive</code>）。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;想必各位对于面向对象都已了然于胸了吧，今天我偶然间遇到了一个面试题，是关于继承方面的，蛮有不错的，邀请各位来探讨一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="c++" scheme="https://lyroom.github.io/tags/c/"/>
    
    <category term="继承" scheme="https://lyroom.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
    <category term="多态" scheme="https://lyroom.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
    <category term="虚函数" scheme="https://lyroom.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
    <category term="虚函数表" scheme="https://lyroom.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/"/>
    
    <category term="虚函数指针" scheme="https://lyroom.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++核心编程</title>
    <link href="https://lyroom.github.io/2024/10/16/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    <id>https://lyroom.github.io/2024/10/16/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</id>
    <published>2024-10-16T03:56:40.000Z</published>
    <updated>2024-10-16T03:56:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>本阶段主要针对<code>C++</code> , <code>面向对象</code> , <code>编程技术</code>做详细讲解，探讨C++中的核心和精髓。</p><span id="more"></span><h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li></ul><p><strong>内存四区意义：</strong></p><p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p><h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>​在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p><p>​<strong>代码区：</strong></p><p>​存放 CPU 执行的机器指令</p><p>​代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>​代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p><p>​<strong>全局区：</strong></p><p>​全局变量和静态变量存放在此.</p><p>​全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p><p>​&#x3D;&#x3D;该区域的数据在程序结束后由操作系统释放&#x3D;&#x3D;.</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><img src="/2024/10/16/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545017602518.png" class="" width="1545017602518"><p>总结：</p><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区特点是共享和只读</li><li>全局区中存放全局变量、静态变量、常量</li><li>常量区中存放 const修饰的全局常量  和 字符串常量</li></ul><h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p>​<strong>栈区：</strong></p><p>​由编译器自动分配释放, 存放函数的参数值,局部变量等</p><p>​注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>堆区：</strong></p><p>​由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p><p>​在C++中主要利用new在堆区开辟内存</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>堆区数据由程序员管理开辟和释放</p><p>堆区数据利用new关键字进行开辟内存</p><h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>​C++中利用&#x3D;&#x3D;new&#x3D;&#x3D;操作符在堆区开辟数据</p><p>​堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 &#x3D;&#x3D;delete&#x3D;&#x3D;</p><p>​语法：<code> new 数据类型</code></p><p>​利用new创建的数据，会返回该数据对应的类型的指针</p><p><strong>示例1： 基本语法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用delete释放堆区数据</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：开辟数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p>**作用： **给变量起别名</p><p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line"><span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p><p><strong>优点：</strong>可以简化指针修改实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p></blockquote><h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p><p>注意：<strong>不要返回局部变量引用</strong></p><p>用法：函数调用作为左值</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能返回局部变量的引用</span></span><br><span class="line"><span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line"><span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p><p>讲解示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line"><span class="type">int</span>&amp; ref = a; </span><br><span class="line">ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">func</span>(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加&#x3D;&#x3D;const修饰形参&#x3D;&#x3D;，防止形参改变实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//v += 10;</span></span><br><span class="line">cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line"><span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li></ul><p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul><li>引用作为重载条件</li><li>函数重载碰到函数默认参数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：&#x3D;&#x3D;封装、继承、多态&#x3D;&#x3D;</p><p>C++认为&#x3D;&#x3D;万事万物都皆为对象&#x3D;&#x3D;，对象上有其属性和行为</p><p><strong>例如：</strong></p><p>​人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p><p>​车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p><p>​具有相同性质的&#x3D;&#x3D;对象&#x3D;&#x3D;，我们可以抽象称为&#x3D;&#x3D;类&#x3D;&#x3D;，人属于人类，车属于车类</p><h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>封装意义一：</strong></p><p>​在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p><p><strong>示例1：</strong>设计一个圆类，求圆的周长</p><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//行为</span></span><br><span class="line"><span class="comment">//获取到圆的周长</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//2 * pi  * r</span></span><br><span class="line"><span class="comment">//获取圆的周长</span></span><br><span class="line"><span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line"><span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">Circle c1;</span><br><span class="line">c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><p><strong>示例2代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">m_id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;</span><br><span class="line"><span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Student stu;</span><br><span class="line">stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">stu.<span class="built_in">setID</span>(<span class="number">250</span>);</span><br><span class="line">stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li>public        公共权限  </li><li>protected 保护权限</li><li>private      私有权限</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string m_Car;</span><br><span class="line"></span><br><span class="line"><span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">m_Password = <span class="number">123456</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line"><span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line"><span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li>struct 默认权限为公共</li><li>class   默认权限为私有</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">C1 c1;</span><br><span class="line">c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">C2 c2;</span><br><span class="line">c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p><p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//姓名设置可读可写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取年龄 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置年龄</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情人设置为只写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">m_Lover = lover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line"><span class="comment">//姓名设置</span></span><br><span class="line">p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄设置</span></span><br><span class="line">p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情人设置</span></span><br><span class="line">p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习案例1：设计立方体类</strong></p><p>设计立方体类(Cube)</p><p>求出立方体的面积和体积</p><p>分别用全局函数和成员函数判断两个立方体是否相等。</p><img src="/2024/10/16/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545533548532.png" class="" width="1545533548532"><p><strong>练习案例2：点和圆的关系</strong></p><p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p><img src="/2024/10/16/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545533829184.png" class="" width="1545533829184"><h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul><li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li><li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li></ul><h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><p>​一个对象或者变量没有初始状态，对其使用后果是未知</p><p>​同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号  ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p><p>​按参数分为： 有参构造和无参构造</p><p>​按类型分为： 普通构造和拷贝构造</p><p>三种调用方式：</p><p>​括号法</p><p>​显示法</p><p>​隐式转换法</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.1  括号法，常用</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line"><span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2 显式法</span></span><br><span class="line">Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line"><span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.3 隐式转换法</span></span><br><span class="line">Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line"><span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = p.mAge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line"><span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person newman3;</span></span><br><span class="line"><span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li><p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</p></li><li><p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age ,<span class="type">int</span> height) &#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">m_age = age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数  </span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">m_age = p.m_age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line"><span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote><h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">////传统方式初始化</span></span><br><span class="line"><span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line"><span class="comment">//m_A = a;</span></span><br><span class="line"><span class="comment">//m_B = b;</span></span><br><span class="line"><span class="comment">//m_C = c;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表方式初始化</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Phone</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">m_PhoneName = name;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Phone</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line">Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line"><span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line"><span class="comment">//析构顺序与构造相反</span></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><p><strong>示例1 ：</strong>静态成员变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量特点：</span></span><br><span class="line"><span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line"><span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line"><span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.m_A = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_A = <span class="number">200</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong>静态成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数特点：</span></span><br><span class="line"><span class="comment">//1 程序共享一个函数</span></span><br><span class="line"><span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">mA = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line"><span class="type">int</span> mA;</span><br><span class="line"><span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line"><span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用return *this</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"><span class="comment">//返回对象本身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person * p = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ul><p><strong>常对象：</strong></p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">m_A = <span class="number">0</span>;</span><br><span class="line">m_B = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line"><span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//const Type* const pointer;</span></span><br><span class="line"><span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line"><span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//mA = 10000;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常对象访问成员函数</span></span><br><span class="line">person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p><p>友元的关键字为  &#x3D;&#x3D;friend&#x3D;&#x3D;</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Building b;</span><br><span class="line"><span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay  gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = p2.m_A + val;</span><br><span class="line">temp.m_B = p2.m_B + val;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数方式</span></span><br><span class="line">Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p></blockquote><blockquote><p>总结2：不要滥用运算符重载</p></blockquote><h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line"><span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p></blockquote><h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">m_Num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置++</span></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line"><span class="comment">//先++</span></span><br><span class="line">m_Num++;</span><br><span class="line"><span class="comment">//再返回</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++</span></span><br><span class="line">MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">//先返回</span></span><br><span class="line">MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">m_Num++;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">out &lt;&lt; myint.m_Num;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyInteger myInt;</span><br><span class="line">cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">MyInteger myInt;</span><br><span class="line">cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 前置递增返回引用，后置递增返回值</p></blockquote><h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator&#x3D;, 对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载赋值运算符 </span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line"><span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回自身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄的指针</span></span><br><span class="line"><span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 10;</span></span><br><span class="line"><span class="comment">//int b = 20;</span></span><br><span class="line"><span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c = b = a;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int a = 0;</span></span><br><span class="line"><span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a != b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">MyPrint myFunc;</span><br><span class="line"><span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAdd add;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象调用  </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系，例如下图中：</p><img src="/2024/10/16/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1544861202252.png" class="" width="1544861202252"><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：&#x3D;&#x3D;可以减少重复的代码&#x3D;&#x3D;</p><p>class A : public B; </p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><img src="/2024/10/16/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/clip_image002.png" class="" title="img"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son1 s1;</span><br><span class="line">s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2 s;</span><br><span class="line"><span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line"><span class="comment">//m_A;</span></span><br><span class="line"><span class="comment">//m_B;</span></span><br><span class="line"><span class="comment">//m_C;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用工具查看：</p><img src="/2024/10/16/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545881904150.png" class="" width="1545881904150"><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： cl &#x2F;d1 reportSingleClassLayout查看的类名   所属文件名</p><p>效果如下图：</p><img src="/2024/10/16/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545882158050.png" class="" width="1545882158050"><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></blockquote><h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line"><span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_C = <span class="number">300</span>;</span><br><span class="line">m_D = <span class="number">400</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>​两个派生类继承同一个基类</p><p>​又有某个类同时继承者两个派生类</p><p>​这种继承被称为菱形继承，或者钻石继承</p><p><strong>典型的菱形继承案例：</strong></p><img src="/2024/10/16/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/clip_image002.jpg" class="" title="IMG_256"><p><strong>菱形继承问题：</strong></p><ol><li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li><li><pre><code>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</code></pre></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SheepTuo st;</span><br><span class="line">st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>菱形继承：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">public</span>: <span class="type">int</span> data; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.data = <span class="number">10</span>;  <span class="comment">// 错误！二义性：不知道访问 B::data 还是 C::data</span></span><br><span class="line">    d.B::data = <span class="number">10</span>; <span class="comment">// 需显式指定路径（仍有重复内存）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：虚继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用虚继承后</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">public</span>: <span class="type">int</span> data; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键：使用 virtual 继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;; <span class="comment">// 虚继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;; <span class="comment">// 虚继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.data = <span class="number">10</span>;  <span class="comment">// ✅ 正确！不再有二义性</span></span><br><span class="line">    d.B::data = <span class="number">20</span>; <span class="comment">// ✅ 修改的是同一份数据</span></span><br><span class="line">    d.C::data = <span class="number">30</span>; <span class="comment">// ✅ 值变为30（共享同一份）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存对比：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">普通继承：</span><br><span class="line">D &#123; </span><br><span class="line">  B &#123; A &#123; data &#125; &#125; </span><br><span class="line">  C &#123; A &#123; data &#125; &#125;   // 每个派生类对象都保留了父类的成员，产生了重复副本！</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">虚继承：</span><br><span class="line">D &#123; </span><br><span class="line">  B &#123; ... &#125; </span><br><span class="line">  C &#123; ... &#125; </span><br><span class="line">  共享的 A &#123; data &#125;   // 唯一副本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li></ul><p>下面通过案例进行讲解多态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Speak函数就是虚函数</span></span><br><span class="line"><span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line"><span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dog dog;</span><br><span class="line"><span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p><h4 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h4><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_Num1;</span><br><span class="line"><span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//普通实现测试</span></span><br><span class="line">Calculator c;</span><br><span class="line">c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Num1;</span><br><span class="line"><span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建加法计算器</span></span><br><span class="line">AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建减法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建乘法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p></blockquote><h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为&#x3D;&#x3D;抽象类&#x3D;&#x3D;</p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line"><span class="comment">//抽象类无法实例化对象</span></span><br><span class="line"><span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base * base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">base = <span class="keyword">new</span> Son;</span><br><span class="line">base-&gt;<span class="built_in">func</span>();</span><br><span class="line"><span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二-制作饮品"></a>4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p><p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><img src="/2024/10/16/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545985945198.png" class="" width="1545985945198"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//规定流程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">Boil</span>();</span><br><span class="line"><span class="built_in">Brew</span>();</span><br><span class="line"><span class="built_in">PourInCup</span>();</span><br><span class="line"><span class="built_in">PutSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line"><span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><p><code>virtual ~类名()&#123;&#125;</code></p><p>纯虚析构语法：</p><p><code> virtual ~类名() = 0;</code></p><p><code>类名::~类名()&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line"><span class="comment">//virtual ~Animal()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cat</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Cat</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_Name;</span><br><span class="line">m_Name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line"><span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line"><span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p><p>​2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><p>​3. 拥有纯虚析构函数的类也属于抽象类</p><h4 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="4.7.6 多态案例三-电脑组装"></a>4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p><p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的计算函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的存储函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">&#123;</span><br><span class="line">m_cpu = cpu;</span><br><span class="line">m_vc = vc;</span><br><span class="line">m_mem = mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供工作的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">~<span class="built_in">Computer</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放CPU零件</span></span><br><span class="line"><span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_cpu;</span><br><span class="line">m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放显卡零件</span></span><br><span class="line"><span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_vc;</span><br><span class="line">m_vc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存条零件</span></span><br><span class="line"><span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_mem;</span><br><span class="line">m_mem = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//第一台电脑零件</span></span><br><span class="line">CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//创建第一台电脑</span></span><br><span class="line">Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第二台电脑组装</span></span><br><span class="line">Computer * computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第三台电脑组装</span></span><br><span class="line">Computer * computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 &#x3D;&#x3D;&lt; fstream &gt;&#x3D;&#x3D;</p><p>文件类型分为两种：</p><ol><li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>   写文件步骤如下：</p><ol><li><p>包含头文件   </p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open(“文件路径”,打开方式);</p></li><li><p>写数据</p><p>ofs &lt;&lt; “写入的数据”;</p></li><li><p>关闭文件</p><p>ofs.close();</p></li></ol><p>文件打开方式：</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件操作必须包含头文件 fstream</li><li>读文件可以利用 ofstream  ，或者fstream类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用&lt;&lt;可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li><p>包含头文件   </p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”,打开方式);</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="comment">//string buf;</span></span><br><span class="line"><span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>读文件可以利用 ifstream  ，或者fstream类</li><li>利用is_open函数可以判断文件是否打开成功</li><li>close 关闭文件</li></ul><h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 &#x3D;&#x3D;ios::binary&#x3D;&#x3D;</p><h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、创建输出流对象</span></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、打开文件</span></span><br><span class="line"><span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">Person p = &#123;<span class="string">&quot;张三&quot;</span>  , <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、写文件</span></span><br><span class="line">ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、关闭文件</span></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li></ul><h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文件输入流对象 可以通过read函数，以二进制方式读数据</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本阶段主要针对&lt;code&gt;C++&lt;/code&gt; , &lt;code&gt;面向对象&lt;/code&gt; , &lt;code&gt;编程技术&lt;/code&gt;做详细讲解，探讨C++中的核心和精髓。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://lyroom.github.io/tags/C/"/>
    
    <category term="面向对象" scheme="https://lyroom.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="编程技术" scheme="https://lyroom.github.io/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>shell小工具推荐——tldr</title>
    <link href="https://lyroom.github.io/2024/10/14/shell%E5%B0%8F%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94tldr/"/>
    <id>https://lyroom.github.io/2024/10/14/shell%E5%B0%8F%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94tldr/</id>
    <published>2024-10-14T06:27:55.000Z</published>
    <updated>2024-10-14T06:27:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tldr使用效果"><a href="#tldr使用效果" class="headerlink" title="tldr使用效果"></a>tldr使用效果</h2><p>今天偶然发现了一个宝藏shell工具，推荐linux，macos用户使用：tldr</p><span id="more"></span><p>在使用man手册查询命令的功能时候，往往会出现一大堆参数，如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">$ man <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LS(1)                            User Commands                           LS(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       <span class="built_in">ls</span> - list directory contents</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="built_in">ls</span> [OPTION]... [FILE]...</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       List  information  about  the FILEs (the current directory by default).</span><br><span class="line">       Sort entries alphabetically <span class="keyword">if</span> none of -cftuvSUX nor --<span class="built_in">sort</span>  is  speci‐</span><br><span class="line">       fied.</span><br><span class="line"></span><br><span class="line">       Mandatory  arguments  to  long  options are mandatory <span class="keyword">for</span> short options</span><br><span class="line">       too.</span><br><span class="line"></span><br><span class="line">       -a, --all</span><br><span class="line">              <span class="keyword">do</span> not ignore entries starting with .</span><br><span class="line"></span><br><span class="line">       -A, --almost-all</span><br><span class="line">              <span class="keyword">do</span> not list implied . and ..</span><br><span class="line"></span><br><span class="line">       --author</span><br><span class="line">              with -l, <span class="built_in">print</span> the author of each file</span><br><span class="line"></span><br><span class="line">       -b, --escape</span><br><span class="line">              <span class="built_in">print</span> C-style escapes <span class="keyword">for</span> nongraphic characters</span><br><span class="line"></span><br><span class="line">       --block-size=SIZE</span><br><span class="line">              with  -l,  scale  sizes  by  SIZE  when  printing  them;   e.g.,</span><br><span class="line">              <span class="string">&#x27;--block-size=M&#x27;</span>; see SIZE format below</span><br><span class="line"></span><br><span class="line">       -B, --ignore-backups</span><br><span class="line">              <span class="keyword">do</span> not list implied entries ending with ~</span><br><span class="line"></span><br><span class="line">       -c     with -lt: <span class="built_in">sort</span> by, and show, ctime (time of last modification of</span><br><span class="line">              file status information); with -l: show ctime and <span class="built_in">sort</span> by  name;</span><br><span class="line">              otherwise: <span class="built_in">sort</span> by ctime, newest first</span><br><span class="line"></span><br><span class="line">       -C     list entries by columns</span><br><span class="line"></span><br><span class="line">       --color[=WHEN]</span><br><span class="line">              colorize  the output; WHEN can be <span class="string">&#x27;always&#x27;</span> (default <span class="keyword">if</span> omitted),</span><br><span class="line">              <span class="string">&#x27;auto&#x27;</span>, or <span class="string">&#x27;never&#x27;</span>; more info below</span><br><span class="line"></span><br><span class="line">       -d, --directory</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们有时候需要快速的使用这个命令，而不希望需要查阅这么多的资料，这时候tldr工具就来了，使用效果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ tldr <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">  列出目录中的内容。</span><br><span class="line">  更多信息：https://www.gnu.org/software/coreutils/ls.</span><br><span class="line"></span><br><span class="line">  - 列出目录中的文件，每个文件占一行：</span><br><span class="line">    <span class="built_in">ls</span> -1</span><br><span class="line"></span><br><span class="line">  - 列出包含隐藏文件的所有文件：</span><br><span class="line">    <span class="built_in">ls</span> -a</span><br><span class="line"></span><br><span class="line">  - 列出所有文件，如果是目录，则在目录名后面加上「/」：</span><br><span class="line">    <span class="built_in">ls</span> -F</span><br><span class="line"></span><br><span class="line">  - 列出包含隐藏文件的所有文件信息，包括权限，所有者，大小和修改日期：</span><br><span class="line">    <span class="built_in">ls</span> -la</span><br><span class="line"></span><br><span class="line">  - 列出所有文件信息，大小用人类可读的单位表示（KiB, MiB, GiB）：</span><br><span class="line">    <span class="built_in">ls</span> -lh</span><br><span class="line"></span><br><span class="line">  - 列出所有文件信息，按大小降序排序：</span><br><span class="line">    <span class="built_in">ls</span> -lSR</span><br><span class="line"></span><br><span class="line">  - 列出所有文件信息，按修改日期从旧到新排序：</span><br><span class="line">    <span class="built_in">ls</span> -ltr</span><br><span class="line"></span><br><span class="line">  - 只列出目录：</span><br><span class="line">    <span class="built_in">ls</span> -d */</span><br></pre></td></tr></table></figure><p>tldr+命令可以快速且简短的给出使用说明，很节省时间。</p><h2 id="tldr安装"><a href="#tldr安装" class="headerlink" title="tldr安装"></a>tldr安装</h2><p><del>tldr：全称是：too long，don&#96;t read,就是为了简短的显示命令的使用方式，以下是ubuntu下的安装方法。</del></p><p><del><code>sudo apt install tldr</code></del></p><p>以上方法被舍弃的原因是更新太麻烦了，<code>tldr --update</code>经常卡住，所以我们选择一种新的方法安装。</p><h3 id="tealdeer代替node-js安装"><a href="#tealdeer代替node-js安装" class="headerlink" title="tealdeer代替node.js安装"></a>tealdeer代替node.js安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载npm安装的tldr</span></span><br><span class="line">npm uninstall -g tldr</span><br><span class="line"><span class="comment"># 安装tealdeer</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install tealdeer</span><br></pre></td></tr></table></figure><h3 id="手动配置配置文件"><a href="#手动配置配置文件" class="headerlink" title="手动配置配置文件"></a>手动配置配置文件</h3><p>需要我们手动创建配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新的目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.config/tealdeer</span><br><span class="line"><span class="comment"># 创建配置文件</span></span><br><span class="line"><span class="built_in">touch</span> ~/.config/tealdeer/config.toml</span><br></pre></td></tr></table></figure><p>配置文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tealdeer 配置文件 (~/.config/tealdeer/config.toml)</span></span><br><span class="line"></span><br><span class="line">[display]</span><br><span class="line"><span class="comment"># 设置显示语言为中文</span></span><br><span class="line">language = <span class="string">&quot;zh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用彩色输出（auto = 根据终端自动判断，always = 总是彩色，never = 禁用彩色）</span></span><br><span class="line">use_color = <span class="string">&quot;auto&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否显示命令示例前的标题（比如 &quot;Examples&quot;）</span></span><br><span class="line">show_headers = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否显示超链接（有的命令会带参考链接）</span></span><br><span class="line">hyperlinks = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[updates]</span><br><span class="line"><span class="comment"># 自动更新启用</span></span><br><span class="line">auto_update = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动更新的时间间隔（单位：小时）</span></span><br><span class="line"><span class="comment"># 这里设置为 168 小时 = 7 天</span></span><br><span class="line">auto_update_interval_hours = 168</span><br></pre></td></tr></table></figure><h2 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h2><p><del>前提是你安装了nodejs和npm,安装tldr客户端</del><br><del><code>sudo npm install -g tldr</code></del><br><del>设置语言环境为中文，修改系统变量</del></p><p>首先查看终端语言环境和系统默认语言环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locale</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LANG</span></span><br></pre></td></tr></table></figure><p>如果显示如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">locale</span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line">LANGUAGE=en_US.UTF-8</span><br><span class="line">LC_CTYPE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_NUMERIC=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_TIME=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_COLLATE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MONETARY=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MESSAGES=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_PAPER=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_NAME=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_ADDRESS=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_TELEPHONE=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_MEASUREMENT=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_IDENTIFICATION=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">LC_ALL=en_US.UTF-8</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LANG</span></span><br><span class="line">en_US.UTF-8</span><br></pre></td></tr></table></figure><p>则表明终端语言环境（LANG）和系统语言环境（LC_ALL）均为英文，我们需要修改终端语言环境如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>在文件末尾添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TLDR_LANG=zh</span><br><span class="line"><span class="built_in">export</span> TLDR_LANGUAGE=zh_Hans</span><br><span class="line"><span class="built_in">export</span> LANG=zh_CN.UTF-8</span><br><span class="line"><span class="built_in">export</span> TEALDEER_LANGUAGE=zh</span><br><span class="line"><span class="built_in">export</span> LANGUAGE=zh_CN:zh</span><br><span class="line"><span class="built_in">unset</span> LC_All <span class="comment">#仅仅修改终端让其不生效</span></span><br></pre></td></tr></table></figure><p>最后更新一下是更改生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="更新tldr缓存"><a href="#更新tldr缓存" class="headerlink" title="更新tldr缓存"></a>更新tldr缓存</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tldr --update</span><br><span class="line">tldr <span class="built_in">ls</span> <span class="comment"># 查看一下成果吧</span></span><br></pre></td></tr></table></figure><p>接下来就可以愉快使用啦！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;tldr使用效果&quot;&gt;&lt;a href=&quot;#tldr使用效果&quot; class=&quot;headerlink&quot; title=&quot;tldr使用效果&quot;&gt;&lt;/a&gt;tldr使用效果&lt;/h2&gt;&lt;p&gt;今天偶然发现了一个宝藏shell工具，推荐linux，macos用户使用：tldr&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://lyroom.github.io/tags/linux/"/>
    
    <category term="shell" scheme="https://lyroom.github.io/tags/shell/"/>
    
    <category term="shell工具推荐" scheme="https://lyroom.github.io/tags/shell%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>github学习</title>
    <link href="https://lyroom.github.io/2024/10/11/github%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lyroom.github.io/2024/10/11/github%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-11T09:05:12.000Z</published>
    <updated>2024-10-11T09:05:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文会较为详细的学习github的一些操作，以下是具体的步骤。</p><h1 id="安装与配置git"><a href="#安装与配置git" class="headerlink" title="安装与配置git"></a>安装与配置git</h1><p>安装git的环境，在这<a href="https://lyroom.github.io/2024/05/10/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%81%E7%A7%BB/">里有</a>详细的解答,便不过多赘述了。</p><h1 id="git学习"><a href="#git学习" class="headerlink" title="git学习"></a>git学习</h1><p>这是git操作的基本流程</p><span id="more"></span><img src="/2024/10/11/github%E5%AD%A6%E4%B9%A0/GitHub.webp" class=""><blockquote><p>Repository,index,workspace，都存储在本地</p></blockquote><h2 id="一-git的基本操作（这部分由master完成）"><a href="#一-git的基本操作（这部分由master完成）" class="headerlink" title="一. git的基本操作（这部分由master完成）"></a>一. git的基本操作（这部分由master完成）</h2><h3 id="git-init-初始化一个本地仓库"><a href="#git-init-初始化一个本地仓库" class="headerlink" title="git init-初始化一个本地仓库"></a>git init-初始化一个本地仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init <span class="comment">#初始化了一个本地仓库，建立了一个.git文件夹</span></span><br></pre></td></tr></table></figure><p>这是git init后当前文件夹的目录结构图，将仓库，暂存区和工作树（项目本地目录）都确定下来了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">githublearning</span><br><span class="line">    ├── .git</span><br><span class="line">    │   ├── branches</span><br><span class="line">    │   ├── COMMIT_EDITMSG</span><br><span class="line">    │   ├── config</span><br><span class="line">    │   ├── description</span><br><span class="line">    │   ├── HEAD</span><br><span class="line">    │   ├── hooks</span><br><span class="line">    │   ├── index</span><br><span class="line">    │   ├── info</span><br><span class="line">    │   ├── logs</span><br><span class="line">    │   ├── objects</span><br><span class="line">    │   └── refs</span><br><span class="line">    ├── git学习.md</span><br><span class="line">    ├── GitHub.webp</span><br><span class="line">    └── README.md</span><br></pre></td></tr></table></figure><ul><li><p><strong>工作树</strong>：.git所在的目录，就是workplace。本例中就是githublearning文件夹，该文件夹内的内容就是需要版本控制的文件</p></li><li><p><strong>暂存区</strong>：.git下的index的文件</p></li><li><p><strong>仓库</strong>：.git文件夹就是仓库</p><p>​**<code>HEAD</code>**：这是一个指向当前活动分支的引用，它告诉 Git 你当前处在哪个分支上。</p><p>​**<code>config</code>**：存储仓库级别的配置信息，如用户信息、远程仓库地址等。</p><p>​**<code>refs</code>**：存储分支（<code>refs/heads/</code>）、标签（<code>refs/tags/</code>）等引用。每个分支和标签都指向特定的提交对象。</p><p>​**<code>objects</code>**：存储 Git 对象（提交、树、文件 blob）的数据库。Git 是通过哈希（SHA-1 值）来存储每个对象的，确保了内容的唯一性和完整性。</p><p>​**<code>index</code>**：即暂存区，用于存储那些你已经用 <code>git add</code> 命令暂存的更改，准备提交时从这里取数据。</p><p>​**<code>logs</code>**：保存引用的历史，记录了每个分支或引用的变更日志，便于追踪。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status <span class="comment">#记录着当前处于master还是branch分支，有无需要commit的文件等</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##以下是状态</span></span><br><span class="line">位于分支 master</span><br><span class="line">要提交的变更：</span><br><span class="line">  （使用 <span class="string">&quot;git restore --staged &lt;文件&gt;...&quot;</span> 以取消暂存）</span><br><span class="line">        修改：     <span class="string">&quot;git\345\255\246\344\271\240.md&quot;</span></span><br></pre></td></tr></table></figure><h3 id="gid-add-向暂存区添加文件"><a href="#gid-add-向暂存区添加文件" class="headerlink" title="gid add-向暂存区添加文件"></a>gid add-向暂存区添加文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add xxx.cpp <span class="comment">#上传一个xxx.cpp文件</span></span><br><span class="line">git add -A <span class="comment">#上传当前文件夹下的所有文件</span></span><br><span class="line">git add . <span class="comment">#同上</span></span><br></pre></td></tr></table></figure><h3 id="git-commit-提交到本地仓库"><a href="#git-commit-提交到本地仓库" class="headerlink" title="git commit-提交到本地仓库"></a>git commit-提交到本地仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m “本次提交的备注” <span class="comment">#上传到master分支，并打上备注</span></span><br><span class="line">$ git commit <span class="comment">#可以直接commit，之后再详细编辑备注</span></span><br></pre></td></tr></table></figure><h3 id="git-log-查看提交日志"><a href="#git-log-查看提交日志" class="headerlink" title="git log-查看提交日志"></a>git log-查看提交日志</h3><p>查看全部日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##以下是日志内容</span></span><br><span class="line">commit b3f611dafea403f51c52a04491a23e1e4e059190 (HEAD -&gt; master)</span><br><span class="line">Author: lyroom &lt;codingfish@outlook.com&gt;</span><br><span class="line">Date:   Sat Oct 12 13:07:04 2024 +0800</span><br><span class="line"></span><br><span class="line">    这是我的第二次详细修改</span><br><span class="line">    </span><br><span class="line">    xxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line"></span><br><span class="line">commit d1f94f3bb752ad1fc2551cd9ccb06c8eee5a39c8</span><br><span class="line">Author: lyroom &lt;codingfish@outlook.com&gt;</span><br><span class="line">Date:   Sat Oct 12 13:04:45 2024 +0800</span><br><span class="line"></span><br><span class="line">    第一次提交</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>查看日志常用快捷键：和man操作，less操作基本一样<br>f：往后翻一页<br>b：往前翻一页</p></blockquote><p>也可以简短一行的输出每次提交的修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=short</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##以下是日志内容</span></span><br><span class="line">commit b3f611dafea403f51c52a04491a23e1e4e059190 (HEAD -&gt; master)</span><br><span class="line">Author: lyroom &lt;codingfish@outlook.com&gt;</span><br><span class="line">Date:   Sat Oct 12 13:07:04 2024 +0800</span><br><span class="line"></span><br><span class="line">    这是我的第二次详细修改</span><br><span class="line"></span><br><span class="line">commit d1f94f3bb752ad1fc2551cd9ccb06c8eee5a39c8</span><br><span class="line">Author: lyroom &lt;codingfish@outlook.com&gt;</span><br><span class="line">Date:   Sat Oct 12 13:04:45 2024 +0800</span><br><span class="line"></span><br><span class="line">    第一次提交</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以查看文件前后修改的对比</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -p README.md</span><br><span class="line"></span><br><span class="line"><span class="comment">##以下是对比内容</span></span><br><span class="line">Author: lyroom &lt;codingfish@outlook.com&gt;</span><br><span class="line">Date:   Sat Oct 12 15:33:31 2024 +0800</span><br><span class="line"></span><br><span class="line">    这是第七次修改</span><br><span class="line"></span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 5f9894b..ffbea86 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> 第六次修改</span><br><span class="line">+第七次修改</span><br></pre></td></tr></table></figure><p>也可以以<a href="#git-log-%E4%BB%A5%E5%9B%BE%E8%A1%A8%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%9F%A5%E7%9C%8B%E5%88%86%E6%94%AF">图形的方式查看提交历史</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph</span><br></pre></td></tr></table></figure><h3 id="git-diff-查看更改前后的区别"><a href="#git-diff-查看更改前后的区别" class="headerlink" title="git diff-查看更改前后的区别"></a>git diff-查看更改前后的区别</h3><p>git diff命令可以查看工作树、暂存区、仓库最新提交之间的差别。</p><h4 id="查看工作树和暂存区的区别"><a href="#查看工作树和暂存区的区别" class="headerlink" title="查看工作树和暂存区的区别"></a>查看工作树和暂存区的区别</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure><p>vscode配合gitlens插件可以清楚看到本地工作目录（左边）和暂存区（右边）的区别，红色表示删除，绿色表示新添加的内容</p><img src="/2024/10/11/github%E5%AD%A6%E4%B9%A0/gitdiffvscode.png" class=""><p>当然使用git diff命令也能明显的看出区别，如下,+代表添加或者修改，-代表删除内容：<br><img src="/2024/10/11/github学习/gitdiff.png"  style="zoom: 80%;" /><br>这两种方法都可以看出工作树和暂存区的区别<br>当我git add -A后，git diff就无任何输出了</p><h4 id="查看工作树和本地仓库最新提交的差别"><a href="#查看工作树和本地仓库最新提交的差别" class="headerlink" title="查看工作树和本地仓库最新提交的差别"></a>查看工作树和本地仓库最新提交的差别</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD</span><br></pre></td></tr></table></figure><p>由于本地工作树和暂存区内容是一样的， 这个命令比较的就是仓库的最新提交和工作树的区别，比较的结果形式和上面的比较是一样的，就不贴图了</p><h2 id="二-分支操作（本部分由分支1完成）"><a href="#二-分支操作（本部分由分支1完成）" class="headerlink" title="二. 分支操作（本部分由分支1完成）"></a>二. 分支操作（本部分由分支1完成）</h2><p>通常一个大型的项目视需要多人合作完成的，每个人负责不同的模块和功能，这通常是并行进行的，所以我们需要分支进行，在各自的功能没有完全上线，各个分支和已经上线的程序master应互不干扰！<br><img src="/2024/10/11/github学习/branch.png"  style="zoom:67%;" /><br>分支1完成后，需要与master合并<br><img src="/2024/10/11/github学习/branch1.png"  style="zoom:80%;" /></p><h3 id="git-branch-显示所有的分支"><a href="#git-branch-显示所有的分支" class="headerlink" title="git branch-显示所有的分支"></a>git branch-显示所有的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>当前只有一个master分支，*指向了master分支，表示当前处于master分支下</p><h3 id="git-checkout-b-创建切换分支"><a href="#git-checkout-b-创建切换分支" class="headerlink" title="git checkout -b-创建切换分支"></a>git checkout -b-创建切换分支</h3><h4 id="创建切换分支1"><a href="#创建切换分支1" class="headerlink" title="创建切换分支1"></a>创建切换分支1</h4><p>创建一个名字为分支1的分支，并切换到分支1下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b 分支1</span><br></pre></td></tr></table></figure><p>查看结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  master</span><br><span class="line">* 分支1</span><br></pre></td></tr></table></figure><p>等价操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支1 <span class="comment">#创建一个名为分支1的分支</span></span><br><span class="line">git checkout 分支1 <span class="comment">#切换到分支1下</span></span><br></pre></td></tr></table></figure><p>提交修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&quot;分支1的第一次提交&quot;</span></span><br></pre></td></tr></table></figure><h4 id="切换到到master分支"><a href="#切换到到master分支" class="headerlink" title="切换到到master分支"></a>切换到到master分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master <span class="comment">#切换到主分支</span></span><br></pre></td></tr></table></figure><p>继续查看当前文件大纲，发现<strong>master分支的大纲</strong>并没有分支1的这部分的文字，如下图：</p><img src="/2024/10/11/github%E5%AD%A6%E4%B9%A0/master%E4%B8%8B%E7%9A%84%E5%88%86%E6%94%AF.png" class=""><p>而在<strong>分支1的大纲</strong>是这样的：</p><img src="/2024/10/11/github%E5%AD%A6%E4%B9%A0/%E5%88%86%E6%94%AF1.png" class=""><h4 id="切换到上一个分支"><a href="#切换到上一个分支" class="headerlink" title="切换到上一个分支"></a>切换到上一个分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -</span><br></pre></td></tr></table></figure><h3 id="分支的删除"><a href="#分支的删除" class="headerlink" title="分支的删除"></a>分支的删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 分支名</span><br><span class="line">$ git branch -d 分支1</span><br><span class="line"></span><br><span class="line">已删除分支 分支1（曾为 6dfa1e7）。</span><br></pre></td></tr></table></figure><h3 id="分支的分类"><a href="#分支的分类" class="headerlink" title="分支的分类"></a>分支的分类</h3><p>在 GitHub 或 Git 版本控制系统中，<strong>特性分支</strong>（feature branch）和<strong>主干分支</strong>（通常是 <code>main</code> 或 <code>master</code> 分支）是两种常见的分支类型，它们用于不同的开发目的：</p><h4 id="1-主干分支（Main-x2F-Master-Branch）"><a href="#1-主干分支（Main-x2F-Master-Branch）" class="headerlink" title="1. 主干分支（Main&#x2F;Master Branch）"></a>1. <strong>主干分支（Main&#x2F;Master Branch）</strong></h4><ul><li><strong>作用</strong>：主干分支是项目的稳定版本，通常包含可部署的代码。它是团队协作时的主分支，代表项目当前的生产环境代码。</li><li><strong>特点</strong>：<ul><li>代码通常是稳定的、经过测试的版本。</li><li>项目的发布版本往往基于主干分支。</li><li>只有当代码经过充分测试、代码审核通过后，才会合并到主干分支。</li></ul></li></ul><h4 id="2-特性分支（Feature-Branch）"><a href="#2-特性分支（Feature-Branch）" class="headerlink" title="2. 特性分支（Feature Branch）"></a>2. <strong>特性分支（Feature Branch）</strong></h4><ul><li><strong>作用</strong>：特性分支用于开发某个特定的功能或修复某个 bug。每个新功能、改进或问题修复通常会创建一个单独的特性分支，以便与主干分支保持隔离，确保主干分支的稳定性。</li><li><strong>特点</strong>：<ul><li>每个特性分支的命名通常与开发的功能相关，如 <code>feature/login-system</code> 或 <code>feature/add-profile-page</code>。</li><li>开发人员可以自由地在特性分支上进行实验，而不会影响到其他开发者的工作或主干分支的稳定性。</li><li>开发完成后，特性分支会通过 Pull Request 进行代码审核，测试通过后才合并到主干分支。<br>流程：</li></ul></li></ul><ol><li>从主干分支拉取最新代码，创建一个新的特性分支。</li><li>在特性分支上开发和测试功能。</li><li>开发完成后，提交 Pull Request 以请求将特性分支的代码合并到主干分支。</li><li>经过代码审核和测试，确认无问题后合并到主干分支。</li></ol><p>这种分支模型能够帮助团队并行开发不同功能，同时确保主干分支始终保持在一个稳定的状态。</p><h3 id="git-merge-分支的合并"><a href="#git-merge-分支的合并" class="headerlink" title="git merge-分支的合并"></a>git merge-分支的合并</h3><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p>分支1已经完成了当前的功能，需要与master合并<br>1.切换回主干分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>2.合并分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff 分支1</span><br></pre></td></tr></table></figure><h4 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h4><p>每次的合并并都不是一帆风顺的，如果分支修改了相同的文件，就会产生冲突，需要<strong>手动解决冲突</strong><br>以下是合并后的报错，提示有冲突：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff 分支1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">自动合并 git学习.md</span><br><span class="line">冲突（内容）：合并冲突于 git学习.md</span><br><span class="line">自动合并失败，修正冲突然后提交修正的结果。</span><br></pre></td></tr></table></figure><p>解决办法：</p><h5 id="1-查看合并的状态，找到冲突的文件"><a href="#1-查看合并的状态，找到冲突的文件" class="headerlink" title="1.查看合并的状态，找到冲突的文件"></a>1.查看合并的状态，找到冲突的文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">位于分支 master</span><br><span class="line">您的分支领先 <span class="string">&#x27;origin/master&#x27;</span> 共 20 个提交。</span><br><span class="line">  （使用 <span class="string">&quot;git push&quot;</span> 来发布您的本地提交）</span><br><span class="line"></span><br><span class="line">您有尚未合并的路径。</span><br><span class="line">  （解决冲突并运行 <span class="string">&quot;git commit&quot;</span>）</span><br><span class="line">  （使用 <span class="string">&quot;git merge --abort&quot;</span> 终止合并）</span><br><span class="line"></span><br><span class="line">未合并的路径：</span><br><span class="line">  （使用 <span class="string">&quot;git add &lt;文件&gt;...&quot;</span> 标记解决方案）</span><br><span class="line">        双方修改：   README.md</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 <span class="string">&quot;git add&quot;</span> 和/或 <span class="string">&quot;git commit -a&quot;</span>）</span><br></pre></td></tr></table></figure><h5 id="2-打开冲突的文件（README-md），解决冲突"><a href="#2-打开冲突的文件（README-md），解决冲突" class="headerlink" title="2.打开冲突的文件（README.md），解决冲突"></a>2.打开冲突的文件（README.md），解决冲突</h5><p>打开文件，会发现文件中有以下的标注，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD（当前分支的内容）</span><br><span class="line">这是当前分支的内容</span><br><span class="line">======= # 分割线，上面的是master内容，下面是分支1的内容</span><br><span class="line">这是branch修改的的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch（传入合并分支的内容）</span><br></pre></td></tr></table></figure><center><img src="/2024/10/11/github学习/readme冲突.png"  style="zoom:67%;" /></center><p>可以手动的选择要保留的内容，保留后，删除’&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD’，’&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ‘，’&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch’，等标注，保存文件即可。</p><h5 id="3-提交解决冲突后的文件"><a href="#3-提交解决冲突后的文件" class="headerlink" title="3.提交解决冲突后的文件"></a>3.提交解决冲突后的文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;解决冲突&quot;</span></span><br></pre></td></tr></table></figure><h5 id="4-合并完成"><a href="#4-合并完成" class="headerlink" title="4.合并完成"></a>4.合并完成</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 分支1</span><br></pre></td></tr></table></figure><h3 id="git-log-以图表的形式查看分支"><a href="#git-log-以图表的形式查看分支" class="headerlink" title="git log-以图表的形式查看分支"></a>git log-以图表的形式查看分支</h3><p>可以以图形的方式查看分支的合并情况，并且看到分支的提交记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*   commit 307375175df620d5a6e9e913a0c92a61c5af91a7 (HEAD -&gt; master)</span><br><span class="line">|\  Merge: 788c7a9 c4687fb</span><br><span class="line">| | Author: lyroom &lt;codingfish@outlook.com&gt;</span><br><span class="line">| | Date:   Tue Oct 15 09:32:29 2024 +0800</span><br><span class="line">| | </span><br><span class="line">| |     Merge branch <span class="string">&#x27;分支1&#x27;</span></span><br><span class="line">| | </span><br><span class="line">| * commit c4687fbd37f633b82b74ad6048daf356610b4c03 (分支1)</span><br><span class="line">| | Author: lyroom &lt;codingfish@outlook.com&gt;</span><br><span class="line">| | Date:   Tue Oct 15 09:31:23 2024 +0800</span><br><span class="line">| | </span><br><span class="line">| |     这是分支一的第五次修改</span><br><span class="line">| | </span><br><span class="line">* | commit 788c7a90543f684b062e3b514db4adcbdd52cf99</span><br><span class="line">| | Author: lyroom &lt;codingfish@outlook.com&gt;</span><br><span class="line">| | Date:   Tue Oct 15 09:27:33 2024 +0800</span><br><span class="line">| | </span><br><span class="line">| |     master merge后的第一次提交</span><br><span class="line">| | </span><br><span class="line">* | commit c9cc7dcb6d5283b0dfd4fc149d067c70940a867f</span><br><span class="line">| | Author: lyroom &lt;codingfish@outlook.com&gt;</span><br><span class="line">| | Date:   Tue Oct 15 09:23:37 2024 +0800</span><br><span class="line">| | </span><br><span class="line">| |     real mergegit add -A!</span><br><span class="line">| | </span><br><span class="line">* | commit ac08a828e2279d605a40a6a3d674ec78b7cdf949</span><br><span class="line">|\| Merge: 9c20e8d 3aa2344</span><br><span class="line">| | Author: lyroom &lt;codingfish@outlook.com&gt;</span><br><span class="line">| | Date:   Tue Oct 15 09:16:17 2024 +0800</span><br><span class="line">| | </span><br><span class="line">| |     第一次合并后的提交</span><br><span class="line">| | </span><br><span class="line">| * commit 3aa23441ddb6cdf4ff390d191b69850395fd2e6c</span><br><span class="line">| | Author: lyroom &lt;codingfish@outlook.com&gt;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="三-更改提交的操作"><a href="#三-更改提交的操作" class="headerlink" title="三. 更改提交的操作"></a>三. 更改提交的操作</h2><h3 id="git-reset-回溯历史版本"><a href="#git-reset-回溯历史版本" class="headerlink" title="git reset-回溯历史版本"></a>git reset-回溯历史版本</h3><p>为了有助于学习，我们先回到创建分支1的时候，然后创建一个fix—B的特性分支<br><img src="/2024/10/11/github学习/fix-B.png"  style="zoom:67%;" /></p><h4 id="回到分支1创建前"><a href="#回到分支1创建前" class="headerlink" title="回到分支1创建前"></a>回到分支1创建前</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard <span class="built_in">hash</span>值 <span class="comment">#这个hash值就是每次commit后的hash值</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你没有做好标记寻找创建分支前的hash值的技巧：git log –graph ,找到分叉前的一个提交的hash值!，如下就是第8次修改的hash值</p><p>| | Author: lyroom <a href="mailto:&#x63;&#x6f;&#x64;&#105;&#x6e;&#x67;&#x66;&#105;&#115;&#104;&#64;&#x6f;&#117;&#116;&#x6c;&#x6f;&#x6f;&#107;&#46;&#99;&#x6f;&#109;">&#x63;&#x6f;&#x64;&#105;&#x6e;&#x67;&#x66;&#105;&#115;&#104;&#64;&#x6f;&#117;&#116;&#x6c;&#x6f;&#x6f;&#107;&#46;&#99;&#x6f;&#109;</a></p><p>| | Date:   Mon Oct 14 16:59:48 2024 +0800</p><p>| | </p><p>| |     master的第10次提交</p><p>| | </p><p>* | commit 7362bced26a2648153fac6779e4c5d2067eab42b</p><p>|&#x2F;  Author: lyroom <a href="mailto:&#x63;&#x6f;&#x64;&#105;&#x6e;&#x67;&#x66;&#105;&#115;&#x68;&#x40;&#111;&#117;&#116;&#108;&#x6f;&#111;&#107;&#x2e;&#99;&#x6f;&#109;">&#x63;&#x6f;&#x64;&#105;&#x6e;&#x67;&#x66;&#105;&#115;&#x68;&#x40;&#111;&#117;&#116;&#108;&#x6f;&#111;&#107;&#x2e;&#99;&#x6f;&#109;</a></p><p>|   Date:   Mon Oct 14 16:57:45 2024 +0800</p><p>|   </p><p>|       master下的第九次修改</p><p>| </p><p>* commit 61126b34e2330bad3945c616374df80de7346be1</p><p>| Author: lyroom <a href="mailto:&#99;&#111;&#x64;&#x69;&#110;&#103;&#102;&#x69;&#115;&#104;&#x40;&#x6f;&#x75;&#x74;&#x6c;&#111;&#111;&#107;&#46;&#99;&#111;&#109;">&#99;&#111;&#x64;&#x69;&#110;&#103;&#102;&#x69;&#115;&#104;&#x40;&#x6f;&#x75;&#x74;&#x6c;&#111;&#111;&#107;&#46;&#99;&#111;&#109;</a></p><p>| Date:   Mon Oct 14 16:17:33 2024 +0800</p><p>| </p><p>|     第8次修改</p><p>| </p><p>* commit ce7d1ccfd971bed9e79a3ececcdb67df97428692</p><p>| Author: lyroom <a href="mailto:&#99;&#111;&#100;&#105;&#110;&#x67;&#102;&#105;&#115;&#x68;&#64;&#111;&#117;&#x74;&#108;&#x6f;&#x6f;&#107;&#x2e;&#x63;&#111;&#109;">&#99;&#111;&#100;&#105;&#110;&#x67;&#102;&#105;&#115;&#x68;&#64;&#111;&#117;&#x74;&#108;&#x6f;&#x6f;&#107;&#x2e;&#x63;&#111;&#109;</a></p><p>| Date:   Mon Oct 14 16:15:19 2024 +0800</p></blockquote><h3 id="创建分支fix-B"><a href="#创建分支fix-B" class="headerlink" title="创建分支fix-B"></a>创建分支fix-B</h3><p>当前状态：<br><img src="/2024/10/11/github学习/分支fix-B.png"  style="zoom:80%;" /><br>fix-B的下一个目标：<br><img src="/2024/10/11/github学习/next.png"  style="zoom:67%;" /></p><h3 id="回溯到分支1合并后的状态"><a href="#回溯到分支1合并后的状态" class="headerlink" title="回溯到分支1合并后的状态"></a>回溯到分支1合并后的状态</h3><h4 id="git-reflog-查看当前仓库的操作日志"><a href="#git-reflog-查看当前仓库的操作日志" class="headerlink" title="git  reflog-查看当前仓库的操作日志"></a>git  reflog-查看当前仓库的操作日志</h4><p>使用git reflog查看当前仓库的操作日志，找到回溯之前的hash值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line"></span><br><span class="line">d261a61 (HEAD -&gt; 分支1) HEAD@&#123;0&#125;: commit: 来自分支1的修改</span><br><span class="line">65f7981 HEAD@&#123;1&#125;: checkout: moving from fix-B to 分支1</span><br><span class="line">083f020 (fix-B) HEAD@&#123;2&#125;: commit: 创建fix-B</span><br><span class="line">61126b3 (master) HEAD@&#123;3&#125;: checkout: moving from master to fix-B</span><br><span class="line">61126b3 (master) HEAD@&#123;4&#125;: checkout: moving from 分支1 to master</span><br><span class="line">65f7981 HEAD@&#123;5&#125;: commit: 分支1的修改</span><br><span class="line">3574200 HEAD@&#123;6&#125;: checkout: moving from master to 分支1</span><br><span class="line">61126b3 (master) HEAD@&#123;7&#125;: reset: moving to 61126b34e2330bad3945c616374df80de7346be1</span><br><span class="line">f77bdd9 HEAD@&#123;8&#125;: checkout: moving from 分支1 to master</span><br></pre></td></tr></table></figure><p>回溯：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard f77bdd9</span><br></pre></td></tr></table></figure><p>目前状态如下：<br><img src="/2024/10/11/github学习/next01.png"  style="zoom:67%;" /><br>合并fix-B到master:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff fix-B</span><br></pre></td></tr></table></figure><p>消除冲突后，达到最终状态：<br><img src="/2024/10/11/github学习/next.png"  style="zoom:67%;" /></p><h3 id="git-commit-–amend-修改最新的一次commit信息"><a href="#git-commit-–amend-修改最新的一次commit信息" class="headerlink" title="git commit –amend-修改最新的一次commit信息"></a>git commit –amend-修改最新的一次commit信息</h3><p>查看git log:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">commit b8c8f1ba295a524f8b85593aa2cde9c233900e61 (HEAD -&gt; master)</span><br><span class="line">Merge: ac54cd9 083f020</span><br><span class="line">Author: lyroom &lt;codingfish@outlook.com&gt;</span><br><span class="line">Date:   Tue Oct 15 13:36:28 2024 +0800</span><br><span class="line"></span><br><span class="line">    master和fix-B冲突消除</span><br></pre></td></tr></table></figure><p>上次在消除冲突后，master又commit一次，这次提交本质是无意义的，因为没有冲突，就不需要提交了，因此需要修改提交备注信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>修改提交信息为：合并master和fix-B：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">commit 9441272bca5d390e54cfd05ba8b6ead3412c72b7 (HEAD -&gt; master)</span><br><span class="line">Merge: ac54cd9 083f020</span><br><span class="line">Author: lyroom &lt;codingfish@outlook.com&gt;</span><br><span class="line">Date:   Tue Oct 15 13:36:28 2024 +0800</span><br><span class="line"></span><br><span class="line">    合并master和fix-B</span><br></pre></td></tr></table></figure><p>这样就修改成功了，除了备注不一样，其他信息都一样。</p><h3 id="git-rebase-i-修改历史提交信息"><a href="#git-rebase-i-修改历史提交信息" class="headerlink" title="git rebase -i-修改历史提交信息"></a>git rebase -i-修改历史提交信息</h3><p>当我们提交了多次，但是发现这些提交工作树的内容都一样，或者无关紧要的好几次commit。如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">commit 2979c94b8b6269cfb16c01a730098d6b2ec6ad4a (HEAD -&gt; master)</span><br><span class="line">Author: lyroom &lt;codingfish@outlook.com&gt;</span><br><span class="line">Date:   Tue Oct 15 14:02:40 2024 +0800</span><br><span class="line"></span><br><span class="line">    又添加了几个空格,修改3次</span><br><span class="line"></span><br><span class="line">commit d81aa63d0f933bf1b0d49cb98a197eb55eb26c55</span><br><span class="line">Author: lyroom &lt;codingfish@outlook.com&gt;</span><br><span class="line">Date:   Tue Oct 15 13:56:44 2024 +0800</span><br><span class="line"></span><br><span class="line">    删除了几个多余字母,修改2次</span><br><span class="line"></span><br><span class="line">commit d63d466638457b1923c83d79b908e327e5fe56e7</span><br><span class="line">Author: lyroom &lt;codingfish@outlook.com&gt;</span><br><span class="line">Date:   Tue Oct 15 13:56:03 2024 +0800</span><br><span class="line"></span><br><span class="line">    删除了几个空格,修改1次</span><br></pre></td></tr></table></figure><p>这些仅仅都是些微的修改，但是提交了多次，我们可以使用git rebase -i命令，修改合并这些提交信息。如下：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~3 <span class="comment"># 修改最近3次提交信息</span></span><br></pre></td></tr></table></figure><p>合并后的commit的hash值，时间和最新的一致，但是提交信息已经修改了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">commit 2979c94b8b6269cfb16c01a730098d6b2ec6ad4a (HEAD -&gt; master)</span><br><span class="line">Author: lyroom &lt;codingfish@outlook.com&gt;</span><br><span class="line">Date:   Tue Oct 15 14:02:40 2024 +0800</span><br><span class="line"></span><br><span class="line">    合并备注信息</span><br></pre></td></tr></table></figure><blockquote><p>虽然’git rebase -i’ 和 ‘git commit –amend’ 都能修改commit的备注信息，但是<br>‘git rebase -i’ 可以合并多次提交，<br>‘git commit –amend’ 只能修改最近一次提交的备注信息。</p></blockquote><h2 id="四-推送至远程仓库"><a href="#四-推送至远程仓库" class="headerlink" title="四. 推送至远程仓库"></a>四. 推送至远程仓库</h2><p>前面的所有操作都是基于本地的操作，接下来我们要进行的是远程仓库的操作。</p><p>当然前提是你需要在github创建一个仓库，如果本地写了README.md就不要勾选创建README.md文档了</p><h3 id="1-git-remote-add-添加远程仓库"><a href="#1-git-remote-add-添加远程仓库" class="headerlink" title="1. git remote add-添加远程仓库"></a>1. git remote add-添加远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;远程名称&gt; &lt;远程仓库URL&gt; <span class="comment"># 添加远程仓库命令格式</span></span><br><span class="line">git remote add origin https://github.com/yourusername/your-repo.git <span class="comment"># https方式添加仓库</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;远程名称&gt;</code>：为远程仓库指定的别名，常用的是 <code>origin</code>，但您可以根据需要自定义名称。</li><li><code>&lt;远程仓库URL&gt;</code>：远程仓库的实际地址。它可以是 HTTPS 或 SSH 的 URL，格式如下：<ul><li>HTTPS: <code>https://github.com/user/repo.git</code></li><li>SSH: <code>git@github.com:user/repo.git</code></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/lyroom/githublearning.git <span class="comment">#用户名：lyroom,仓库名字：githublearning</span></span><br><span class="line">$ git remote -v <span class="comment">#查看远程仓库和url</span></span><br><span class="line"></span><br><span class="line">originhttps://github.com/lyroom/githublearning.git (fetch)</span><br><span class="line">originhttps://github.com/lyroom/githublearning.git (push)</span><br></pre></td></tr></table></figure><h3 id="2-git-push-推送本地仓库到远程仓库"><a href="#2-git-push-推送本地仓库到远程仓库" class="headerlink" title="2.git push-推送本地仓库到远程仓库"></a>2.git push-推送本地仓库到远程仓库</h3><h4 id="推送至远程仓库master分支"><a href="#推送至远程仓库master分支" class="headerlink" title="推送至远程仓库master分支"></a>推送至远程仓库master分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master <span class="comment">#推送本地仓库到远程仓库 u:upstream上游的缩写，</span></span><br><span class="line">    <span class="comment"># -u :将oring设置为上游仓库</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">枚举对象中: 111, 完成.</span><br><span class="line">对象计数中: 100% (111/111), 完成.</span><br><span class="line">使用 20 个线程进行压缩</span><br><span class="line">压缩对象中: 100% (102/102), 完成.</span><br><span class="line">写入对象中: 100% (108/108), 1.18 MiB | 28.73 MiB/s, 完成.</span><br><span class="line">总共 108（差异 51），复用 0（差异 0），包复用 0</span><br><span class="line">remote: Resolving deltas: 100% (51/51), <span class="keyword">done</span>.</span><br><span class="line">To https://github.com/lyroom/githublearning.git</span><br><span class="line">   e362a53..99a3c4e  master -&gt; master</span><br><span class="line">分支 <span class="string">&#x27;master&#x27;</span> 设置为跟踪来自 <span class="string">&#x27;origin&#x27;</span> 的远程分支 <span class="string">&#x27;master&#x27;</span>。</span><br></pre></td></tr></table></figure><h4 id="推送至远程仓库master以外分支"><a href="#推送至远程仓库master以外分支" class="headerlink" title="推送至远程仓库master以外分支"></a>推送至远程仓库master以外分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout fix-B <span class="comment">#切换到fix-B分支</span></span><br><span class="line">$ git push -u origin  fix-B <span class="comment">#推送本地分支fix-B到远程仓库</span></span><br></pre></td></tr></table></figure><img src="/2024/10/11/github学习/branchs.png"  style="zoom: 80%;" /><h2 id="五-从远程仓库获取"><a href="#五-从远程仓库获取" class="headerlink" title="五.从远程仓库获取"></a>五.从远程仓库获取</h2><h3 id="1-git-clone-克隆远程仓库到本地"><a href="#1-git-clone-克隆远程仓库到本地" class="headerlink" title="1.git clone-克隆远程仓库到本地"></a>1.git clone-克隆远程仓库到本地</h3><h4 id="获取远程仓库（master）"><a href="#获取远程仓库（master）" class="headerlink" title="获取远程仓库（master）"></a>获取远程仓库（master）</h4><p>  首先我们切换到其他目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/lyroom/githublearning.git <span class="comment">#克隆远程仓库到本地</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">正克隆到 <span class="string">&#x27;githublearning&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 132, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (132/132), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (62/62), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 132 (delta 58), reused 131 (delta 57), pack-reused 0 (from 0)</span><br><span class="line">接收对象中: 100% (132/132), 1.18 MiB | 3.06 MiB/s, 完成.</span><br><span class="line">处理 delta 中: 100% (58/58), 完成.</span><br></pre></td></tr></table></figure><p>执行完成之后我们默认处于master分支下，并且和远程仓库master&#x2F;main分支的内容是一样的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch </span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h4 id="获取远程仓库（非master）"><a href="#获取远程仓库（非master）" class="headerlink" title="获取远程仓库（非master）"></a>获取远程仓库（非master）</h4><h5 id="git-branch-a-查看远程分支"><a href="#git-branch-a-查看远程分支" class="headerlink" title="git branch -a-查看远程分支"></a>git branch -a-查看远程分支</h5><p>我们可以使用git branch -a查看远程和本地的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/fix-B</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><p>可以看到本地只有master分支，远程有master和fix-B分支</p><blockquote><p>注意：我们已经切换了文件夹(gitlearning—&gt;githublearning)，所以之前本地仓库只上传了master和fix-B分支,不要和之前的仓库搞混了</p></blockquote><h5 id="git-checkout-b-克隆远程仓库的fix-B分支到本地"><a href="#git-checkout-b-克隆远程仓库的fix-B分支到本地" class="headerlink" title="git checkout -b-克隆远程仓库的fix-B分支到本地"></a>git checkout -b-克隆远程仓库的fix-B分支到本地</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b fix-B origin/fix-B <span class="comment">#克隆远程仓库的fix-B分支到本地</span></span><br><span class="line">  <span class="comment">#-b：创建分支并切换到fix-B分支</span></span><br></pre></td></tr></table></figure><h5 id="向本地的fix-B分支提交更改"><a href="#向本地的fix-B分支提交更改" class="headerlink" title="向本地的fix-B分支提交更改"></a>向本地的fix-B分支提交更改</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am <span class="string">&quot;向本地的fix-B添加了内容&quot;</span> <span class="comment">#向本地的fix-B分支提交更改</span></span><br></pre></td></tr></table></figure><h5 id="推送fix-B分支到远程仓库"><a href="#推送fix-B分支到远程仓库" class="headerlink" title="推送fix-B分支到远程仓库"></a>推送fix-B分支到远程仓库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git push <span class="comment">#推送本地的fix-B分支到远程仓库</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">枚举对象中: 5, 完成.</span><br><span class="line">对象计数中: 100% (5/5), 完成.</span><br><span class="line">使用 20 个线程进行压缩</span><br><span class="line">压缩对象中: 100% (3/3), 完成.</span><br><span class="line">写入对象中: 100% (3/3), 367 字节 | 367.00 KiB/s, 完成.</span><br><span class="line">总共 3（差异 1），复用 0（差异 0），包复用 0</span><br><span class="line">remote: Resolving deltas: 100% (1/1), completed with 1 <span class="built_in">local</span> object.</span><br><span class="line">To https://github.com/lyroom/githublearning.git</span><br><span class="line">   083f020..bfde7fb  fix-B -&gt; fix-B</span><br></pre></td></tr></table></figure><h3 id="2-git-pull-拉取远程仓库到本地仓库"><a href="#2-git-pull-拉取远程仓库到本地仓库" class="headerlink" title="2.git pull-拉取远程仓库到本地仓库"></a>2.git pull-拉取远程仓库到本地仓库</h3><p>刚刚在githublearning的仓库中修改了fix-B分支的内容并且上传到了github，但是我们gitlearnging仓库中的fix-B分支并没有更新，所以我们需要拉取远程仓库的fix-B分支到本地仓库</p><blockquote><p>注意要切换到最开始的项目目录(githublearning—&gt;gitlearning)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout fix-B <span class="comment">#切换到fix-B分支</span></span><br><span class="line">$ git pull origin fix-B <span class="comment">#拉取远程仓库的master分支到本地仓库</span></span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="GitHub%E5%85%A5%E9%97%A8%E4%B8%8E%E8%B7%B5.pdf">GitHub 入门与实践</a><br><a href="https://github.com/lyroom/githublearning">本项目github地址</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文会较为详细的学习github的一些操作，以下是具体的步骤。&lt;/p&gt;
&lt;h1 id=&quot;安装与配置git&quot;&gt;&lt;a href=&quot;#安装与配置git&quot; class=&quot;headerlink&quot; title=&quot;安装与配置git&quot;&gt;&lt;/a&gt;安装与配置git&lt;/h1&gt;&lt;p&gt;安装git的环境，在这&lt;a href=&quot;https://lyroom.github.io/2024/05/10/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%81%E7%A7%BB/&quot;&gt;里有&lt;/a&gt;详细的解答,便不过多赘述了。&lt;/p&gt;
&lt;h1 id=&quot;git学习&quot;&gt;&lt;a href=&quot;#git学习&quot; class=&quot;headerlink&quot; title=&quot;git学习&quot;&gt;&lt;/a&gt;git学习&lt;/h1&gt;&lt;p&gt;这是git操作的基本流程&lt;/p&gt;</summary>
    
    
    
    
    <category term="github" scheme="https://lyroom.github.io/tags/github/"/>
    
    <category term="git" scheme="https://lyroom.github.io/tags/git/"/>
    
  </entry>
  
</feed>
